{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"explanation/overview/","title":"Explanation","text":""},{"location":"explanation/overview/#models-package","title":"Models Package","text":"<p>The <code>models</code> package defines the fundamental domain concepts used throughout the trading system.</p> <p>Concrete definitions and their semantics are documented in the API Reference.</p> <p> View Models Package API Reference.</p>"},{"location":"explanation/overview/#events-package","title":"Events Package","text":"<p>The <code>events</code> package defines the event message objects propagated through the system.</p> <p>Concrete types of event message objects and their payloads are documented in the API Reference.</p> <p> View Events Package API Reference.</p>"},{"location":"explanation/overview/#indicators-package","title":"Indicators Package","text":"<p>The <code>indicators</code> package provides a library of common technical indicators and a base class for creating custom ones. Indicators are intended to be used in the context of (multi-symbol) strategies and provide a thread-safe mechanism for storing and retrieving per-symbol indicator values computed from incoming market bars.</p> <p>Concrete indicators and their computation logic, as well as the base class for creating custom indicators, are documented in the API Reference.</p> <p> View Indicators Package API Reference.</p>"},{"location":"explanation/overview/#messaging-package","title":"Messaging Package","text":"<p>The <code>messaging</code> package provides the infrastructure for event-based communication between system components. It provides an event dispatch mechanism for propagating event objects to subscribers and a base class for system components that subscribe to or publish events.</p> <p>The event bus and subscriber base class are documented in the API Reference.</p> <p> View Messaging Package API Reference.</p>"},{"location":"reference/overview/","title":"Reference","text":"<ul> <li> <p>Brokers </p> <p>Provides interfaces for order execution via a simulated broker and adapters to real venues.</p> <p> View <code>brokers</code> package API</p> </li> <li> <p>Events </p> <p>Defines the event message objects propagated through the system.</p> <p> View <code>events</code> package API</p> </li> <li> <p>Indicators </p> <p>Provides a library of common technical indicators and a base class for creating custom ones.</p> <p> View <code>indicators</code> package API</p> </li> <li> <p>Messaging </p> <p>Provides the infrastructure for event-based communication between system components.</p> <p> View <code>messaging</code> package API</p> </li> <li> <p>Models </p> <p>Defines the fundamental domain concepts used throughout the trading system.</p> <p> View <code>models</code> package API</p> </li> <li> <p>Secmaster </p> <p>Provides a schema for creating and utilities to populate the security master database.</p> <p> View <code>secmaster</code> package API</p> </li> </ul>"},{"location":"reference/brokers/base/","title":"Base","text":""},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase","title":"<code>BrokerBase</code>","text":"<p>               Bases: <code>Subscriber</code></p> <p>Abstract base class for broker components.</p> <p>A broker component receives order-related request events from the event bus and translates them into actions against an external execution venue or simulated environment. Responses to these requests are published back onto the event bus.</p> <p>This class defines the event-handling interface and subscription logic common to all broker implementations.</p>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the broker and subscribe to order request events.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for receiving order requests and publishing response events.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Initialize the broker and subscribe to order request events.\n\n    Parameters:\n        event_bus:\n            Event bus used for receiving order requests and publishing response events.\n    \"\"\"\n    super().__init__(event_bus)\n\n    self._subscribe(\n        events.requests.OrderSubmissionRequest,\n        events.requests.OrderCancellationRequest,\n        events.requests.OrderModificationRequest,\n    )\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Establish a connection to the external broker API. For simulated broker, this method is a no-op.</p> <p>Implementations are responsible for initializing any external resources required to submit, modify, or cancel orders.</p> Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef connect(self) -&gt; None:\n    \"\"\"\n    Establish a connection to the external broker API.\n    For simulated broker, this method is a no-op.\n\n    Implementations are responsible for initializing any external resources required to submit, modify, or cancel orders.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect the external broker API and stop event processing. For simulated broker, this method is a no-op.</p> <p>This method shuts down the subscriber and releases associated resources.</p> Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect the external broker API and stop event processing.\n    For simulated broker, this method is a no-op.\n\n    This method shuts down the subscriber and releases associated resources.\n    \"\"\"\n    self.shutdown()\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_event","title":"<code>_on_event(event)</code>","text":"<p>Dispatch incoming order-related events to the appropriate handler.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Incoming event received from the event bus.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Dispatch incoming order-related events to the appropriate handler.\n\n    Parameters:\n        event:\n            Incoming event received from the event bus.\n    \"\"\"\n    match event:\n        case events.requests.OrderSubmissionRequest() as submit_order:\n            self._on_submit_order(submit_order)\n        case events.requests.OrderCancellationRequest() as cancel_order:\n            self._on_cancel_order(cancel_order)\n        case events.requests.OrderModificationRequest() as modify_order:\n            self._on_modify_order(modify_order)\n        case _:\n            return\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_submit_order","title":"<code>_on_submit_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order submission request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_submit_order(self, event: events.requests.OrderSubmissionRequest) -&gt; None:\n    \"\"\"\n    Handle an order submission request.\n\n    Parameters:\n        event:\n            Order submission request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_cancel_order","title":"<code>_on_cancel_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order cancellation request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderCancellationRequest</code> <p>Order cancellation request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_cancel_order(self, event: events.requests.OrderCancellationRequest) -&gt; None:\n    \"\"\"\n    Handle an order cancellation request.\n\n    Parameters:\n        event:\n            Order cancellation request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_modify_order","title":"<code>_on_modify_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order modification request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_modify_order(self, event: events.requests.OrderModificationRequest) -&gt; None:\n    \"\"\"\n    Handle an order modification request.\n\n    Parameters:\n        event:\n            Order modification request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._respond","title":"<code>_respond(response_event)</code>","text":"<p>Publish a response event to the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>response_event</code> <code>ResponseBase</code> <p>Response event generated by the broker.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def _respond(self, response_event: events.responses.ResponseBase) -&gt; None:\n    \"\"\"\n    Publish a response event to the event bus.\n\n    Parameters:\n        response_event:\n            Response event generated by the broker.\n    \"\"\"\n    self._publish(response_event)\n</code></pre>"},{"location":"reference/brokers/simulated/","title":"Simulated","text":""},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated._PendingOrder","title":"<code>_PendingOrder</code>  <code>dataclass</code>","text":"<p>Internal order state tracked by the simulated broker.</p> <p>This structure represents broker-side pending order state and is distinct from order request events. It is used to evaluate trigger conditions against incoming market bars and to generate fills when conditions are met.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>@dataclasses.dataclass\nclass _PendingOrder:\n    \"\"\"\n    Internal order state tracked by the simulated broker.\n\n    This structure represents broker-side pending order state and is distinct from order request events.\n    It is used to evaluate trigger conditions against incoming market bars and to generate fills when conditions are met.\n    \"\"\"\n\n    order_id: uuid.UUID\n    symbol: str\n    order_type: models.OrderType\n    side: models.TradeSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker","title":"<code>SimulatedBroker</code>","text":"<p>               Bases: <code>BrokerBase</code></p> <p>Event-driven simulated broker for backtesting.</p> <p>The broker subscribes to order request events and market bar events. Order requests are validated and accepted or rejected immediately. Accepted orders are stored as pending broker-side state and evaluated against each incoming bar. When an order triggers, a fill event is published with a deterministic fill price model based on the bar's OHLC values.</p> <p>The broker publishes response events using the event timestamp to preserve simulated time consistency.</p>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used to receive order requests and market bars, and to publish broker responses and fills.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    parameters:\n        event_bus:\n            Event bus used to receive order requests and market bars, and to publish broker responses and fills.\n    \"\"\"\n    self._pending_market_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n\n    super().__init__(event_bus)\n    self._subscribe(events.market.BarReceived)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker.connect","title":"<code>connect()</code>","text":"<p>Establish broker readiness.</p> <p>The simulated broker has no external connectivity requirements. This method is a no-op and exists to satisfy the broker interface.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"\n    Establish broker readiness.\n\n    The simulated broker has no external connectivity requirements.\n    This method is a no-op and exists to satisfy the broker interface.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_event","title":"<code>_on_event(event)</code>","text":"<p>Dispatch incoming events.</p> <p>Market bar events are routed to bar processing. All other events are delegated to the broker base class for order request handling.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Incoming event received from the event bus.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Dispatch incoming events.\n\n    Market bar events are routed to bar processing.\n    All other events are delegated to the broker base class for order request handling.\n\n    parameters:\n        event:\n            Incoming event received from the event bus.\n    \"\"\"\n    match event:\n        case events.market.BarReceived() as bar:\n            self._on_bar(bar)\n        case _:\n            super()._on_event(event)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_bar","title":"<code>_on_bar(event)</code>","text":"<p>Process an incoming market bar.</p> <p>Pending orders are evaluated against the bar in a fixed sequence to provide deterministic behavior. Crucially, limit orders are processed after stop limit orders to ensure that limit orders created by stop limit orders are evaluated against the same bar.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to trigger and price simulated fills.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_bar(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Process an incoming market bar.\n\n    Pending orders are evaluated against the bar in a fixed sequence to provide deterministic behavior.\n    Crucially, limit orders are processed after stop limit orders to ensure that limit orders created by stop limit orders are evaluated against the same bar.\n\n    parameters:\n        event:\n            Market bar used to trigger and price simulated fills.\n    \"\"\"\n    self._process_market_orders(event)\n    self._process_stop_orders(event)\n    self._process_stop_limit_orders(event)\n    self._process_limit_orders(event)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_market_orders","title":"<code>_process_market_orders(event)</code>","text":"<p>Fill pending market orders for the bar symbol.</p> <p>Market orders are filled at the bar open price on the next received bar for the matching symbol.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar providing the simulated fill price and timestamps.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_market_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Fill pending market orders for the bar symbol.\n\n    Market orders are filled at the bar open price on the next received bar for the matching symbol.\n\n    parameters:\n        event:\n            Market bar providing the simulated fill price and timestamps.\n    \"\"\"\n    for order_id, order in list(self._pending_market_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=event.open,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_market_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_stop_orders","title":"<code>_process_stop_orders(event)</code>","text":"<p>Evaluate and fill pending stop orders for the bar symbol.</p> <p>Stop orders trigger when the bar crosses the stop level. The fill price is modeled as the worse of the stop price and the bar open in the direction of the trade.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate triggers and determine fill prices.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_stop_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate and fill pending stop orders for the bar symbol.\n\n    Stop orders trigger when the bar crosses the stop level.\n    The fill price is modeled as the worse of the stop price and the bar open in the direction of the trade.\n\n    parameters:\n        event:\n            Market bar used to evaluate triggers and determine fill prices.\n    \"\"\"\n    for order_id, order in list(self._pending_stop_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        # This is for mypy, it has already been validated on submission\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.TradeSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.TradeSide.BUY:\n                fill_price = max(order.stop_price, event.open)\n            case models.TradeSide.SELL:\n                fill_price = min(order.stop_price, event.open)\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_stop_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_stop_limit_orders","title":"<code>_process_stop_limit_orders(event)</code>","text":"<p>Evaluate pending stop-limit orders for the bar symbol.</p> <p>Stop-limit orders trigger on stop conditions. When triggered, they are converted into pending limit orders at the same identifier.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate stop triggers.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_stop_limit_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate pending stop-limit orders for the bar symbol.\n\n    Stop-limit orders trigger on stop conditions.\n    When triggered, they are converted into pending limit orders at the same identifier.\n\n    parameters:\n        event:\n            Market bar used to evaluate stop triggers.\n    \"\"\"\n    for order_id, order in list(self._pending_stop_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.TradeSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        limit_order = dataclasses.replace(order, order_type=models.OrderType.LIMIT)\n        self._pending_limit_orders[order_id] = limit_order\n        del self._pending_stop_limit_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_limit_orders","title":"<code>_process_limit_orders(event)</code>","text":"<p>Evaluate and fill pending limit orders for the bar symbol.</p> <p>Limit orders trigger when the bar crosses the limit level. The fill price is modeled as the better of the limit price and the bar open in the direction of the trade.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate triggers and determine fill prices.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_limit_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate and fill pending limit orders for the bar symbol.\n\n    Limit orders trigger when the bar crosses the limit level.\n    The fill price is modeled as the better of the limit price and the bar open in the direction of the trade.\n\n    parameters:\n        event:\n            Market bar used to evaluate triggers and determine fill prices.\n    \"\"\"\n    for order_id, order in list(self._pending_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        assert order.limit_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.low &lt;= order.limit_price\n            case models.TradeSide.SELL:\n                triggered = event.high &gt;= order.limit_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.TradeSide.BUY:\n                fill_price = min(order.limit_price, event.open)\n            case models.TradeSide.SELL:\n                fill_price = max(order.limit_price, event.open)\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_limit_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._reject_if_invalid_submission","title":"<code>_reject_if_invalid_submission(event)</code>","text":"<p>Validate an order submission request.</p> <p>Invalid submissions are rejected immediately by publishing an <code>OrderRejected</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the submission is invalid and was rejected, otherwise False.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_submission(\n    self, event: events.requests.OrderSubmissionRequest\n) -&gt; bool:\n    \"\"\"\n    Validate an order submission request.\n\n    Invalid submissions are rejected immediately by publishing an `OrderRejected` response event.\n\n    parameters:\n        event:\n            Order submission request event to validate.\n\n    returns:\n        True if the submission is invalid and was rejected, otherwise False.\n    \"\"\"\n    is_invalid = event.quantity &lt;= 0\n\n    match event.order_type:\n        case models.OrderType.LIMIT:\n            is_invalid = (\n                is_invalid or event.limit_price is None or event.limit_price &lt;= 0\n            )\n        case models.OrderType.STOP:\n            is_invalid = (\n                is_invalid or event.stop_price is None or event.stop_price &lt;= 0\n            )\n        case models.OrderType.STOP_LIMIT:\n            is_invalid = is_invalid or (\n                event.limit_price is None\n                or event.limit_price &lt;= 0\n                or event.stop_price is None\n                or event.stop_price &lt;= 0\n            )\n\n    if is_invalid:\n        self._publish(\n            events.responses.OrderRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=event.system_order_id,\n                rejection_reason=models.OrderRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_submit_order","title":"<code>_on_submit_order(event)</code>","text":"<p>Handle an order submission request.</p> <p>Valid orders are stored as pending broker-side state and acknowledged via an <code>OrderAccepted</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_submit_order(self, event: events.requests.OrderSubmissionRequest) -&gt; None:\n    \"\"\"\n    Handle an order submission request.\n\n    Valid orders are stored as pending broker-side state and acknowledged via an `OrderAccepted` response event.\n\n    parameters:\n        event:\n            Order submission request event.\n    \"\"\"\n    if self._reject_if_invalid_submission(event):\n        return\n\n    order = _PendingOrder(\n        order_id=event.system_order_id,\n        symbol=event.symbol,\n        order_type=event.order_type,\n        side=event.side,\n        quantity=event.quantity,\n        limit_price=event.limit_price,\n        stop_price=event.stop_price,\n    )\n\n    match order.order_type:\n        case models.OrderType.MARKET:\n            self._pending_market_orders[order.order_id] = order\n        case models.OrderType.LIMIT:\n            self._pending_limit_orders[order.order_id] = order\n        case models.OrderType.STOP:\n            self._pending_stop_orders[order.order_id] = order\n        case models.OrderType.STOP_LIMIT:\n            self._pending_stop_limit_orders[order.order_id] = order\n\n    self._publish(\n        events.responses.OrderAccepted(\n            ts_event_ns=event.ts_event_ns,\n            ts_broker_ns=event.ts_event_ns,\n            associated_order_id=order.order_id,\n        )\n    )\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_cancel_order","title":"<code>_on_cancel_order(event)</code>","text":"<p>Handle an order cancellation request.</p> <p>If the referenced order is pending, it is removed and acknowledged via <code>CancellationAccepted</code>. Otherwise, <code>CancellationRejected</code> is published.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderCancellationRequest</code> <p>Order cancellation request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_cancel_order(self, event: events.requests.OrderCancellationRequest) -&gt; None:\n    \"\"\"\n    Handle an order cancellation request.\n\n    If the referenced order is pending, it is removed and acknowledged via `CancellationAccepted`.\n    Otherwise, `CancellationRejected` is published.\n\n    parameters:\n        event:\n            Order cancellation request event.\n    \"\"\"\n    order_id = event.system_order_id\n\n    removed = False\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            del pending_orders[order_id]\n            removed = True\n            break\n\n    if removed:\n        self._publish(\n            events.responses.CancellationAccepted(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order_id,\n            )\n        )\n    else:\n        self._publish(\n            events.responses.CancellationRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order_id,\n                rejection_reason=models.CancellationRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._reject_if_invalid_modification","title":"<code>_reject_if_invalid_modification(event)</code>","text":"<p>Validate an order modification request.</p> <p>Invalid modifications are rejected immediately by publishing a <code>ModificationRejected</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the modification is invalid and was rejected, otherwise False.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_modification(\n    self, event: events.requests.OrderModificationRequest\n) -&gt; bool:\n    \"\"\"\n    Validate an order modification request.\n\n    Invalid modifications are rejected immediately by publishing a `ModificationRejected` response event.\n\n    parameters:\n        event:\n            Order modification request event to validate.\n\n    returns:\n        True if the modification is invalid and was rejected, otherwise False.\n    \"\"\"\n    is_invalid = (\n        (event.quantity is not None and event.quantity &lt;= 0)\n        or (event.limit_price is not None and event.limit_price &lt;= 0)\n        or (event.stop_price is not None and event.stop_price &lt;= 0)\n    )\n\n    if is_invalid:\n        self._publish(\n            events.responses.ModificationRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=event.system_order_id,\n                rejection_reason=models.ModificationRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_modify_order","title":"<code>_on_modify_order(event)</code>","text":"<p>Handle an order modification request.</p> <p>If the referenced order is pending, its fields are updated and acknowledged via <code>ModificationAccepted</code>. Otherwise, <code>ModificationRejected</code> is published.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_modify_order(self, event: events.requests.OrderModificationRequest) -&gt; None:\n    \"\"\"\n    Handle an order modification request.\n\n    If the referenced order is pending, its fields are updated and acknowledged via `ModificationAccepted`.\n    Otherwise, `ModificationRejected` is published.\n\n    parameters:\n        event:\n            Order modification request event.\n    \"\"\"\n    if self._reject_if_invalid_modification(event):\n        return\n\n    order_id = event.system_order_id\n\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            order = pending_orders[order_id]\n\n            new_quantity = (\n                event.quantity if event.quantity is not None else order.quantity\n            )\n            new_limit_price = (\n                event.limit_price\n                if event.limit_price is not None\n                else order.limit_price\n            )\n            new_stop_price = (\n                event.stop_price\n                if event.stop_price is not None\n                else order.stop_price\n            )\n\n            pending_orders[order_id] = dataclasses.replace(\n                order,\n                quantity=new_quantity,\n                limit_price=new_limit_price,\n                stop_price=new_stop_price,\n            )\n\n            self._publish(\n                events.responses.ModificationAccepted(\n                    ts_event_ns=event.ts_event_ns,\n                    ts_broker_ns=event.ts_event_ns,\n                    associated_order_id=order_id,\n                )\n            )\n            return\n\n    self._publish(\n        events.responses.ModificationRejected(\n            ts_event_ns=event.ts_event_ns,\n            ts_broker_ns=event.ts_event_ns,\n            associated_order_id=order_id,\n            rejection_reason=models.ModificationRejectionReason.UNKNOWN,\n            rejection_message=\"Unknown\",\n        )\n    )\n</code></pre>"},{"location":"reference/events/base/","title":"Base","text":""},{"location":"reference/events/base/#onesecondtrader.events.base.EventBase","title":"<code>EventBase</code>  <code>dataclass</code>","text":"<p>Base class for immutable event message objects, using Unix epoch nanoseconds.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the represented fact occurred, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <p>If not provided, <code>ts_created_ns</code> is assigned automatically at object creation.</p> Source code in <code>src/onesecondtrader/events/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass EventBase:\n    \"\"\"\n    Base class for immutable event message objects, using Unix epoch nanoseconds.\n\n    | Field           | Type   | Semantics                                                              |\n    |-----------------|--------|------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`  | Time at which the represented fact occurred, as UTC epoch nanoseconds. |\n    | `ts_created_ns` | `int`  | Time at which the event object was created, as UTC epoch nanoseconds.  |\n\n    If not provided, `ts_created_ns` is assigned automatically at object creation.\n    \"\"\"\n\n    ts_event_ns: int\n    ts_created_ns: int = dataclasses.field(default_factory=time.time_ns)\n</code></pre>"},{"location":"reference/events/market/bar_processed/","title":"Bar Processed","text":""},{"location":"reference/events/market/bar_processed/#onesecondtrader.events.market.bar_processed.BarProcessed","title":"<code>BarProcessed</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BarReceived</code></p> <p>Event representing a market data bar with computed indicator values.</p> <p>This event extends <code>BarReceived</code> by attaching indicator values derived from the bar data.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the bar was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>bar_period</code> <code>models.data.BarPeriod</code> Time interval represented by the bar. <code>open</code> <code>float</code> Opening price of the bar period. <code>high</code> <code>float</code> Highest traded price during the bar period. <code>low</code> <code>float</code> Lowest traded price during the bar period. <code>close</code> <code>float</code> Closing price of the bar period. <code>volume</code> <code>int</code> or <code>None</code> Traded volume during the bar period, if available. <code>indicators</code> <code>dict[str, float]</code> Mapping of indicator names to computed indicator values. Source code in <code>src/onesecondtrader/events/market/bar_processed.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarProcessed(BarReceived):\n    \"\"\"\n    Event representing a market data bar with computed indicator values.\n\n    This event extends `BarReceived` by attaching indicator values derived from the bar data.\n\n    | Field           | Type                    | Semantics                                                                  |\n    |-----------------|-------------------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`                   | Time at which the bar was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns` | `int`                   | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `symbol`        | `str`                   | Identifier of the traded instrument.                                       |\n    | `bar_period`    | `models.data.BarPeriod` | Time interval represented by the bar.                                      |\n    | `open`          | `float`                 | Opening price of the bar period.                                           |\n    | `high`          | `float`                 | Highest traded price during the bar period.                                |\n    | `low`           | `float`                 | Lowest traded price during the bar period.                                 |\n    | `close`         | `float`                 | Closing price of the bar period.                                           |\n    | `volume`        | `int` or `None`         | Traded volume during the bar period, if available.                         |\n    | `indicators`    | `dict[str, float]`      | Mapping of indicator names to computed indicator values.                   |\n    \"\"\"\n\n    indicators: dict[str, float] = dataclasses.field(default_factory=dict)\n</code></pre>"},{"location":"reference/events/market/bar_received/","title":"Bar Received","text":""},{"location":"reference/events/market/bar_received/#onesecondtrader.events.market.bar_received.BarReceived","title":"<code>BarReceived</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Event representing the reception of a completed market data bar.</p> <p>This event represents a time-aggregated bar as received from a market data source or produced by a resampling process.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the bar was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>bar_period</code> <code>models.data.BarPeriod</code> Time interval represented by the bar. <code>open</code> <code>float</code> Opening price of the bar period. <code>high</code> <code>float</code> Highest traded price during the bar period. <code>low</code> <code>float</code> Lowest traded price during the bar period. <code>close</code> <code>float</code> Closing price of the bar period. <code>volume</code> <code>int</code> or <code>None</code> Traded volume during the bar period, if available. Source code in <code>src/onesecondtrader/events/market/bar_received.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarReceived(events.EventBase):\n    \"\"\"\n    Event representing the reception of a completed market data bar.\n\n    This event represents a time-aggregated bar as received from a market data source or produced by a resampling process.\n\n    | Field           | Type                     | Semantics                                                                   |\n    |-----------------|--------------------------|-----------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`                    | Time at which the bar was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns` | `int`                    | Time at which the event object was created, as UTC epoch nanoseconds.       |\n    | `symbol`        | `str`                    | Identifier of the traded instrument.                                        |\n    | `bar_period`    | `models.data.BarPeriod`  | Time interval represented by the bar.                                       |\n    | `open`          | `float`                  | Opening price of the bar period.                                            |\n    | `high`          | `float`                  | Highest traded price during the bar period.                                 |\n    | `low`           | `float`                  | Lowest traded price during the bar period.                                  |\n    | `close`         | `float`                  | Closing price of the bar period.                                            |\n    | `volume`        | `int` or `None`          | Traded volume during the bar period, if available.                          |\n    \"\"\"\n\n    symbol: str\n    bar_period: models.BarPeriod\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n</code></pre>"},{"location":"reference/events/orders/base/","title":"Base","text":""},{"location":"reference/events/orders/base/#onesecondtrader.events.orders.base.OrderBase","title":"<code>OrderBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for brokers-originated order events.</p> <p>Order events are brokers-originated facts about the state or execution of an order. Each order event is correlated to a system order identifier via <code>associated_order_id</code>.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the response event was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the response, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code>. Identifier of the order associated with the brokers response. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order, if reported. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/orders/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderBase(events.EventBase):\n    \"\"\"\n    Base class for brokers-originated order events.\n\n    Order events are brokers-originated facts about the state or execution of an order.\n    Each order event is correlated to a system order identifier via `associated_order_id`.\n\n    | Field                 | Type            | Semantics                                                                             |\n    |-----------------------|-----------------|---------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the response event was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                 |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the response, as UTC epoch nanoseconds.               |\n    | `associated_order_id` | `uuid.UUID`.    | Identifier of the order associated with the brokers response.                          |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the order, if reported.                                 |\n    | `symbol`              | `str`           | Identifier of the traded instrument.                                                  |\n    \"\"\"\n\n    ts_broker_ns: int\n    associated_order_id: uuid.UUID\n    broker_order_id: str | None = None\n    symbol: str\n</code></pre>"},{"location":"reference/events/orders/expirations/","title":"Expirations","text":""},{"location":"reference/events/orders/expirations/#onesecondtrader.events.orders.expirations.OrderExpired","title":"<code>OrderExpired</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderBase</code></p> <p>Event indicating that the order is no longer active at the venue due to expiration according to brokers- or venue-specific rules (e.g. time-in-force constraints).</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the expiration was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the expiration, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the expired order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the expired order, if reported. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/orders/expirations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderExpired(OrderBase):\n    \"\"\"\n    Event indicating that the order is no longer active at the venue due to expiration according to brokers- or venue-specific rules (e.g. time-in-force constraints).\n\n    | Field                 | Type            | Semantics                                                                          |\n    |-----------------------|-----------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the expiration was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the expiration, as UTC epoch nanoseconds.          |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the expired order.                                                   |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the expired order, if reported.                      |\n    | `symbol`              | `str`           | Identifier of the traded instrument.                                               |\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/events/orders/fills/","title":"Fills","text":""},{"location":"reference/events/orders/fills/#onesecondtrader.events.orders.fills.FillEvent","title":"<code>FillEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderBase</code></p> <p>Event representing the execution of a trade resulting in a fill.</p> <p>A fill event records the execution of a quantity of an order at a specific price. Multiple fill events may be associated with the same order in the case of partial execution.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the fill was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the fill, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the fill. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order associated with the fill, if available. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>fill_id</code> <code>uuid.UUID</code> System-assigned unique identifier of the fill event. <code>broker_fill_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the execution record, if available. <code>side</code> <code>models.TradeSide</code> Trade direction of the executed quantity. <code>quantity_filled</code> <code>float</code> Quantity executed in this fill. <code>fill_price</code> <code>float</code> Execution price of the fill. <code>commission</code> <code>float</code> Commission or fee associated with the fill. <code>exchange</code> <code>str</code> Identifier of the execution venue. Source code in <code>src/onesecondtrader/events/orders/fills.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass FillEvent(OrderBase):\n    \"\"\"\n    Event representing the execution of a trade resulting in a fill.\n\n    A fill event records the execution of a quantity of an order at a specific price.\n    Multiple fill events may be associated with the same order in the case of partial execution.\n\n    | Field                 | Type                | Semantics                                                                       |\n    |-----------------------|---------------------|---------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`               | Time at which the fill was observed by the system, as UTC epoch nanoseconds.    |\n    | `ts_created_ns`       | `int`               | Time at which the event object was created, as UTC epoch nanoseconds.           |\n    | `ts_broker_ns`        | `int`               | Time reported by the brokers for the fill, as UTC epoch nanoseconds.             |\n    | `associated_order_id` | `uuid.UUID`         | Identifier of the order associated with the fill.                               |\n    | `broker_order_id`     | `str` or `None`     | Broker-assigned identifier of the order associated with the fill, if available. |\n    | `symbol`              | `str`               | Identifier of the traded instrument.                                            |\n    | `fill_id`             | `uuid.UUID`         | System-assigned unique identifier of the fill event.                            |\n    | `broker_fill_id`      | `str` or `None`     | Broker-assigned identifier of the execution record, if available.               |\n    | `side`                | `models.TradeSide`  | Trade direction of the executed quantity.                                       |\n    | `quantity_filled`     | `float`             | Quantity executed in this fill.                                                 |\n    | `fill_price`          | `float`             | Execution price of the fill.                                                    |\n    | `commission`          | `float`             | Commission or fee associated with the fill.                                     |\n    | `exchange`            | `str`               | Identifier of the execution venue.                                              |\n    \"\"\"\n\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    broker_fill_id: str | None = None\n    side: models.TradeSide\n    quantity_filled: float\n    fill_price: float\n    commission: float\n    exchange: str = \"SIMULATED\"\n</code></pre>"},{"location":"reference/events/requests/base/","title":"Base","text":""},{"location":"reference/events/requests/base/#onesecondtrader.events.requests.base.RequestBase","title":"<code>RequestBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for request events.</p> <p>This class defines attributes common to all requests issued to a brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order associated with the request. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/requests/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass RequestBase(events.EventBase):\n    \"\"\"\n    Base class for request events.\n\n    This class defines attributes common to all requests issued to a brokers.\n\n    | Field             | Type        | Semantics                                                                  |\n    |-------------------|-------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`       | Time at which the request was issued, as UTC epoch nanoseconds.            |\n    | `ts_created_ns`   | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `system_order_id` | `uuid.UUID` | System-assigned identifier of the order associated with the request.       |\n    | `symbol`          | `str`       | Identifier of the traded instrument.                                       |\n    \"\"\"\n\n    system_order_id: uuid.UUID\n    symbol: str\n</code></pre>"},{"location":"reference/events/requests/order_cancellation/","title":"Order Cancellation","text":""},{"location":"reference/events/requests/order_cancellation/#onesecondtrader.events.requests.order_cancellation.OrderCancellationRequest","title":"<code>OrderCancellationRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to cancel an existing order.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the cancellation request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order to be cancelled. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/requests/order_cancellation.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderCancellationRequest(RequestBase):\n    \"\"\"\n    Event representing a request to cancel an existing order.\n\n    | Field             | Type        | Semantics                                                                    |\n    |-------------------|-------------|------------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`       | Time at which the cancellation request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.        |\n    | `system_order_id` | `uuid.UUID` | System-assigned identifier of the order to be cancelled.                     |\n    | `symbol`          | `str`       | Identifier of the traded instrument.                                         |\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/events/requests/order_modification/","title":"Order Modification","text":""},{"location":"reference/events/requests/order_modification/#onesecondtrader.events.requests.order_modification.OrderModificationRequest","title":"<code>OrderModificationRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to modify an existing order.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the modification request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order to be modified. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>quantity</code> <code>float</code> or <code>None</code> Updated order quantity, if modified. <code>limit_price</code> <code>float</code> or <code>None</code> Updated limit price, if modified. <code>stop_price</code> <code>float</code> or <code>None</code> Updated stop price, if modified. Source code in <code>src/onesecondtrader/events/requests/order_modification.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderModificationRequest(RequestBase):\n    \"\"\"\n    Event representing a request to modify an existing order.\n\n    | Field             | Type              | Semantics                                                                    |\n    |-------------------|-------------------|------------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`             | Time at which the modification request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`             | Time at which the event object was created, as UTC epoch nanoseconds.        |\n    | `system_order_id` | `uuid.UUID`       | System-assigned identifier of the order to be modified.                      |\n    | `symbol`          | `str`             | Identifier of the traded instrument.                                         |\n    | `quantity`        | `float` or `None` | Updated order quantity, if modified.                                         |\n    | `limit_price`     | `float` or `None` | Updated limit price, if modified.                                            |\n    | `stop_price`      | `float` or `None` | Updated stop price, if modified.                                             |\n    \"\"\"\n\n    quantity: float | None = None\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"reference/events/requests/order_submission/","title":"Order Submission","text":""},{"location":"reference/events/requests/order_submission/#onesecondtrader.events.requests.order_submission.OrderSubmissionRequest","title":"<code>OrderSubmissionRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to submit a new order to a brokers.</p> <p>The <code>system_order_id</code> is a unique identifier assigned by the system to the order submission request by default at object creation.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the submission request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned unique identifier for the order submission. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>order_type</code> <code>models.OrderType</code> Execution constraint of the order. <code>side</code> <code>models.TradeSide</code> Direction of the trade. <code>quantity</code> <code>float</code> Requested order quantity. <code>limit_price</code> <code>float</code> or <code>None</code> Limit price, if applicable to the order type. <code>stop_price</code> <code>float</code> or <code>None</code> Stop price, if applicable to the order type. Source code in <code>src/onesecondtrader/events/requests/order_submission.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderSubmissionRequest(RequestBase):\n    \"\"\"\n    Event representing a request to submit a new order to a brokers.\n\n    The `system_order_id` is a unique identifier assigned by the system to the order submission request by default at object creation.\n\n    | Field             | Type                     | Semantics                                                                  |\n    |-------------------|--------------------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`                    | Time at which the submission request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`                    | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `system_order_id` | `uuid.UUID`              | System-assigned unique identifier for the order submission.                |\n    | `symbol`          | `str`                    | Identifier of the traded instrument.                                       |\n    | `order_type`      | `models.OrderType`       | Execution constraint of the order.                                         |\n    | `side`            | `models.TradeSide`       | Direction of the trade.                                                    |\n    | `quantity`        | `float`                  | Requested order quantity.                                                  |\n    | `limit_price`     | `float` or `None`        | Limit price, if applicable to the order type.                              |\n    | `stop_price`      | `float` or `None`        | Stop price, if applicable to the order type.                               |\n    \"\"\"\n\n    system_order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    order_type: models.OrderType\n    side: models.TradeSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"reference/events/responses/base/","title":"Base","text":""},{"location":"reference/events/responses/base/#onesecondtrader.events.responses.base.ResponseBase","title":"<code>ResponseBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for brokers response events.</p> <p>This class defines attributes common to all responses received from a brokers in reaction to previously issued requests.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the response event was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the response, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the brokers response. Source code in <code>src/onesecondtrader/events/responses/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ResponseBase(events.EventBase):\n    \"\"\"\n    Base class for brokers response events.\n\n    This class defines attributes common to all responses received from a brokers in reaction to previously issued requests.\n\n    | Field                 | Type        | Semantics                                                                             |\n    |-----------------------|-------------|---------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`       | Time at which the response event was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns`       | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.                 |\n    | `ts_broker_ns`        | `int`       | Time reported by the brokers for the response, as UTC epoch nanoseconds.               |\n    | `associated_order_id` | `uuid.UUID` | Identifier of the order associated with the brokers response.                          |\n    \"\"\"\n\n    ts_broker_ns: int\n    associated_order_id: uuid.UUID\n</code></pre>"},{"location":"reference/events/responses/cancellations/","title":"Cancellations","text":""},{"location":"reference/events/responses/cancellations/#onesecondtrader.events.responses.cancellations.CancellationAccepted","title":"<code>CancellationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order cancellation has been acknowledged by the brokers and the order is no longer active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the cancellation was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the cancellation, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the cancelled order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the cancelled order, if reported. Source code in <code>src/onesecondtrader/events/responses/cancellations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass CancellationAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the order cancellation has been acknowledged by the brokers and the order is no longer active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                              |\n    |-----------------------|-----------------|----------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the cancellation was observed by the system, as UTC epoch nanoseconds.   |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                  |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the cancellation, as UTC epoch nanoseconds.            |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the cancelled order.                                                     |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the cancelled order, if reported.                        |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/cancellations/#onesecondtrader.events.responses.cancellations.CancellationRejected","title":"<code>CancellationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order cancellation has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the rejected cancellation. <code>rejection_reason</code> <code>models.CancellationRejectionReason</code> Canonical classification of the cancellation rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/cancellations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass CancellationRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the order cancellation has been rejected by the brokers.\n\n    | Field                 | Type                                 | Semantics                                                                          |\n    |-----------------------|--------------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                                | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                                | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                                | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                          | Identifier of the order associated with the rejected cancellation.                 |\n    | `rejection_reason`    | `models.CancellationRejectionReason` | Canonical classification of the cancellation rejection cause.                      |\n    | `rejection_message`   | `str`                                | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.CancellationRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/events/responses/modifications/","title":"Modifications","text":""},{"location":"reference/events/responses/modifications/#onesecondtrader.events.responses.modifications.ModificationAccepted","title":"<code>ModificationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the requested modification has been acknowledged by the brokers and that the updated order parameters are active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the modification acceptance, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the modified order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order after modification, if reported. Source code in <code>src/onesecondtrader/events/responses/modifications.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ModificationAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the requested modification has been acknowledged by\n    the brokers and that the updated order parameters are active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                              |\n    |-----------------------|-----------------|----------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the acceptance was observed by the system, as UTC epoch nanoseconds.     |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                  |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the modification acceptance, as UTC epoch nanoseconds. |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the modified order.                                                      |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the order after modification, if reported.               |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/modifications/#onesecondtrader.events.responses.modifications.ModificationRejected","title":"<code>ModificationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the requested modification has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the rejected modification. <code>rejection_reason</code> <code>models.ModificationRejectionReason</code> Canonical classification of the modification rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/modifications.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ModificationRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the requested modification has been rejected by the brokers.\n\n    | Field                 | Type                                 | Semantics                                                                          |\n    |-----------------------|--------------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                                | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                                | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                                | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                          | Identifier of the order associated with the rejected modification.                 |\n    | `rejection_reason`    | `models.ModificationRejectionReason` | Canonical classification of the modification rejection cause.                      |\n    | `rejection_message`   | `str`                                | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.ModificationRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/events/responses/orders/","title":"Orders","text":""},{"location":"reference/events/responses/orders/#onesecondtrader.events.responses.orders.OrderAccepted","title":"<code>OrderAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order has been accepted by the brokers and is active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the acceptance, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the accepted order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the accepted order. Source code in <code>src/onesecondtrader/events/responses/orders.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the order has been accepted by the brokers and is active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                          |\n    |-----------------------|-----------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the acceptance, as UTC epoch nanoseconds.          |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the accepted order.                                                  |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the accepted order.                                  |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/orders/#onesecondtrader.events.responses.orders.OrderRejected","title":"<code>OrderRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the rejected order. <code>rejection_reason</code> <code>models.OrderRejectionReason</code> Canonical classification of the rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/orders.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the order has been rejected by the brokers.\n\n    | Field                 | Type                          | Semantics                                                                          |\n    |-----------------------|-------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                         | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                         | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                         | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                   | Identifier of the rejected order.                                                  |\n    | `rejection_reason`    | `models.OrderRejectionReason` | Canonical classification of the rejection cause.                                   |\n    | `rejection_message`   | `str`                         | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.OrderRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/indicators/base/","title":"Base","text":""},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase","title":"<code>IndicatorBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for scalar technical indicators with per-symbol history.</p> <p>The class provides a thread-safe mechanism for storing and retrieving indicator values computed from incoming market bars, keyed by symbol. It does not manage input windows or rolling computation state.</p> <p>Subclasses define a stable indicator identifier via the <code>name</code> property and implement <code>_compute_indicator</code>, which computes a single scalar value per incoming bar. Indicators with multiple conceptual outputs must be implemented as multiple single-output indicators (e.g. Bollinger Bands must be implemented via three separate indicators <code>BBUpper</code>, <code>BBMiddle</code>, and <code>BBLower</code>).</p> <p>The update mechanism is thread-safe. Indicator computation is performed outside the internal lock. Subclasses that maintain internal state are responsible for ensuring its thread safety and must not access <code>_history_data</code>.</p> <p>Indicator values are stored per symbol in bounded FIFO buffers. Missing data and out-of-bounds access yield <code>numpy.nan</code>.</p> <p>The <code>plot_at</code> attribute is an opaque identifier forwarded to the charting backend and has no intrinsic meaning within the indicator subsystem.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Stable identifier used for charting and downstream integration.\n    \"\"\"\n    pass\n</code></pre> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def plot_at(self) -&gt; int:\n    \"\"\"\n    Plotting identifier.\n\n    Returns:\n        Opaque identifier consumed by the charting backend.\n    \"\"\"\n    return self._plot_at\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Stable identifier used for charting and downstream integration.</p>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.plot_at","title":"<code>plot_at</code>  <code>property</code>","text":"<p>Plotting identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>Opaque identifier consumed by the charting backend.</p>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.__init__","title":"<code>__init__(max_history=100, plot_at=99)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>max_history</code> <code>int</code> <p>Maximum number of indicator values retained per symbol. Cannot be less than 1.</p> <code>100</code> <code>plot_at</code> <code>int</code> <p>Opaque plotting identifier forwarded to the charting backend.</p> <code>99</code> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def __init__(self, max_history: int = 100, plot_at: int = 99) -&gt; None:\n    \"\"\"\n    Parameters:\n        max_history:\n            Maximum number of indicator values retained per symbol.\n            Cannot be less than 1.\n        plot_at:\n            Opaque plotting identifier forwarded to the charting backend.\n    \"\"\"\n    self._lock = threading.Lock()\n    self._max_history = max(1, int(max_history))\n    self._history_data: dict[str, collections.deque[float]] = {}\n    self._plot_at = plot_at\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>  <code>abstractmethod</code>","text":"<p>Compute the indicator value for a single market bar.</p> <p>This method is executed outside the internal lock. Implementations must not access <code>_history_data</code> and must ensure thread safety of any internal computation state.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input for indicator computation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Computed indicator value.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>@abc.abstractmethod\ndef _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Compute the indicator value for a single market bar.\n\n    This method is executed outside the internal lock.\n    Implementations must not access `_history_data` and must ensure thread safety of any internal computation state.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input for indicator computation.\n\n    Returns:\n        Computed indicator value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.update","title":"<code>update(incoming_bar)</code>","text":"<p>Update the indicator with a new market bar.</p> <p>The computed value is appended to the per-symbol history buffer.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar triggering the update.</p> required Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def update(self, incoming_bar: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Update the indicator with a new market bar.\n\n    The computed value is appended to the per-symbol history buffer.\n\n    Parameters:\n        incoming_bar:\n            Market bar triggering the update.\n    \"\"\"\n    symbol = incoming_bar.symbol\n\n    value = self._compute_indicator(incoming_bar)\n\n    with self._lock:\n        if symbol not in self._history_data:\n            self._history_data[symbol] = collections.deque(maxlen=self._max_history)\n\n        self._history_data[symbol].append(value)\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.latest","title":"<code>latest(symbol)</code>","text":"<p>Return the most recent indicator value for a symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Symbol identifier.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Most recent value, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def latest(self, symbol: str) -&gt; float:\n    \"\"\"\n    Return the most recent indicator value for a symbol.\n\n    Parameters:\n        symbol:\n            Symbol identifier.\n\n    Returns:\n        Most recent value, or `numpy.nan` if unavailable.\n    \"\"\"\n    return self[symbol, -1]\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve an indicator value by symbol and index.</p> <p>Indexing follows standard Python sequence semantics. Negative indices refer to positions relative to the most recent value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>tuple[str, int]</code> <p><code>(symbol, index)</code> pair specifying the symbol and history offset.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Indicator value at the specified position, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def __getitem__(self, key: tuple[str, int]) -&gt; float:\n    \"\"\"\n    Retrieve an indicator value by symbol and index.\n\n    Indexing follows standard Python sequence semantics.\n    Negative indices refer to positions relative to the most recent value.\n\n    Parameters:\n        key:\n            `(symbol, index)` pair specifying the symbol and history offset.\n\n    Returns:\n        Indicator value at the specified position, or `numpy.nan` if unavailable.\n    \"\"\"\n    symbol, index = key\n\n    with self._lock:\n        history = self._history_data.get(symbol)\n\n        if history is None:\n            return np.nan\n\n        try:\n            return history[index]\n        except IndexError:\n            return np.nan\n</code></pre>"},{"location":"reference/indicators/market_fields/","title":"Market Fields","text":""},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open","title":"<code>Open</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Open price indicator.</p> <p>This indicator exposes the open price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the open price indicator.\n    \"\"\"\n    return \"OPEN\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the open price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the open price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Open price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the open price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Open price of the bar.\n    \"\"\"\n    return incoming_bar.open\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High","title":"<code>High</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>High price indicator.</p> <p>This indicator exposes the high price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the high price indicator.\n    \"\"\"\n    return \"HIGH\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the high price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the high price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>High price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the high price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        High price of the bar.\n    \"\"\"\n    return incoming_bar.high\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low","title":"<code>Low</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Low price indicator.</p> <p>This indicator exposes the low price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the low price indicator.\n    \"\"\"\n    return \"LOW\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the low price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the low price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Low price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the low price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Low price of the bar.\n    \"\"\"\n    return incoming_bar.low\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close","title":"<code>Close</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Close price indicator.</p> <p>This indicator exposes the close price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the close price indicator.\n    \"\"\"\n    return \"CLOSE\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the close price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the close price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Close price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the close price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Close price of the bar.\n    \"\"\"\n    return incoming_bar.close\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume","title":"<code>Volume</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Volume indicator.</p> <p>This indicator exposes the traded volume of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface. Missing volume values yield <code>numpy.nan</code>.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the volume indicator.\n    \"\"\"\n    return \"VOLUME\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the volume indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the volume from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Volume of the bar, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the volume from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Volume of the bar, or `numpy.nan` if unavailable.\n    \"\"\"\n    return float(incoming_bar.volume) if incoming_bar.volume is not None else np.nan\n</code></pre>"},{"location":"reference/indicators/moving_averages/","title":"Moving Averages","text":""},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Simple Moving Average (SMA) indicator.</p> <p>This indicator computes the arithmetic mean of a selected bar field over a fixed rolling window. One scalar value is produced per incoming bar and stored per symbol.</p> <p>The rolling window is maintained independently for each symbol. Until the window is fully populated, the indicator yields <code>numpy.nan</code>.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Identifier encoding the indicator type, period, and bar field.\n    \"\"\"\n    return f\"SMA_{self.period}_{self.bar_field.name}\"\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Identifier encoding the indicator type, period, and bar field.</p>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage.__init__","title":"<code>__init__(period=200, max_history=100, bar_field=models.BarField.CLOSE, plot_at=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size used to compute the moving average.</p> <code>200</code> <code>max_history</code> <code>int</code> <p>Maximum number of computed indicator values retained per symbol.</p> <code>100</code> <code>bar_field</code> <code>BarField</code> <p>Bar field used as the input series.</p> <code>CLOSE</code> <code>plot_at</code> <code>int</code> <p>Opaque plotting identifier forwarded to the charting backend.</p> <code>0</code> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def __init__(\n    self,\n    period: int = 200,\n    max_history: int = 100,\n    bar_field: models.BarField = models.BarField.CLOSE,\n    plot_at: int = 0,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        period:\n            Window size used to compute the moving average.\n        max_history:\n            Maximum number of computed indicator values retained per symbol.\n        bar_field:\n            Bar field used as the input series.\n        plot_at:\n            Opaque plotting identifier forwarded to the charting backend.\n    \"\"\"\n    super().__init__(max_history=max_history, plot_at=plot_at)\n\n    self.period: int = max(1, int(period))\n    self.bar_field: models.BarField = bar_field\n    self._window: dict[str, collections.deque[float]] = {}\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Compute the simple moving average for a single received bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input for the computation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Simple moving average value, or <code>numpy.nan</code> if the rolling window is not yet fully populated.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Compute the simple moving average for a single received bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input for the computation.\n\n    Returns:\n        Simple moving average value, or `numpy.nan` if the rolling window is not yet fully populated.\n    \"\"\"\n    symbol = incoming_bar.symbol\n    if symbol not in self._window:\n        self._window[symbol] = collections.deque(maxlen=self.period)\n\n    window = self._window[symbol]\n    value = self._extract_field(incoming_bar)\n    window.append(value)\n\n    if len(window) &lt; self.period:\n        return np.nan\n    return sum(window) / self.period\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage._extract_field","title":"<code>_extract_field(incoming_bar)</code>","text":"<p>Extract the configured bar field from an incoming bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar providing the input data.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Extracted field value, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def _extract_field(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the configured bar field from an incoming bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar providing the input data.\n\n    Returns:\n        Extracted field value, or `numpy.nan` if unavailable.\n    \"\"\"\n    match self.bar_field:\n        case models.BarField.OPEN:\n            return incoming_bar.open\n        case models.BarField.HIGH:\n            return incoming_bar.high\n        case models.BarField.LOW:\n            return incoming_bar.low\n        case models.BarField.CLOSE:\n            return incoming_bar.close\n        case models.BarField.VOLUME:\n            return (\n                float(incoming_bar.volume)\n                if incoming_bar.volume is not None\n                else np.nan\n            )\n        case _:\n            return incoming_bar.close\n</code></pre>"},{"location":"reference/messaging/eventbus/","title":"Eventbus","text":""},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus","title":"<code>EventBus</code>","text":"<p>Event dispatch mechanism for propagating event objects to subscribers.</p> <p>The event bus maintains subscriptions between subscribers and concrete event types. Events published to the bus are synchronously delivered to all subscribers registered for the exact event type.</p> <p>Subscription management and event publication are thread-safe. Event delivery itself occurs outside the internal lock.</p>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty event bus.</p> <p>The bus starts with no registered subscribers and no active subscriptions.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize an empty event bus.\n\n    The bus starts with no registered subscribers and no active subscriptions.\n    \"\"\"\n    self._per_event_subscriptions: collections.defaultdict[\n        type[events.EventBase], set[Subscriber]\n    ] = collections.defaultdict(set)\n    self._subscribers: set[Subscriber] = set()\n    self._lock: threading.Lock = threading.Lock()\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.subscribe","title":"<code>subscribe(subscriber, event_type)</code>","text":"<p>Register a subscriber for a specific event type.</p> <p>The subscriber will receive all future events whose concrete type matches <code>event_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subscriber</code> <code>Subscriber</code> <p>Object receiving published events.</p> required <code>event_type</code> <code>type[EventBase]</code> <p>Concrete event class the subscriber is interested in.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def subscribe(\n    self,\n    subscriber: Subscriber,\n    event_type: type[events.EventBase],\n) -&gt; None:\n    \"\"\"\n    Register a subscriber for a specific event type.\n\n    The subscriber will receive all future events whose concrete type matches `event_type`.\n\n    Parameters:\n        subscriber:\n            Object receiving published events.\n        event_type:\n            Concrete event class the subscriber is interested in.\n    \"\"\"\n    with self._lock:\n        self._subscribers.add(subscriber)\n        self._per_event_subscriptions[event_type].add(subscriber)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(subscriber)</code>","text":"<p>Remove a subscriber from all event subscriptions.</p> <p>After unsubscription, the subscriber will no longer receive any events published on this bus.</p> <p>Parameters:</p> Name Type Description Default <code>subscriber</code> <code>Subscriber</code> <p>Subscriber to remove.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def unsubscribe(self, subscriber: Subscriber) -&gt; None:\n    \"\"\"\n    Remove a subscriber from all event subscriptions.\n\n    After unsubscription, the subscriber will no longer receive any events published on this bus.\n\n    Parameters:\n        subscriber:\n            Subscriber to remove.\n    \"\"\"\n    with self._lock:\n        for set_of_event_subscribers in self._per_event_subscriptions.values():\n            set_of_event_subscribers.discard(subscriber)\n        self._subscribers.discard(subscriber)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"<p>Publish an event to all subscribed listeners.</p> <p>Subscribers are matched strictly by the concrete type of the event. Parent classes and inheritance relationships are not considered.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to dispatch.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def publish(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Publish an event to all subscribed listeners.\n\n    Subscribers are matched strictly by the concrete type of the event.\n    Parent classes and inheritance relationships are not considered.\n\n    Parameters:\n        event:\n            Event instance to dispatch.\n    \"\"\"\n    with self._lock:\n        subscribers = self._per_event_subscriptions[type(event)].copy()\n    for subscriber in subscribers:\n        subscriber.receive(event)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.wait_until_system_idle","title":"<code>wait_until_system_idle()</code>","text":"<p>Block until all subscribers report an idle state.</p> <p>This method delegates to each subscriber's <code>wait_until_idle</code> method and returns only after all subscribers have completed any pending work.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def wait_until_system_idle(self) -&gt; None:\n    \"\"\"\n    Block until all subscribers report an idle state.\n\n    This method delegates to each subscriber's `wait_until_idle` method and returns only after all subscribers have completed any pending work.\n    \"\"\"\n    with self._lock:\n        subscribers = self._subscribers.copy()\n    for subscriber in subscribers:\n        subscriber.wait_until_idle()\n</code></pre>"},{"location":"reference/messaging/subscriber/","title":"Subscriber","text":""},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber","title":"<code>Subscriber</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for event bus subscribers.</p> <p>A subscriber receives events from an event bus and processes them asynchronously in a dedicated worker thread. Incoming events are queued and handled sequentially.</p> <p>Subclasses implement <code>_on_event</code> to define event-specific behavior.</p>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the subscriber and start its event-processing thread.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for subscribing to and publishing events.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Initialize the subscriber and start its event-processing thread.\n\n    Parameters:\n        event_bus:\n            Event bus used for subscribing to and publishing events.\n    \"\"\"\n    self._event_bus = event_bus\n    self._queue: queue.Queue[events.EventBase | None] = queue.Queue()\n\n    self._running: threading.Event = threading.Event()\n    self._running.set()\n\n    self._thread = threading.Thread(\n        target=self._event_loop, name=self.__class__.__name__\n    )\n    self._thread.start()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.receive","title":"<code>receive(event)</code>","text":"<p>Receive an event from the event bus.</p> <p>The event is enqueued for asynchronous processing if the subscriber is running.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance delivered by the event bus.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def receive(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Receive an event from the event bus.\n\n    The event is enqueued for asynchronous processing if the subscriber is running.\n\n    Parameters:\n        event:\n            Event instance delivered by the event bus.\n    \"\"\"\n    if self._running.is_set():\n        self._queue.put(event)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.wait_until_idle","title":"<code>wait_until_idle()</code>","text":"<p>Block until all queued events have been processed.</p> <p>If the subscriber is not running, this method returns immediately.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def wait_until_idle(self) -&gt; None:\n    \"\"\"\n    Block until all queued events have been processed.\n\n    If the subscriber is not running, this method returns immediately.\n    \"\"\"\n    if not self._running.is_set():\n        return\n\n    self._queue.join()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.shutdown","title":"<code>shutdown()</code>","text":"<p>Shut down the subscriber and stop event processing.</p> <p>The subscriber is unsubscribed from the event bus, its worker thread is signaled to terminate, and all pending events are processed before shutdown completes.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shut down the subscriber and stop event processing.\n\n    The subscriber is unsubscribed from the event bus, its worker thread is signaled to terminate, and all pending events are processed before shutdown completes.\n    \"\"\"\n    if not self._running.is_set():\n        return\n\n    self._event_bus.unsubscribe(self)\n    self._running.clear()\n    self._queue.put(None)\n\n    if threading.current_thread() is not self._thread:\n        self._thread.join()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._subscribe","title":"<code>_subscribe(*event_types)</code>","text":"<p>Subscribe this subscriber to one or more event types.</p> <p>Parameters:</p> Name Type Description Default <code>*event_types</code> <code>type[EventBase]</code> <p>Concrete event classes to subscribe to.</p> <code>()</code> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _subscribe(self, *event_types: type[events.EventBase]) -&gt; None:\n    \"\"\"\n    Subscribe this subscriber to one or more event types.\n\n    Parameters:\n        *event_types:\n            Concrete event classes to subscribe to.\n    \"\"\"\n    for event_type in event_types:\n        self._event_bus.subscribe(self, event_type)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._publish","title":"<code>_publish(event)</code>","text":"<p>Publish an event to the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to publish.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _publish(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Publish an event to the event bus.\n\n    Parameters:\n        event:\n            Event instance to publish.\n    \"\"\"\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._event_loop","title":"<code>_event_loop()</code>","text":"<p>Internal worker loop for processing queued events.</p> <p>This method runs in a dedicated thread and should not be called directly.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _event_loop(self) -&gt; None:\n    \"\"\"\n    Internal worker loop for processing queued events.\n\n    This method runs in a dedicated thread and should not be called directly.\n    \"\"\"\n    while True:\n        event = self._queue.get()\n\n        if event is None:\n            self._queue.task_done()\n            break\n\n        try:\n            self._on_event(event)\n        except Exception as exc:\n            self._on_exception(exc)\n        finally:\n            self._queue.task_done()\n\n    self._cleanup()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._on_exception","title":"<code>_on_exception(exc)</code>","text":"<p>Handle an exception raised during event processing.</p> <p>Subclasses may override this method to implement logging or recovery behavior. The default implementation ignores the exception.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>Exception raised while processing an event.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _on_exception(self, exc: Exception) -&gt; None:\n    \"\"\"\n    Handle an exception raised during event processing.\n\n    Subclasses may override this method to implement logging or recovery behavior.\n    The default implementation ignores the exception.\n\n    Parameters:\n        exc:\n            Exception raised while processing an event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._cleanup","title":"<code>_cleanup()</code>","text":"<p>Perform cleanup after the event loop terminates.</p> <p>Subclasses may override this method to release resources or emit shutdown notifications.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _cleanup(self) -&gt; None:\n    \"\"\"\n    Perform cleanup after the event loop terminates.\n\n    Subclasses may override this method to release resources or emit shutdown notifications.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._on_event","title":"<code>_on_event(event)</code>  <code>abstractmethod</code>","text":"<p>Handle a single event.</p> <p>This method is invoked sequentially for each event received by the subscriber. Implementations must not block indefinitely, as <code>wait_until_idle</code> relies on timely completion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to handle.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>@abc.abstractmethod\ndef _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Handle a single event.\n\n    This method is invoked sequentially for each event received by the subscriber.\n    Implementations must not block indefinitely, as `wait_until_idle` relies on timely completion.\n\n    Parameters:\n        event:\n            Event instance to handle.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/models/bar_fields/","title":"Bar Fields","text":""},{"location":"reference/models/bar_fields/#onesecondtrader.models.bar_fields.BarField","title":"<code>BarField</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of bar fields used as indicator inputs.</p> Value Semantics <code>OPEN</code> Bar's opening value. <code>HIGH</code> Bar's highest value. <code>LOW</code> Bar's lowest value. <code>CLOSE</code> Bar's closing value. <code>VOLUME</code> Bar's traded volume. Source code in <code>src/onesecondtrader/models/bar_fields.py</code> <pre><code>class BarField(enum.Enum):\n    \"\"\"\n    Enumeration of bar fields used as indicator inputs.\n\n    | Value    | Semantics                          |\n    |----------|------------------------------------|\n    | `OPEN`   | Bar's opening value.               |\n    | `HIGH`   | Bar's highest value.               |\n    | `LOW`    | Bar's lowest value.                |\n    | `CLOSE`  | Bar's closing value.               |\n    | `VOLUME` | Bar's traded volume.               |\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"},{"location":"reference/models/bar_period/","title":"Bar Period","text":""},{"location":"reference/models/bar_period/#onesecondtrader.models.bar_period.BarPeriod","title":"<code>BarPeriod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of bar aggregation periods.</p> Value Semantics <code>SECOND</code> Duration of 1 second. <code>MINUTE</code> Duration of 1 minute. <code>HOUR</code> Duration of 1 hour. <code>DAY</code> Duration of 1 day. Source code in <code>src/onesecondtrader/models/bar_period.py</code> <pre><code>class BarPeriod(enum.Enum):\n    \"\"\"\n    Enumeration of bar aggregation periods.\n\n    | Value    | Semantics            |\n    |----------|----------------------|\n    | `SECOND` | Duration of 1 second.|\n    | `MINUTE` | Duration of 1 minute.|\n    | `HOUR`   | Duration of 1 hour.  |\n    | `DAY`    | Duration of 1 day.   |\n    \"\"\"\n\n    SECOND = enum.auto()\n    MINUTE = enum.auto()\n    HOUR = enum.auto()\n    DAY = enum.auto()\n</code></pre>"},{"location":"reference/models/order_types/","title":"Order Types","text":""},{"location":"reference/models/order_types/#onesecondtrader.models.order_types.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of order execution types.</p> Value Semantics <code>LIMIT</code> Executable only at the specified limit price or better. <code>MARKET</code> Executable immediately at the best available market price. <code>STOP</code> Becomes a market order once the stop price is reached. <code>STOP_LIMIT</code> Becomes a limit order once the stop price is reached. Source code in <code>src/onesecondtrader/models/order_types.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"\n    Enumeration of order execution types.\n\n    | Value        | Semantics                                                   |\n    |--------------|-------------------------------------------------------------|\n    | `LIMIT`      | Executable only at the specified limit price or better.     |\n    | `MARKET`     | Executable immediately at the best available market price.  |\n    | `STOP`       | Becomes a market order once the stop price is reached.      |\n    | `STOP_LIMIT` | Becomes a limit order once the stop price is reached.       |\n    \"\"\"\n\n    LIMIT = enum.auto()\n    MARKET = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/","title":"Rejection Reasons","text":""},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.OrderRejectionReason","title":"<code>OrderRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order rejection reasons.</p> <p>This enumeration defines the system-level classification of order rejection causes. It provides a stable, brokers-agnostic taxonomy for programmatic handling of rejected orders.</p> Value Semantics <code>UNKNOWN</code> The rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class OrderRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order rejection reasons.\n\n    This enumeration defines the system-level classification of order rejection causes.\n    It provides a stable, brokers-agnostic taxonomy for programmatic handling of rejected orders.\n\n    | Value     | Semantics                                                                 |\n    |-----------|---------------------------------------------------------------------------|\n    | `UNKNOWN` | The rejection reason could not be classified into a known category.       |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.ModificationRejectionReason","title":"<code>ModificationRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order modification rejection reasons.</p> <p>This enumeration defines the system-level classification of reasons for which an order modification request may be rejected by a brokers. It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of modification rejections.</p> Value Semantics <code>UNKNOWN</code> The modification rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class ModificationRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order modification rejection reasons.\n\n    This enumeration defines the system-level classification of reasons for which an order modification request may be rejected by a brokers.\n    It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of modification rejections.\n\n    | Value     | Semantics                                                                        |\n    |-----------|----------------------------------------------------------------------------------|\n    | `UNKNOWN` | The modification rejection reason could not be classified into a known category. |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.CancellationRejectionReason","title":"<code>CancellationRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order cancellation rejection reasons.</p> <p>This enumeration defines the system-level classification of reasons for which an order cancellation request may be rejected by a brokers. It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of cancellation rejections.</p> Value Semantics <code>UNKNOWN</code> The cancellation rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class CancellationRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order cancellation rejection reasons.\n\n    This enumeration defines the system-level classification of reasons for which an order cancellation request may be rejected by a brokers.\n    It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of cancellation rejections.\n\n    | Value     | Semantics                                                                        |\n    |-----------|----------------------------------------------------------------------------------|\n    | `UNKNOWN` | The cancellation rejection reason could not be classified into a known category. |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/trade_sides/","title":"Trade Sides","text":""},{"location":"reference/models/trade_sides/#onesecondtrader.models.trade_sides.TradeSide","title":"<code>TradeSide</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of trade direction.</p> <p><code>TradeSide</code> specifies the direction of change applied to the (net) signed position quantity from the perspective of the trading account.</p> Value Semantics <code>BUY</code> Increases the signed position quantity. <code>SELL</code> Decreases the signed position quantity. Source code in <code>src/onesecondtrader/models/trade_sides.py</code> <pre><code>class TradeSide(enum.Enum):\n    \"\"\"\n    Enumeration of trade direction.\n\n    `TradeSide` specifies the direction of change applied to the (net) signed position\n    quantity from the perspective of the trading account.\n\n    | Value   | Semantics                                      |\n    |---------|------------------------------------------------|\n    | `BUY`   | Increases the signed position quantity.        |\n    | `SELL`  | Decreases the signed position quantity.        |\n    \"\"\"\n\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"reference/secmaster/utils/","title":"Utils","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.BATCH_SIZE","title":"<code>BATCH_SIZE = 10000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.LOG_EVERY_OHLCV","title":"<code>LOG_EVERY_OHLCV = 1000000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.LOG_EVERY_SYMBOLOGY","title":"<code>LOG_EVERY_SYMBOLOGY = 50000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.create_secmaster_db","title":"<code>create_secmaster_db(db_path, schema_version=1)</code>","text":"<p>Create a new security master SQLite database using a selected schema version.</p> <p>The database file is created at the given path and initialized by executing the SQL script located in the <code>schema_versions</code> directory adjacent to this module.</p> <p>The function expects the schema script to set <code>PRAGMA user_version</code> to the corresponding schema version and verifies this after execution.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>Filesystem path at which the SQLite database file will be created.</p> required <code>schema_version</code> <code>int</code> <p>Version number selecting the schema script to apply.</p> <code>1</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the created database file.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If a file already exists at <code>db_path</code>.</p> <code>FileNotFoundError</code> <p>If the schema script for <code>schema_version</code> does not exist.</p> <code>DatabaseError</code> <p>If the applied schema does not set the expected <code>user_version</code> or if SQLite fails while executing the schema.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def create_secmaster_db(db_path: pathlib.Path, schema_version: int = 1) -&gt; pathlib.Path:\n    \"\"\"\n    Create a new security master SQLite database using a selected schema version.\n\n    The database file is created at the given path and initialized by executing the SQL script\n    located in the `schema_versions` directory adjacent to this module.\n\n    The function expects the schema script to set `PRAGMA user_version` to the corresponding\n    schema version and verifies this after execution.\n\n    Parameters:\n        db_path:\n            Filesystem path at which the SQLite database file will be created.\n        schema_version:\n            Version number selecting the schema script to apply.\n\n    Returns:\n        The path to the created database file.\n\n    Raises:\n        FileExistsError:\n            If a file already exists at `db_path`.\n        FileNotFoundError:\n            If the schema script for `schema_version` does not exist.\n        sqlite3.DatabaseError:\n            If the applied schema does not set the expected `user_version` or if SQLite fails\n            while executing the schema.\n    \"\"\"\n    if db_path.exists():\n        raise FileExistsError(f\"Database already exists: {db_path}\")\n\n    schema_path = (\n        pathlib.Path(__file__).resolve().parent\n        / \"schema_versions\"\n        / f\"secmaster_schema_v{schema_version}.sql\"\n    )\n\n    if not schema_path.is_file():\n        raise FileNotFoundError(\n            f\"Schema version {schema_version} not found: {schema_path}\"\n        )\n\n    db_path.parent.mkdir(parents=True, exist_ok=True)\n\n    schema_sql = schema_path.read_text(encoding=\"utf-8\")\n\n    with sqlite3.connect(str(db_path)) as con:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        con.executescript(schema_sql)\n\n        row = con.execute(\"PRAGMA user_version;\").fetchone()\n        actual_version = int(row[0]) if row else 0\n\n        if actual_version != schema_version:\n            raise sqlite3.DatabaseError(\n                f\"Schema script set user_version={actual_version}, expected {schema_version}\"\n            )\n\n    return db_path\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_databento_zip","title":"<code>ingest_databento_zip(zip_path, db_path, publisher_name='databento', symbol_type='raw_symbol', dataset=None)</code>","text":"<p>Ingest market data from a Databento zip archive into the security master database.</p> <p>The archive may contain one or more DBN files and an optional <code>symbology.json</code>. The function ingests OHLCV records from DBN files into <code>ohlcv</code> and ingests symbol-to-instrument mappings into <code>symbology</code>.</p> <p>The publisher namespace is created if absent. Publisher identity is determined by the pair <code>(publisher_name, dataset)</code>, where <code>dataset</code> is extracted from <code>metadata.json</code> in the archive.</p> <p>Ingestion is idempotent with respect to primary keys: existing <code>ohlcv</code> and <code>symbology</code> rows are left unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>zip_path</code> <code>Path</code> <p>Path to the Databento zip archive.</p> required <code>db_path</code> <code>Path</code> <p>Path to the security master SQLite database.</p> required <code>publisher_name</code> <code>str</code> <p>Vendor name stored in <code>publishers.name</code>. The dataset is derived from archive metadata.</p> <code>'databento'</code> <code>symbol_type</code> <code>str</code> <p>Symbol scheme stored in <code>symbology.symbol_type</code> for symbols found in <code>symbology.json</code>.</p> <code>'raw_symbol'</code> <code>dataset</code> <code>str | None</code> <p>Optional dataset override. If provided, it is used when <code>metadata.json</code> is missing or does not specify a dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple of (ohlcv_record_count_seen, symbology_record_count_seen).</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_databento_zip(\n    zip_path: pathlib.Path,\n    db_path: pathlib.Path,\n    publisher_name: str = \"databento\",\n    symbol_type: str = \"raw_symbol\",\n    dataset: str | None = None,\n) -&gt; tuple[int, int]:\n    \"\"\"\n    Ingest market data from a Databento zip archive into the security master database.\n\n    The archive may contain one or more DBN files and an optional `symbology.json`. The function\n    ingests OHLCV records from DBN files into `ohlcv` and ingests symbol-to-instrument mappings\n    into `symbology`.\n\n    The publisher namespace is created if absent. Publisher identity is determined by the pair\n    `(publisher_name, dataset)`, where `dataset` is extracted from `metadata.json` in the archive.\n\n    Ingestion is idempotent with respect to primary keys: existing `ohlcv` and `symbology` rows are\n    left unchanged.\n\n    Parameters:\n        zip_path:\n            Path to the Databento zip archive.\n        db_path:\n            Path to the security master SQLite database.\n        publisher_name:\n            Vendor name stored in `publishers.name`. The dataset is derived from archive metadata.\n        symbol_type:\n            Symbol scheme stored in `symbology.symbol_type` for symbols found in `symbology.json`.\n        dataset:\n            Optional dataset override. If provided, it is used when `metadata.json` is missing or\n            does not specify a dataset.\n\n    Returns:\n        A tuple of (ohlcv_record_count_seen, symbology_record_count_seen).\n    \"\"\"\n    ohlcv_count = 0\n    symbology_count = 0\n\n    logger.info(\"Opening Databento archive: %s\", zip_path)\n\n    if not db_path.is_file():\n        raise FileNotFoundError(f\"Security master DB not found: {db_path}\")\n\n    con = sqlite3.connect(str(db_path))\n\n    try:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        _assert_secmaster_db(con)\n        _enable_bulk_loading(con)\n\n        with con:\n            with zipfile.ZipFile(zip_path, \"r\") as zf:\n                dataset, venue = _extract_dataset_info(zf, dataset_override=dataset)\n                logger.info(\n                    \"Publisher resolved: name=%s dataset=%s venue=%s\",\n                    publisher_name,\n                    dataset,\n                    venue,\n                )\n                publisher_id = _get_or_create_publisher(\n                    con, publisher_name, dataset, venue\n                )\n\n                with tempfile.TemporaryDirectory() as tmpdir:\n                    dbn_files = [\n                        n\n                        for n in zf.namelist()\n                        if n.endswith(\".dbn.zst\") or n.endswith(\".dbn\")\n                    ]\n                    symbology_member = _zip_find_member(zf, \"symbology.json\")\n\n                    if not dbn_files and symbology_member is None:\n                        raise ValueError(\n                            \"Archive contains no DBN files and no symbology.json\"\n                        )\n\n                    logger.info(\"Found %d DBN file(s) in archive\", len(dbn_files))\n\n                    for name in dbn_files:\n                        extracted_path = _zip_member_to_tempfile(zf, name, tmpdir)\n                        try:\n                            logger.info(\"Ingesting DBN file: %s\", extracted_path.name)\n                            ohlcv_count += _ingest_dbn(\n                                extracted_path, con, publisher_id\n                            )\n                        finally:\n                            try:\n                                extracted_path.unlink()\n                            except FileNotFoundError:\n                                pass\n\n                    if symbology_member is not None:\n                        symbology_path = _zip_member_to_tempfile(\n                            zf, symbology_member, tmpdir\n                        )\n                        try:\n                            logger.info(\"Ingesting symbology.json\")\n                            symbology_count += _ingest_symbology(\n                                symbology_path,\n                                con,\n                                publisher_id,\n                                symbol_type=symbol_type,\n                            )\n                        finally:\n                            try:\n                                symbology_path.unlink()\n                            except FileNotFoundError:\n                                pass\n                    else:\n                        logger.info(\"No symbology.json present in archive\")\n    finally:\n        try:\n            _disable_bulk_loading(con)\n        finally:\n            con.close()\n\n    logger.info(\n        \"Finished zip ingestion: %s (%d OHLCV records, %d symbology records)\",\n        zip_path.name,\n        ohlcv_count,\n        symbology_count,\n    )\n\n    return ohlcv_count, symbology_count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_databento_dbn","title":"<code>ingest_databento_dbn(dbn_path, db_path, publisher_name='databento')</code>","text":"<p>Ingest market data from a Databento DBN file into the security master database.</p> <p>Reads OHLCV records from the DBN file and inserts them into <code>ohlcv</code>. The publisher namespace is created if absent. Publisher identity is determined by the pair <code>(publisher_name, dataset)</code>, where <code>dataset</code> is read from DBN metadata.</p> <p>Ingestion is idempotent with respect to primary keys: existing bars are left unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>dbn_path</code> <code>Path</code> <p>Path to the DBN file (.dbn or .dbn.zst).</p> required <code>db_path</code> <code>Path</code> <p>Path to the security master SQLite database.</p> required <code>publisher_name</code> <code>str</code> <p>Vendor name stored in <code>publishers.name</code>. The dataset is derived from DBN metadata.</p> <code>'databento'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of OHLCV records seen in the DBN stream.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_databento_dbn(\n    dbn_path: pathlib.Path,\n    db_path: pathlib.Path,\n    publisher_name: str = \"databento\",\n) -&gt; int:\n    \"\"\"\n    Ingest market data from a Databento DBN file into the security master database.\n\n    Reads OHLCV records from the DBN file and inserts them into `ohlcv`. The publisher namespace\n    is created if absent. Publisher identity is determined by the pair `(publisher_name, dataset)`,\n    where `dataset` is read from DBN metadata.\n\n    Ingestion is idempotent with respect to primary keys: existing bars are left unchanged.\n\n    Parameters:\n        dbn_path:\n            Path to the DBN file (.dbn or .dbn.zst).\n        db_path:\n            Path to the security master SQLite database.\n        publisher_name:\n            Vendor name stored in `publishers.name`. The dataset is derived from DBN metadata.\n\n    Returns:\n        The number of OHLCV records seen in the DBN stream.\n    \"\"\"\n    logger.info(\"Starting DBN ingestion: %s\", dbn_path)\n\n    if not db_path.is_file():\n        raise FileNotFoundError(f\"Security master DB not found: {db_path}\")\n\n    con = sqlite3.connect(str(db_path))\n\n    try:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        _assert_secmaster_db(con)\n        _enable_bulk_loading(con)\n\n        with con:\n            store = databento.DBNStore.from_file(dbn_path)\n            dataset = store.metadata.dataset\n            if not dataset:\n                raise ValueError(f\"DBN metadata missing dataset: {dbn_path}\")\n            venue = dataset.split(\".\")[0] if \".\" in dataset else None\n\n            logger.info(\n                \"Publisher resolved: name=%s dataset=%s venue=%s\",\n                publisher_name,\n                dataset,\n                venue,\n            )\n\n            publisher_id = _get_or_create_publisher(con, publisher_name, dataset, venue)\n            count = _ingest_dbn(dbn_path, con, publisher_id)\n    finally:\n        try:\n            _disable_bulk_loading(con)\n        finally:\n            con.close()\n\n    logger.info(\"Finished DBN ingestion: %s (%d OHLCV records)\", dbn_path.name, count)\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._extract_dataset_info","title":"<code>_extract_dataset_info(zf, dataset_override=None)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _extract_dataset_info(\n    zf: zipfile.ZipFile,\n    dataset_override: str | None = None,\n) -&gt; tuple[str, str | None]:\n    metadata_member = _zip_find_member(zf, \"metadata.json\")\n    if metadata_member is None:\n        if dataset_override is None:\n            raise ValueError(\n                \"Archive is missing metadata.json and no dataset override was provided\"\n            )\n        dataset = dataset_override\n    else:\n        with zf.open(metadata_member) as f:\n            metadata = json.load(f)\n        dataset = metadata.get(\"query\", {}).get(\"dataset\")\n        if not dataset:\n            if dataset_override is None:\n                raise ValueError(\n                    f\"metadata.json is missing query.dataset (member={metadata_member!r})\"\n                )\n            dataset = dataset_override\n\n    venue = dataset.split(\".\")[0] if \".\" in dataset else None\n    return dataset, venue\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._zip_find_member","title":"<code>_zip_find_member(zf, basename, allow_multiple=False)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _zip_find_member(\n    zf: zipfile.ZipFile,\n    basename: str,\n    allow_multiple: bool = False,\n) -&gt; str | None:\n    candidates = [\n        name\n        for name in zf.namelist()\n        if name == basename or name.endswith(\"/\" + basename)\n    ]\n    if not candidates:\n        return None\n    if len(candidates) == 1:\n        return candidates[0]\n\n    candidates = sorted(candidates)\n    if not allow_multiple:\n        raise ValueError(f\"Multiple {basename} members found in archive: {candidates}\")\n\n    selected = candidates[0]\n    logger.warning(\"Multiple %s found in archive; using %s\", basename, selected)\n    return selected\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._zip_member_to_tempfile","title":"<code>_zip_member_to_tempfile(zf, member_name, tmpdir)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _zip_member_to_tempfile(\n    zf: zipfile.ZipFile,\n    member_name: str,\n    tmpdir: str,\n) -&gt; pathlib.Path:\n    suffix = \"\".join(pathlib.PurePosixPath(member_name).suffixes)\n    with tempfile.NamedTemporaryFile(\n        mode=\"wb\",\n        suffix=suffix,\n        delete=False,\n        dir=tmpdir,\n    ) as tmp:\n        with zf.open(member_name) as src:\n            shutil.copyfileobj(src, tmp)\n        return pathlib.Path(tmp.name)\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._get_or_create_publisher","title":"<code>_get_or_create_publisher(con, name, dataset, venue)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _get_or_create_publisher(\n    con: sqlite3.Connection,\n    name: str,\n    dataset: str,\n    venue: str | None,\n) -&gt; int:\n    cursor = con.cursor()\n    cursor.execute(\n        \"SELECT publisher_id FROM publishers WHERE name = ? AND dataset = ?\",\n        (name, dataset),\n    )\n    row = cursor.fetchone()\n    if row:\n        return row[0]\n\n    cursor.execute(\n        \"INSERT INTO publishers (name, dataset, venue) VALUES (?, ?, ?)\",\n        (name, dataset, venue),\n    )\n    return cursor.lastrowid  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._get_or_create_instrument","title":"<code>_get_or_create_instrument(con, publisher_id, source_instrument_id)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _get_or_create_instrument(\n    con: sqlite3.Connection,\n    publisher_id: int,\n    source_instrument_id: int,\n) -&gt; int:\n    cursor = con.cursor()\n    cursor.execute(\n        \"SELECT instrument_id FROM instruments WHERE publisher_ref = ? AND source_instrument_id = ?\",\n        (publisher_id, source_instrument_id),\n    )\n    row = cursor.fetchone()\n    if row:\n        return row[0]\n\n    cursor.execute(\n        \"INSERT INTO instruments (publisher_ref, source_instrument_id) VALUES (?, ?)\",\n        (publisher_id, source_instrument_id),\n    )\n    return cursor.lastrowid  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._assert_secmaster_db","title":"<code>_assert_secmaster_db(con, expected_user_version=1)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _assert_secmaster_db(\n    con: sqlite3.Connection, expected_user_version: int = 1\n) -&gt; None:\n    row = con.execute(\"PRAGMA user_version;\").fetchone()\n    user_version = int(row[0]) if row else 0\n    if user_version != expected_user_version:\n        raise sqlite3.DatabaseError(\n            \"Security master schema user_version=\"\n            f\"{user_version} does not match expected {expected_user_version}\"\n        )\n\n    required = {\"publishers\", \"instruments\", \"ohlcv\", \"symbology\"}\n    present = {\n        r[0]\n        for r in con.execute(\n            \"SELECT name FROM sqlite_master WHERE type = 'table'\"\n        ).fetchall()\n    }\n    missing = sorted(required - present)\n    if missing:\n        raise sqlite3.DatabaseError(\n            f\"Security master schema missing required tables: {', '.join(missing)}\"\n        )\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_dbn","title":"<code>_ingest_dbn(dbn_path, con, publisher_id)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_dbn(\n    dbn_path: pathlib.Path,\n    con: sqlite3.Connection,\n    publisher_id: int,\n) -&gt; int:\n    store = databento.DBNStore.from_file(dbn_path)\n    cursor = con.cursor()\n\n    instrument_cache: dict[int, int] = {}\n    batch: list[tuple] = []\n    count = 0\n\n    logger.info(\"Streaming OHLCV records from: %s\", dbn_path.name)\n\n    for record in store:\n        if not isinstance(record, databento.OHLCVMsg):\n            continue\n\n        source_id = record.instrument_id\n        if source_id not in instrument_cache:\n            instrument_cache[source_id] = _get_or_create_instrument(\n                con, publisher_id, source_id\n            )\n        internal_id = instrument_cache[source_id]\n\n        rtype_val = (\n            record.rtype.value if hasattr(record.rtype, \"value\") else record.rtype\n        )\n\n        batch.append(\n            (\n                internal_id,\n                rtype_val,\n                record.ts_event,\n                record.open,\n                record.high,\n                record.low,\n                record.close,\n                record.volume,\n            )\n        )\n        count += 1\n\n        if count % LOG_EVERY_OHLCV == 0:\n            logger.info(\"Ingested %d OHLCV records from %s\", count, dbn_path.name)\n\n        if len(batch) &gt;= BATCH_SIZE:\n            cursor.executemany(\n                \"INSERT OR IGNORE INTO ohlcv \"\n                \"(instrument_id, rtype, ts_event, open, high, low, close, volume) \"\n                \"VALUES (?, ?, ?, ?, ?, ?, ?, ?)\",\n                batch,\n            )\n            batch.clear()\n\n    if batch:\n        cursor.executemany(\n            \"INSERT OR IGNORE INTO ohlcv \"\n            \"(instrument_id, rtype, ts_event, open, high, low, close, volume) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?)\",\n            batch,\n        )\n\n    logger.info(\"Completed OHLCV ingest from %s (%d records)\", dbn_path.name, count)\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_symbology","title":"<code>_ingest_symbology(json_path, con, publisher_id, symbol_type='raw_symbol')</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_symbology(\n    json_path: pathlib.Path,\n    con: sqlite3.Connection,\n    publisher_id: int,\n    symbol_type: str = \"raw_symbol\",\n) -&gt; int:\n    if not isinstance(symbol_type, str) or not symbol_type:\n        raise ValueError(\"symbol_type must be a non-empty string\")\n\n    with open(json_path, \"r\") as f:\n        data = json.load(f)\n\n    if not isinstance(data, dict):\n        raise ValueError(\"symbology.json root must be a JSON object\")\n\n    result = data.get(\"result\", {})\n    if not isinstance(result, dict):\n        raise ValueError(\"symbology.json['result'] must be an object\")\n    cursor = con.cursor()\n\n    batch: list[tuple] = []\n    count = 0\n\n    logger.info(\"Streaming symbology mappings from: %s\", json_path.name)\n\n    instrument_cache: set[int] = set()\n\n    for symbol, mappings in result.items():\n        if not isinstance(mappings, list):\n            raise ValueError(\n                f\"symbology.json mappings must be a list for symbol={symbol!r}\"\n            )\n\n        for i, mapping in enumerate(mappings):\n            if not isinstance(mapping, dict):\n                raise ValueError(\n                    f\"symbology.json mapping must be an object at symbol={symbol!r} index={i}\"\n                )\n\n            missing_keys = [k for k in (\"s\", \"d0\", \"d1\") if k not in mapping]\n            if missing_keys:\n                raise ValueError(\n                    \"symbology.json mapping missing key(s) \"\n                    f\"{missing_keys} at symbol={symbol!r} index={i}\"\n                )\n\n            source_id = int(mapping[\"s\"])\n\n            if source_id not in instrument_cache:\n                _get_or_create_instrument(con, publisher_id, source_id)\n                instrument_cache.add(source_id)\n\n            batch.append(\n                (\n                    publisher_id,\n                    symbol,\n                    symbol_type,\n                    source_id,\n                    mapping[\"d0\"],\n                    mapping[\"d1\"],\n                )\n            )\n            count += 1\n\n            if count % LOG_EVERY_SYMBOLOGY == 0:\n                logger.info(\n                    \"Ingested %d symbology mappings from %s\", count, json_path.name\n                )\n\n            if len(batch) &gt;= BATCH_SIZE:\n                cursor.executemany(\n                    \"INSERT OR IGNORE INTO symbology \"\n                    \"(publisher_ref, symbol, symbol_type, source_instrument_id, start_date, end_date) \"\n                    \"VALUES (?, ?, ?, ?, ?, ?)\",\n                    batch,\n                )\n                batch.clear()\n\n    if batch:\n        cursor.executemany(\n            \"INSERT OR IGNORE INTO symbology \"\n            \"(publisher_ref, symbol, symbol_type, source_instrument_id, start_date, end_date) \"\n            \"VALUES (?, ?, ?, ?, ?, ?)\",\n            batch,\n        )\n\n    logger.info(\n        \"Completed symbology ingest from %s (%d mappings)\", json_path.name, count\n    )\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._enable_bulk_loading","title":"<code>_enable_bulk_loading(con)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _enable_bulk_loading(con: sqlite3.Connection) -&gt; None:\n    con.execute(\"PRAGMA journal_mode = WAL\")\n    con.execute(\"PRAGMA synchronous = NORMAL\")\n    con.execute(\"PRAGMA cache_size = -64000\")\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._disable_bulk_loading","title":"<code>_disable_bulk_loading(con)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _disable_bulk_loading(con: sqlite3.Connection) -&gt; None:\n    con.execute(\"PRAGMA synchronous = FULL\")\n    con.execute(\"PRAGMA journal_mode = DELETE\")\n    con.execute(\"PRAGMA cache_size = -2000\")\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/","title":"Secmaster Schema V1","text":"<p>Security master database schema.</p> <p>The schema is designed for Databento-native ingestion via DBN files, while remaining compatible with other sources. Instrument identity is modeled per publisher namespace and supports either numeric upstream identifiers or symbols. Contract specifications and other static reference metadata are intentionally out of scope for this schema and should be stored separately if ingested.</p> <p>The schema is explicitly ingestion-safe in the sense that:</p> <p>1) publishers are keyed by (vendor, dataset) rather than vendor alone, allowing multiple feeds per vendor; 2) symbology admits multiple mappings sharing the same start date by including the resolved instrument identifier in the primary key, preventing accidental overwrites during bulk ingestion.</p> Table Description <code>publishers</code> Registry of vendor+dataset namespaces used for market data and instrument ingestion. <code>instruments</code> Registry of instruments observed from ingestion within a publisher namespace. <code>ohlcv</code> Aggregated OHLCV bar data keyed by instrument, bar duration (<code>rtype</code>), and event timestamp (<code>ts_event</code>). <code>symbology</code> Time-bounded mappings from publisher-native symbols to publisher-native instrument identifiers."},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#publishers","title":"Publishers","text":"<p>Registry of all data sources used for market data and instrument ingestion.</p> <p>Each row represents a distinct data product (feed) within a vendor namespace. A publisher record is uniquely identified by the pair (<code>name</code>, <code>dataset</code>), not by <code>name</code> alone. This allows a single vendor (e.g. Databento) to appear multiple times, once per concrete dataset/feed (e.g. <code>GLBX.MDP3</code>, <code>XNAS.ITCH</code>).</p> <p>A publisher establishes the provenance of instrument definitions and price data and provides the context in which raw symbols and native instrument identifiers are interpreted.</p> Field Type Constraints Description <code>publisher_id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Internal surrogate key uniquely identifying a publisher record within the system. <code>name</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable vendor identifier for the data source (e.g. <code>databento</code>, <code>yfinance</code>). <code>dataset</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the concrete data product or feed through which data is sourced; uses Databento dataset names (e.g. <code>GLBX.MDP3</code>) for Databento ingestion and internal identifiers for other sources (e.g. <code>YFINANCE</code>). <code>venue</code> <code>TEXT</code> Optional ISO 10383 Market Identifier Code (MIC) describing the primary trading venue; may be NULL for aggregated or multi-venue sources. <p>Table constraints</p> <ul> <li><code>UNIQUE(name, dataset)</code> ensures that each vendor+feed combination is represented at most once.</li> </ul> <p>Examples</p> <p>Databento CME Globex feed:</p> <ul> <li><code>name</code>    = <code>'databento'</code></li> <li><code>dataset</code> = <code>'GLBX.MDP3'</code></li> <li><code>venue</code>   = <code>XCME</code></li> </ul> <p>Databento NASDAQ TotalView feed:</p> <ul> <li><code>name</code>    = <code>'databento'</code></li> <li><code>dataset</code> = <code>'XNAS.ITCH'</code></li> <li><code>venue</code>   = <code>XNAS</code></li> </ul> <p>Yahoo Finance equity data:</p> <ul> <li><code>name</code>    = <code>'yfinance'</code></li> <li><code>dataset</code> = <code>'YFINANCE'</code></li> <li><code>venue</code>   = <code>NULL</code></li> </ul> <pre><code>CREATE TABLE publishers (\n    publisher_id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    dataset TEXT NOT NULL,\n    venue TEXT,\n    UNIQUE (name, dataset)\n);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#instruments","title":"Instruments","text":"<p>Registry of instruments observed through market data ingestion.</p> <p>Each row represents an instrument identity within a publisher namespace. Instruments may be identified by a publisher-native numeric identifier, a symbol identifier, or both. Databento ingestion uses <code>source_instrument_id</code> as the primary identifier and may optionally store a symbol from symbology. Symbol-first sources such as yfinance use <code>symbol</code> as the primary identifier and typically leave <code>source_instrument_id</code> to be <code>NULL</code>.</p> <p>The table does not store contract specifications or other reference metadata. Such metadata must be stored separately when available.</p> Field Type Constraints Description <code>instrument_id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Internal surrogate key identifying an instrument record within the system. <code>publisher_ref</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>publishers.publisher_id</code>, defining the publisher namespace in which this instrument identity is valid. <code>source_instrument_id</code> <code>INTEGER</code> Publisher-native numeric instrument identifier as provided by the upstream data source (e.g. Databento instrument_id); may be <code>NULL</code> for symbol-only sources. <code>symbol</code> <code>TEXT</code> Publisher-native symbol string identifying the instrument (e.g. raw symbol, ticker); may be NULL when numeric identifiers are used. <code>symbol_type</code> <code>TEXT</code> Identifier describing the symbol scheme or resolution type used by the publisher (e.g. <code>raw_symbol</code>, <code>continuous</code>, <code>ticker</code>). <p>Each instrument must be identifiable by at least one of <code>source_instrument_id</code> or <code>symbol</code>. Uniqueness constraints ensure that instrument identities do not collide within a publisher namespace. The table intentionally excludes contract specifications and other reference metadata, which must be stored separately when available.</p> <pre><code>CREATE TABLE instruments (\n    instrument_id INTEGER PRIMARY KEY,\n    publisher_ref INTEGER NOT NULL,\n    source_instrument_id INTEGER,\n    symbol TEXT,\n    symbol_type TEXT,\n    FOREIGN KEY (publisher_ref) REFERENCES publishers(publisher_id),\n    CHECK (\n        source_instrument_id IS NOT NULL\n        OR symbol IS NOT NULL\n    ),\n    CHECK (symbol IS NULL OR symbol_type IS NOT NULL),\n    UNIQUE (publisher_ref, source_instrument_id),\n    UNIQUE (publisher_ref, symbol, symbol_type)\n);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#ohlcv","title":"OHLCV","text":"<p>Stores aggregated OHLCV bars for instruments at multiple time resolutions.</p> Field Type Constraints Description <code>instrument_id</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>instruments.instrument_id</code>, identifying the instrument to which this bar belongs. <code>rtype</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK IN (32, 33, 34, 35, 36)</code> Record type code encoding the bar duration using Databento OHLCV conventions (e.g. <code>32</code>=1s, <code>33</code>=1m, <code>34</code>=1h, <code>35</code>=1d). <code>ts_event</code> <code>INTEGER</code> <code>NOT NULL</code> Event timestamp of the bar as provided by the upstream source, stored as nanoseconds since the UTC Unix epoch. <code>open</code> <code>INTEGER</code> <code>NOT NULL</code> Opening price of the bar interval, stored as a fixed-point integer using the upstream price scaling convention. <code>high</code> <code>INTEGER</code> <code>NOT NULL</code> Highest traded price during the bar interval, stored as a fixed-point integer. <code>low</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK(low &lt;= high)</code> Lowest traded price during the bar interval, stored as a fixed-point integer. <code>close</code> <code>INTEGER</code> <code>NOT NULL</code> Closing price of the bar interval, stored as a fixed-point integer. <code>volume</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK(volume &gt;= 0)</code> Total traded volume during the bar interval. <p>The composite primary key enforces uniqueness per instrument, bar duration, and event timestamp. Integrity constraints ensure basic OHLC consistency and prevent invalid price relationships from being stored. The table uses <code>WITHOUT ROWID</code> to store rows directly in the primary key B-tree for reduced storage overhead and faster lookups.</p> <pre><code>CREATE TABLE ohlcv (\n    instrument_id INTEGER NOT NULL,\n    rtype INTEGER NOT NULL CHECK(rtype IN (32, 33, 34, 35, 36)),\n    ts_event INTEGER NOT NULL,\n    open INTEGER NOT NULL,\n    high INTEGER NOT NULL,\n    low INTEGER NOT NULL,\n    close INTEGER NOT NULL,\n    volume INTEGER NOT NULL CHECK(volume &gt;= 0),\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, rtype, ts_event),\n    CHECK(low &lt;= high),\n    CHECK(open BETWEEN low AND high),\n    CHECK(close BETWEEN low AND high)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#symbology","title":"Symbology","text":"<p>Stores time-bounded mappings from publisher-native symbols to publisher-native instrument identifiers.</p> <p>The table captures symbol resolution rules as provided by upstream data sources and must be interpreted within the namespace of a specific publisher.</p> <p>The schema permits multiple mappings to share the same <code>start_date</code> for a given (<code>publisher_ref</code>, <code>symbol</code>, <code>symbol_type</code>) by including <code>source_instrument_id</code> in the primary key. This prevents accidental overwrite when upstream symbology exports contain same-day corrections, backfills, or parallel resolution segments.</p> Field Type Constraints Description <code>publisher_ref</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>publishers.publisher_id</code>, defining the publisher namespace in which the symbol mapping is valid. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Publisher-native symbol string as provided by the upstream source (e.g. raw symbol, continuous symbol). <code>symbol_type</code> <code>TEXT</code> <code>NOT NULL</code> Identifier describing the symbol scheme or resolution type used by the publisher (e.g. <code>raw_symbol</code>, <code>continuous</code>). <code>source_instrument_id</code> <code>INTEGER</code> <code>NOT NULL</code> Publisher-native numeric instrument identifier corresponding to the resolved symbol. <code>start_date</code> <code>TEXT</code> <code>NOT NULL</code> First calendar date (inclusive) on which this symbol-to-instrument mapping is valid, stored in YYYY-MM-DD format. <code>end_date</code> <code>TEXT</code> <code>NOT NULL</code> Last calendar date (inclusive) on which this symbol-to-instrument mapping is valid, stored in YYYY-MM-DD format. <p>The primary key enforces uniqueness of mappings at the granularity of a resolved instrument. Date bounds are interpreted as closed intervals.</p> <pre><code>CREATE TABLE symbology (\n    publisher_ref INTEGER NOT NULL,\n    symbol TEXT NOT NULL,\n    symbol_type TEXT NOT NULL,\n    source_instrument_id INTEGER NOT NULL,\n    start_date TEXT NOT NULL,\n    end_date TEXT NOT NULL,\n    FOREIGN KEY (publisher_ref) REFERENCES publishers(publisher_id),\n    FOREIGN KEY (publisher_ref, source_instrument_id)\n        REFERENCES instruments(publisher_ref, source_instrument_id),\n    PRIMARY KEY (publisher_ref, symbol, symbol_type, start_date, source_instrument_id),\n    CHECK (start_date &lt;= end_date)\n);\n</code></pre>"}]}