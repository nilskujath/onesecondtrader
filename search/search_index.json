{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"PipPoetryColab <pre><code>pip install onesecondtrader\n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre> <pre><code>!pip install onesecondtrader\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Core </p> <p>Contains: <code>models.py</code></p> <p> View <code>core/</code> package API</p> </li> <li> <p>Datafeeds </p> <p>Contains: <code>base_datafeed.py</code></p> <p> View <code>datafeeds/</code> package API</p> </li> <li> <p>Messaging </p> <p>Contains: <code>eventbus.py</code>, <code>events.py</code></p> <p> View <code>messaging/</code> package API</p> </li> <li> <p>Monitoring </p> <p>Contains: <code>console.py</code></p> <p> View <code>monitoring/</code> package API</p> </li> </ul>"},{"location":"api-reference/core/models/","title":"Models","text":""},{"location":"api-reference/core/models/#onesecondtrader.core.models.BrokerType","title":"<code>BrokerType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for broker types.</p> <p>Attributes:</p> Enum Value Description <code>LOCAL_SIMULATED</code> <code>enum.auto()</code> Locally simulated broker <code>IB_SIMULATED</code> <code>enum.auto()</code> Interactive Brokers paper trading account <code>IB_LIVE</code> <code>enum.auto()</code> Interactive Brokers live trading account <code>MT5</code> <code>enum.auto()</code> MetaTrader 5 Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class BrokerType(enum.Enum):\n    \"\"\"\n    Enum for broker types.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `LOCAL_SIMULATED` | `enum.auto()` | Locally simulated broker |\n    | `IB_SIMULATED` | `enum.auto()` | Interactive Brokers paper trading account |\n    | `IB_LIVE` | `enum.auto()` | Interactive Brokers live trading account |\n    | `MT5` | `enum.auto()` | MetaTrader 5 |\n    \"\"\"\n\n    LOCAL_SIMULATED = enum.auto()\n    IB_SIMULATED = enum.auto()\n    IB_LIVE = enum.auto()\n    MT5 = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.Bar","title":"<code>Bar</code>  <code>dataclass</code>","text":"<p>Class for representing a OHLC(V) bar of market data.</p> <p>Attributes:</p> Name Type Description <code>open</code> <code>float</code> <p>Open price</p> <code>high</code> <code>float</code> <p>High price</p> <code>low</code> <code>float</code> <p>Low price</p> <code>close</code> <code>float</code> <p>Close price</p> <code>volume</code> <code>float</code> <p>Volume</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Bar:\n    \"\"\"\n    Class for representing a OHLC(V) bar of market data.\n\n    Attributes:\n        open (float): Open price\n        high (float): High price\n        low (float): Low price\n        close (float): Close price\n        volume (float): Volume\n    \"\"\"\n\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float | None = None\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.Side","title":"<code>Side</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order sides.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class Side(enum.Enum):\n    \"\"\"\n    Enum for order sides.\n    \"\"\"\n\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.TimeInForce","title":"<code>TimeInForce</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Order time-in-force specifications.</p> <p>Attributes:</p> Enum Value Description <code>DAY</code> <code>enum.auto()</code> Valid until end of trading day <code>FOK</code> <code>enum.auto()</code> Fill entire order immediately or cancel (Fill-or-Kill) <code>GTC</code> <code>enum.auto()</code> Active until explicitly cancelled (Good-Till-Cancelled) <code>GTD</code> <code>enum.auto()</code> Active until specified date (Good-Till-Date) <code>IOC</code> <code>enum.auto()</code> Execute available quantity immediately, cancel rest (Immediate-or-Cancel) Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class TimeInForce(enum.Enum):\n    \"\"\"\n    Order time-in-force specifications.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `DAY` | `enum.auto()` | Valid until end of trading day |\n    | `FOK` | `enum.auto()` | Fill entire order immediately or cancel (Fill-or-Kill) |\n    | `GTC` | `enum.auto()` | Active until explicitly cancelled (Good-Till-Cancelled) |\n    | `GTD` | `enum.auto()` | Active until specified date (Good-Till-Date) |\n    | `IOC` | `enum.auto()` | Execute available quantity immediately, cancel rest\n        (Immediate-or-Cancel) |\n    \"\"\"\n\n    DAY = enum.auto()\n    FOK = enum.auto()\n    GTC = enum.auto()\n    GTD = enum.auto()\n    IOC = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order types.</p> <p>Attributes:</p> Enum Value Description <code>MARKET</code> <code>enum.auto()</code> Market order <code>LIMIT</code> <code>enum.auto()</code> Limit order <code>STOP</code> <code>enum.auto()</code> Stop order <code>STOP_LIMIT</code> <code>enum.auto()</code> Stop-limit order Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"\n    Enum for order types.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `MARKET` | `enum.auto()` | Market order |\n    | `LIMIT` | `enum.auto()` | Limit order |\n    | `STOP` | `enum.auto()` | Stop order |\n    | `STOP_LIMIT` | `enum.auto()` | Stop-limit order |\n    \"\"\"\n\n    MARKET = enum.auto()\n    LIMIT = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderLifecycleState","title":"<code>OrderLifecycleState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order lifecycle states.</p> <p>Attributes:</p> Enum Value Description <code>PENDING</code> <code>enum.auto()</code> Order has been submitted, but not yet acknowledged by the broker <code>OPEN</code> <code>enum.auto()</code> Order has been acknowledged by the broker, but not yet filled or cancelled <code>FILLED</code> <code>enum.auto()</code> Order has been filled <code>CANCELLED</code> <code>enum.auto()</code> Order has been cancelled Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderLifecycleState(enum.Enum):\n    \"\"\"\n    Enum for order lifecycle states.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `PENDING` | `enum.auto()` | Order has been submitted, but not yet acknowledged by\n        the broker |\n    | `OPEN` | `enum.auto()` | Order has been acknowledged by the broker, but not yet\n        filled or cancelled |\n    | `FILLED` | `enum.auto()` | Order has been filled |\n    | `CANCELLED` | `enum.auto()` | Order has been cancelled |\n    \"\"\"\n\n    PENDING = enum.auto()\n    OPEN = enum.auto()\n    PARTIALLY_FILLED = enum.auto()\n    FILLED = enum.auto()\n    CANCELLED = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderRejectionReason","title":"<code>OrderRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order rejection reasons.</p> <p>Attributes:</p> Enum Value Description <code>UNKNOWN</code> <code>enum.auto()</code> Unknown reason <code>NEGATIVE_QUANTITY</code> <code>enum.auto()</code> Negative quantity Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderRejectionReason(enum.Enum):\n    \"\"\"\n    Enum for order rejection reasons.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `UNKNOWN` | `enum.auto()` | Unknown reason |\n    | `NEGATIVE_QUANTITY` | `enum.auto()` | Negative quantity |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n    NEGATIVE_QUANTITY = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.TimeFrame","title":"<code>TimeFrame</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for timeframes.</p> <p>Attributes:</p> Enum Value Description <code>SECOND</code> <code>enum.auto()</code> 1 second <code>MINUTE</code> <code>enum.auto()</code> 1 minute <code>HOUR</code> <code>enum.auto()</code> 1 hour <code>DAY</code> <code>enum.auto()</code> 1 day <code>WEEK</code> <code>enum.auto()</code> 1 week <code>MONTH</code> <code>enum.auto()</code> 1 month <code>YEAR</code> <code>enum.auto()</code> 1 year Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class TimeFrame(enum.Enum):\n    \"\"\"\n    Enum for timeframes.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `SECOND` | `enum.auto()` | 1 second |\n    | `MINUTE` | `enum.auto()` | 1 minute |\n    | `HOUR` | `enum.auto()` | 1 hour |\n    | `DAY` | `enum.auto()` | 1 day |\n    | `WEEK` | `enum.auto()` | 1 week |\n    | `MONTH` | `enum.auto()` | 1 month |\n    | `YEAR` | `enum.auto()` | 1 year\n    \"\"\"\n\n    SECOND = enum.auto()\n    MINUTE = enum.auto()\n    HOUR = enum.auto()\n    DAY = enum.auto()\n    WEEK = enum.auto()\n    MONTH = enum.auto()\n    YEAR = enum.auto()\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/","title":"Base Datafeed","text":"<p>This module provides the base class for datafeeds.</p>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed","title":"<code>BaseDatafeed</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all datafeeds.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>class BaseDatafeed(abc.ABC):\n    \"\"\"\n    Base class for all datafeeds.\n    \"\"\"\n\n    def __init__(self, event_bus: eventbus.EventBus) -&gt; None:\n        \"\"\"\n        Initializes the datafeed with the provided event bus.\n\n        Args:\n            event_bus (eventbus.EventBus): The event bus to publish events to.\n\n        Attributes:\n            self.event_bus (eventbus.EventBus): The event bus to publish events to.\n            self._lock (threading.Lock): Lock for thread safety.\n            self._is_connected (bool): Whether the datafeed is connected. `True` if\n                  connected, `False` otherwise.\n            self._streamed_symbols (set[tuple[str, models.TimeFrame]]): Set of symbols\n                 and timeframes that are currently being streamed.\n        \"\"\"\n        self.event_bus = event_bus\n\n        self._lock = threading.Lock()\n        self._is_connected = False\n        self._streamed_symbols: set[tuple[str, models.TimeFrame]] = set()\n\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to the datafeed.\n\n        Returns:\n            bool: True if connection successful, False otherwise.\n        \"\"\"\n        with self._lock:\n            if self._is_connected:\n                console.logger.warning(f\"{self.__class__.__name__} already connected\")\n                return True\n\n            console.logger.info(f\"Connecting to {self.__class__.__name__}...\")\n            try:\n                success = self._connect()\n                if success:\n                    self._is_connected = True\n                    console.logger.info(\n                        f\"Successfully connected to {self.__class__.__name__}\"\n                    )\n                    return True\n                else:\n                    console.logger.error(\n                        f\"Failed to connect to {self.__class__.__name__}\"\n                    )\n                    return False\n            except Exception as e:\n                console.logger.error(\n                    f\"Connection failed for {self.__class__.__name__}: {e}\"\n                )\n                return False\n\n    @abc.abstractmethod\n    def _connect(self) -&gt; bool:\n        \"\"\"\n        Implement connection logic for the specific datafeed.\n\n        Returns:\n            bool: True if connection successful, False otherwise.\n        \"\"\"\n        pass\n\n    def disconnect(self) -&gt; bool:\n        \"\"\"\n        Disconnect from the datafeed.\n        Clears the set of streamed symbols.\n\n        Returns:\n            bool: True if disconnection successful, False otherwise.\n        \"\"\"\n        with self._lock:\n            if not self._is_connected:\n                console.logger.warning(\n                    f\"{self.__class__.__name__} already disconnected\"\n                )\n                return True\n\n            console.logger.info(f\"Disconnecting from {self.__class__.__name__}...\")\n            try:\n                success = self._disconnect()\n                if success:\n                    self._is_connected = False\n                    self._streamed_symbols.clear()\n                    console.logger.info(\n                        f\"Successfully disconnected from {self.__class__.__name__}\"\n                    )\n                    return True\n                else:\n                    console.logger.error(\n                        f\"Failed to disconnect from {self.__class__.__name__}\"\n                    )\n                    return False\n            except Exception as e:\n                console.logger.error(\n                    f\"Disconnection failed for {self.__class__.__name__}: {e}\"\n                )\n                self._is_connected = False\n                self._streamed_symbols.clear()\n                return False\n\n    @abc.abstractmethod\n    def _disconnect(self) -&gt; bool:\n        \"\"\"\n        Implement disconnection logic for the specific datafeed.\n\n        Returns:\n            bool: True if disconnection successful, False otherwise.\n        \"\"\"\n        pass\n\n    def start_streaming_for_symbols(\n        self, symbols: list[tuple[str, models.TimeFrame]]\n    ) -&gt; bool:\n        \"\"\"\n        Start streaming market data for the specified symbols and timeframes.\n\n        Args:\n            symbols: List of (symbol, timeframe) tuples to start streaming.\n\n        Returns:\n            bool: True if streaming started successfully, False otherwise.\n        \"\"\"\n        if not symbols:\n            console.logger.warning(\"No symbols provided for streaming\")\n            return True\n\n        with self._lock:\n            if not self._is_connected:\n                console.logger.error(\"Cannot start streaming: datafeed not connected\")\n                return False\n\n            new_symbols = set(symbols) - self._streamed_symbols\n            if not new_symbols:\n                console.logger.info(\"All requested symbols are already being streamed\")\n                return True\n\n            try:\n                success = self._start_streaming_for_symbols(list(new_symbols))\n                if success:\n                    self._streamed_symbols.update(new_symbols)\n                    console.logger.info(\n                        f\"Successfully started streaming for {len(new_symbols)} symbols\"\n                    )\n                    return True\n                else:\n                    console.logger.error(\"Failed to start streaming for symbols\")\n                    return False\n            except Exception as e:\n                console.logger.error(f\"Exception while starting streaming: {e}\")\n                return False\n\n    @abc.abstractmethod\n    def _start_streaming_for_symbols(\n        self, symbols: list[tuple[str, models.TimeFrame]]\n    ) -&gt; bool:\n        \"\"\"\n        Implement streaming startup logic for the specific datafeed.\n\n        Args:\n            symbols: List of (symbol, timeframe) tuples to start streaming.\n                    These are guaranteed to be new symbols not already being streamed.\n\n        Returns:\n            bool: True if streaming started successfully, False otherwise.\n        \"\"\"\n        pass\n\n    def stop_streaming_for_symbols(\n        self, symbols: list[tuple[str, models.TimeFrame]]\n    ) -&gt; bool:\n        \"\"\"\n        Stop streaming market data for the specified symbols and timeframes.\n\n        Args:\n            symbols: List of (symbol, timeframe) tuples to stop streaming.\n\n        Returns:\n            bool: True if streaming stopped successfully, False otherwise.\n        \"\"\"\n        if not symbols:\n            console.logger.warning(\"No symbols provided for stopping streaming\")\n            return True\n\n        with self._lock:\n            if not self._is_connected:\n                console.logger.warning(\n                    \"Datafeed not connected, but removing symbols from tracking\"\n                )\n                self._streamed_symbols.difference_update(symbols)\n                return True\n\n            symbols_to_stop = set(symbols) &amp; self._streamed_symbols\n            if not symbols_to_stop:\n                console.logger.info(\n                    \"None of the requested symbols are currently being streamed\"\n                )\n                return True\n\n            console.logger.info(\n                f\"Stopping streaming for {len(symbols_to_stop)} symbols\"\n            )\n            try:\n                success = self._stop_streaming_for_symbols(list(symbols_to_stop))\n                if success:\n                    self._streamed_symbols.difference_update(symbols_to_stop)\n                    console.logger.info(\n                        f\"Successfully stopped streaming for {len(symbols_to_stop)} \"\n                        f\"symbols\"\n                    )\n                    return True\n                else:\n                    console.logger.error(\"Failed to stop streaming for symbols\")\n                    return False\n            except Exception as e:\n                console.logger.error(f\"Exception while stopping streaming: {e}\")\n                self._streamed_symbols.difference_update(symbols_to_stop)\n                return False\n\n    @abc.abstractmethod\n    def _stop_streaming_for_symbols(\n        self, symbols: list[tuple[str, models.TimeFrame]]\n    ) -&gt; bool:\n        \"\"\"\n        Implement streaming shutdown logic for the specific datafeed.\n\n        Args:\n            symbols: List of (symbol, timeframe) tuples to stop streaming.\n                    These are guaranteed to be symbols currently being streamed.\n\n        Returns:\n            bool: True if streaming stopped successfully, False otherwise.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def preload_bars(\n        self, preload_list: list[tuple[str, models.TimeFrame, int]]\n    ) -&gt; None:\n        \"\"\"\n        Preload historical bars for the specified symbols, timeframes, and counts.\n\n        Args:\n            preload_list: List of (symbol, timeframe, count) tuples specifying\n                         what historical data to preload.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initializes the datafeed with the provided event bus.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>The event bus to publish events to.</p> required <p>Attributes:</p> Name Type Description <code>self.event_bus</code> <code>EventBus</code> <p>The event bus to publish events to.</p> <code>self._lock</code> <code>Lock</code> <p>Lock for thread safety.</p> <code>self._is_connected</code> <code>bool</code> <p>Whether the datafeed is connected. <code>True</code> if   connected, <code>False</code> otherwise.</p> <code>self._streamed_symbols</code> <code>set[tuple[str, TimeFrame]]</code> <p>Set of symbols  and timeframes that are currently being streamed.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def __init__(self, event_bus: eventbus.EventBus) -&gt; None:\n    \"\"\"\n    Initializes the datafeed with the provided event bus.\n\n    Args:\n        event_bus (eventbus.EventBus): The event bus to publish events to.\n\n    Attributes:\n        self.event_bus (eventbus.EventBus): The event bus to publish events to.\n        self._lock (threading.Lock): Lock for thread safety.\n        self._is_connected (bool): Whether the datafeed is connected. `True` if\n              connected, `False` otherwise.\n        self._streamed_symbols (set[tuple[str, models.TimeFrame]]): Set of symbols\n             and timeframes that are currently being streamed.\n    \"\"\"\n    self.event_bus = event_bus\n\n    self._lock = threading.Lock()\n    self._is_connected = False\n    self._streamed_symbols: set[tuple[str, models.TimeFrame]] = set()\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.connect","title":"<code>connect()</code>","text":"<p>Connect to the datafeed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def connect(self) -&gt; bool:\n    \"\"\"\n    Connect to the datafeed.\n\n    Returns:\n        bool: True if connection successful, False otherwise.\n    \"\"\"\n    with self._lock:\n        if self._is_connected:\n            console.logger.warning(f\"{self.__class__.__name__} already connected\")\n            return True\n\n        console.logger.info(f\"Connecting to {self.__class__.__name__}...\")\n        try:\n            success = self._connect()\n            if success:\n                self._is_connected = True\n                console.logger.info(\n                    f\"Successfully connected to {self.__class__.__name__}\"\n                )\n                return True\n            else:\n                console.logger.error(\n                    f\"Failed to connect to {self.__class__.__name__}\"\n                )\n                return False\n        except Exception as e:\n            console.logger.error(\n                f\"Connection failed for {self.__class__.__name__}: {e}\"\n            )\n            return False\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed._connect","title":"<code>_connect()</code>  <code>abstractmethod</code>","text":"<p>Implement connection logic for the specific datafeed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if connection successful, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef _connect(self) -&gt; bool:\n    \"\"\"\n    Implement connection logic for the specific datafeed.\n\n    Returns:\n        bool: True if connection successful, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from the datafeed. Clears the set of streamed symbols.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if disconnection successful, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def disconnect(self) -&gt; bool:\n    \"\"\"\n    Disconnect from the datafeed.\n    Clears the set of streamed symbols.\n\n    Returns:\n        bool: True if disconnection successful, False otherwise.\n    \"\"\"\n    with self._lock:\n        if not self._is_connected:\n            console.logger.warning(\n                f\"{self.__class__.__name__} already disconnected\"\n            )\n            return True\n\n        console.logger.info(f\"Disconnecting from {self.__class__.__name__}...\")\n        try:\n            success = self._disconnect()\n            if success:\n                self._is_connected = False\n                self._streamed_symbols.clear()\n                console.logger.info(\n                    f\"Successfully disconnected from {self.__class__.__name__}\"\n                )\n                return True\n            else:\n                console.logger.error(\n                    f\"Failed to disconnect from {self.__class__.__name__}\"\n                )\n                return False\n        except Exception as e:\n            console.logger.error(\n                f\"Disconnection failed for {self.__class__.__name__}: {e}\"\n            )\n            self._is_connected = False\n            self._streamed_symbols.clear()\n            return False\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed._disconnect","title":"<code>_disconnect()</code>  <code>abstractmethod</code>","text":"<p>Implement disconnection logic for the specific datafeed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if disconnection successful, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef _disconnect(self) -&gt; bool:\n    \"\"\"\n    Implement disconnection logic for the specific datafeed.\n\n    Returns:\n        bool: True if disconnection successful, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.start_streaming_for_symbols","title":"<code>start_streaming_for_symbols(symbols)</code>","text":"<p>Start streaming market data for the specified symbols and timeframes.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of (symbol, timeframe) tuples to start streaming.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming started successfully, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def start_streaming_for_symbols(\n    self, symbols: list[tuple[str, models.TimeFrame]]\n) -&gt; bool:\n    \"\"\"\n    Start streaming market data for the specified symbols and timeframes.\n\n    Args:\n        symbols: List of (symbol, timeframe) tuples to start streaming.\n\n    Returns:\n        bool: True if streaming started successfully, False otherwise.\n    \"\"\"\n    if not symbols:\n        console.logger.warning(\"No symbols provided for streaming\")\n        return True\n\n    with self._lock:\n        if not self._is_connected:\n            console.logger.error(\"Cannot start streaming: datafeed not connected\")\n            return False\n\n        new_symbols = set(symbols) - self._streamed_symbols\n        if not new_symbols:\n            console.logger.info(\"All requested symbols are already being streamed\")\n            return True\n\n        try:\n            success = self._start_streaming_for_symbols(list(new_symbols))\n            if success:\n                self._streamed_symbols.update(new_symbols)\n                console.logger.info(\n                    f\"Successfully started streaming for {len(new_symbols)} symbols\"\n                )\n                return True\n            else:\n                console.logger.error(\"Failed to start streaming for symbols\")\n                return False\n        except Exception as e:\n            console.logger.error(f\"Exception while starting streaming: {e}\")\n            return False\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed._start_streaming_for_symbols","title":"<code>_start_streaming_for_symbols(symbols)</code>  <code>abstractmethod</code>","text":"<p>Implement streaming startup logic for the specific datafeed.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of (symbol, timeframe) tuples to start streaming.     These are guaranteed to be new symbols not already being streamed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming started successfully, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef _start_streaming_for_symbols(\n    self, symbols: list[tuple[str, models.TimeFrame]]\n) -&gt; bool:\n    \"\"\"\n    Implement streaming startup logic for the specific datafeed.\n\n    Args:\n        symbols: List of (symbol, timeframe) tuples to start streaming.\n                These are guaranteed to be new symbols not already being streamed.\n\n    Returns:\n        bool: True if streaming started successfully, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.stop_streaming_for_symbols","title":"<code>stop_streaming_for_symbols(symbols)</code>","text":"<p>Stop streaming market data for the specified symbols and timeframes.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of (symbol, timeframe) tuples to stop streaming.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming stopped successfully, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def stop_streaming_for_symbols(\n    self, symbols: list[tuple[str, models.TimeFrame]]\n) -&gt; bool:\n    \"\"\"\n    Stop streaming market data for the specified symbols and timeframes.\n\n    Args:\n        symbols: List of (symbol, timeframe) tuples to stop streaming.\n\n    Returns:\n        bool: True if streaming stopped successfully, False otherwise.\n    \"\"\"\n    if not symbols:\n        console.logger.warning(\"No symbols provided for stopping streaming\")\n        return True\n\n    with self._lock:\n        if not self._is_connected:\n            console.logger.warning(\n                \"Datafeed not connected, but removing symbols from tracking\"\n            )\n            self._streamed_symbols.difference_update(symbols)\n            return True\n\n        symbols_to_stop = set(symbols) &amp; self._streamed_symbols\n        if not symbols_to_stop:\n            console.logger.info(\n                \"None of the requested symbols are currently being streamed\"\n            )\n            return True\n\n        console.logger.info(\n            f\"Stopping streaming for {len(symbols_to_stop)} symbols\"\n        )\n        try:\n            success = self._stop_streaming_for_symbols(list(symbols_to_stop))\n            if success:\n                self._streamed_symbols.difference_update(symbols_to_stop)\n                console.logger.info(\n                    f\"Successfully stopped streaming for {len(symbols_to_stop)} \"\n                    f\"symbols\"\n                )\n                return True\n            else:\n                console.logger.error(\"Failed to stop streaming for symbols\")\n                return False\n        except Exception as e:\n            console.logger.error(f\"Exception while stopping streaming: {e}\")\n            self._streamed_symbols.difference_update(symbols_to_stop)\n            return False\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed._stop_streaming_for_symbols","title":"<code>_stop_streaming_for_symbols(symbols)</code>  <code>abstractmethod</code>","text":"<p>Implement streaming shutdown logic for the specific datafeed.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of (symbol, timeframe) tuples to stop streaming.     These are guaranteed to be symbols currently being streamed.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming stopped successfully, False otherwise.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef _stop_streaming_for_symbols(\n    self, symbols: list[tuple[str, models.TimeFrame]]\n) -&gt; bool:\n    \"\"\"\n    Implement streaming shutdown logic for the specific datafeed.\n\n    Args:\n        symbols: List of (symbol, timeframe) tuples to stop streaming.\n                These are guaranteed to be symbols currently being streamed.\n\n    Returns:\n        bool: True if streaming stopped successfully, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.preload_bars","title":"<code>preload_bars(preload_list)</code>  <code>abstractmethod</code>","text":"<p>Preload historical bars for the specified symbols, timeframes, and counts.</p> <p>Parameters:</p> Name Type Description Default <code>preload_list</code> <code>list[tuple[str, TimeFrame, int]]</code> <p>List of (symbol, timeframe, count) tuples specifying          what historical data to preload.</p> required Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef preload_bars(\n    self, preload_list: list[tuple[str, models.TimeFrame, int]]\n) -&gt; None:\n    \"\"\"\n    Preload historical bars for the specified symbols, timeframes, and counts.\n\n    Args:\n        preload_list: List of (symbol, timeframe, count) tuples specifying\n                     what historical data to preload.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/messaging/eventbus/","title":"Eventbus","text":"<p>This module provides the event bus for managing event-driven communication between  the trading infrastructure's components via a publish-subscribe messaging pattern.</p>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus for managing event-driven communication between the trading  infrastructure's components via a publish-subscribe messaging pattern. Supports inheritance-based subscriptions where handlers subscribed to a parent event  type will receive events of child types. Each subscription can include an optional filter function to receive only specific  events of a given type (e.g. filtering <code>IncomingBar</code> events for a specific symbol).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Import necessary modules\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from onesecondtrader.messaging.eventbus import EventBus\n&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n</code></pre> <pre><code>&gt;&gt;&gt; # Instantiate event bus\n&gt;&gt;&gt; event_bus = EventBus()\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a dummy handler that simply prints the symbol of the received event\n&gt;&gt;&gt; def dummy_handler(incoming_bar_event: events.Market.IncomingBar):\n...     print(f\"Received: {incoming_bar_event.symbol}\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Subscribe to IncomingBar events whose symbol is AAPL\n&gt;&gt;&gt; event_bus.subscribe(\n...     events.Market.IncomingBar,\n...     dummy_handler,\n...     lambda event: event.symbol == \"AAPL\" # Lambda filter function\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Create events to publish\n&gt;&gt;&gt; aapl_event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n...     symbol=\"AAPL\",\n...     bar=models.Bar(\n...         open=100.0, high=101.0, low=99.0,\n...         close=100.5, volume=1000\n...     )\n... )\n&gt;&gt;&gt; googl_event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n...     symbol=\"GOOGL\",\n...     bar=models.Bar(\n...         open=2800.0, high=2801.0, low=2799.0,\n...         close=2800.5, volume=500\n...     )\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Publish events - only AAPL passes filter and will be printed\n&gt;&gt;&gt; event_bus.publish(aapl_event)\nReceived: AAPL\n&gt;&gt;&gt; event_bus.publish(googl_event)\n</code></pre> <pre><code>&gt;&gt;&gt; # Unsubscribe the dummy handler\n&gt;&gt;&gt; event_bus.unsubscribe(events.Market.IncomingBar, dummy_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # Publish again - no handler receives it (warning will be logged)\n&gt;&gt;&gt; event_bus.publish(aapl_event)\nWARNING:root:Published IncomingBar but no subscribers exist - check event wiring\n</code></pre> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>class EventBus:\n    # noinspection PyTypeChecker\n    \"\"\"\n    Event bus for managing event-driven communication between the trading\n     infrastructure's components via a publish-subscribe messaging pattern.\n    Supports inheritance-based subscriptions where handlers subscribed to a parent event\n     type will receive events of child types.\n    Each subscription can include an optional filter function to receive only specific\n     events of a given type (e.g. filtering `IncomingBar` events for a specific symbol).\n\n    Examples:\n        &gt;&gt;&gt; # Import necessary modules\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from onesecondtrader.messaging.eventbus import EventBus\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n\n        &gt;&gt;&gt; # Instantiate event bus\n        &gt;&gt;&gt; event_bus = EventBus()\n\n        &gt;&gt;&gt; # Create a dummy handler that simply prints the symbol of the received event\n        &gt;&gt;&gt; def dummy_handler(incoming_bar_event: events.Market.IncomingBar):\n        ...     print(f\"Received: {incoming_bar_event.symbol}\")\n\n        &gt;&gt;&gt; # Subscribe to IncomingBar events whose symbol is AAPL\n        &gt;&gt;&gt; event_bus.subscribe(\n        ...     events.Market.IncomingBar,\n        ...     dummy_handler,\n        ...     lambda event: event.symbol == \"AAPL\" # Lambda filter function\n        ... )\n\n        &gt;&gt;&gt; # Create events to publish\n        &gt;&gt;&gt; aapl_event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n        ...     symbol=\"AAPL\",\n        ...     bar=models.Bar(\n        ...         open=100.0, high=101.0, low=99.0,\n        ...         close=100.5, volume=1000\n        ...     )\n        ... )\n        &gt;&gt;&gt; googl_event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n        ...     symbol=\"GOOGL\",\n        ...     bar=models.Bar(\n        ...         open=2800.0, high=2801.0, low=2799.0,\n        ...         close=2800.5, volume=500\n        ...     )\n        ... )\n\n        &gt;&gt;&gt; # Publish events - only AAPL passes filter and will be printed\n        &gt;&gt;&gt; event_bus.publish(aapl_event)\n        Received: AAPL\n        &gt;&gt;&gt; event_bus.publish(googl_event)\n\n        &gt;&gt;&gt; # Unsubscribe the dummy handler\n        &gt;&gt;&gt; event_bus.unsubscribe(events.Market.IncomingBar, dummy_handler)\n\n        &gt;&gt;&gt; # Publish again - no handler receives it (warning will be logged)\n        &gt;&gt;&gt; event_bus.publish(aapl_event)  # doctest: +SKIP\n        WARNING:root:Published IncomingBar but no subscribers exist - check event wiring\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes the event bus with optimized data structures for high-performance\n        event publishing.\n\n        Attributes:\n            self._handlers (collections.defaultdict): Direct storage mapping event types\n                 to handler lists\n            self._publish_cache (dict): Pre-computed cache for O(1) publish operations\n            self._lock (threading.Lock): Single lock for all operations\n                (subscribe/unsubscribe are rare)\n            self._sequence_number (int): Sequence number counter for events\n        \"\"\"\n        self._handlers: dict[\n            type[events.Base.Event],\n            list[\n                tuple[\n                    Callable[[events.Base.Event], None],\n                    Callable[[events.Base.Event], bool],\n                ]\n            ],\n        ] = collections.defaultdict(list)\n\n        self._publish_cache: dict[\n            type[events.Base.Event],\n            list[\n                tuple[\n                    Callable[[events.Base.Event], None],\n                    Callable[[events.Base.Event], bool],\n                ]\n            ],\n        ] = {}\n\n        self._lock: threading.Lock = threading.Lock()\n        self._sequence_number: int = -1\n\n        self._rebuild_cache()\n\n    def subscribe(\n        self,\n        event_type: type[events.Base.Event],\n        event_handler: Callable[[events.Base.Event], None],\n        event_filter: Callable[[events.Base.Event], bool] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        The `subscribe` method registers an event handler for event messages of a\n         specified type and all its subtypes (expressed as subclasses in the event\n          dataclass hierarchy, so-called inheritance-based subscription).\n        When an event of that type or any subtype is published, the handler will be\n         invoked if the associated `event_filter` returns `True` for that event\n         instance.\n        A given handler can only be subscribed once per event type.\n        If the handler is already subscribed to the given event type\n         \u2014regardless of the filter function\u2014\n        the subscription attempt is ignored and a warning is logged.\n\n        Arguments:\n            event_type (type[events.Base.Event]): Type of the event to subscribe to,\n             must be a subclass of `events.Base.Event`.\n            event_handler (Callable[events.Base.Event, None]): Function to call when an\n                 event of the given type is published.\n                This callable must accept a single argument of type `events.Base.Event`\n                 (or its subclass).\n            event_filter (Callable[[events.Base.Event], bool] | None): Function to\n                 determine whether to call the event handler for a given event.\n                Should accept one event and return `True` to handle or `False` to\n                 ignore.\n                Defaults to `None`, which creates a filter that always returns `True`\n                 (i.e. always call the event handler).\n        \"\"\"\n\n        if not issubclass(event_type, events.Base.Event):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_type must be a subclass of \"\n                f\"Event, got {type(event_type).__name__}\"\n            )\n            return\n\n        if not callable(event_handler):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_handler must be callable, \"\n                f\"got {type(event_handler).__name__}\"\n            )\n            return\n\n        if event_filter is None:\n\n            def event_filter(event: events.Base.Event) -&gt; bool:\n                return True\n\n        if not callable(event_filter):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_filter must be callable, \"\n                f\"got {type(event_filter).__name__}\"\n            )\n            return\n\n        is_valid, error_msg = self._validate_filter_signature(event_filter)\n        if not is_valid:\n            console.logger.error(f\"Invalid subscription attempt: {error_msg}\")\n            return\n\n        with self._lock:\n            if any(\n                event_handler == existing_handler\n                for existing_handler, _ in self._handlers[event_type]\n            ):\n                console.logger.warning(\n                    f\"Duplicate subscription attempt: event_handler was already \"\n                    f\"subscribed to {event_type.__name__}\"\n                )\n                return\n\n            self._handlers[event_type].append((event_handler, event_filter))\n\n            self._rebuild_cache()\n\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.info(f\"Subscribed {handler_name} to {event_type.__name__}.\")\n\n    def unsubscribe(\n        self,\n        event_type: type[events.Base.Event],\n        event_handler: Callable[[events.Base.Event], None],\n    ) -&gt; None:\n        \"\"\"\n        The `unsubscribe` method removes an event handler from the subscribers list for\n         the specified event type.\n        If the event handler is not subscribed to the given event type, the\n         unsubscription attempt is ignored and a warning is logged.\n        After removing the event handler, the event type may have an empty subscribers\n         list but remains in the `subscribers` dictionary.\n\n        Arguments:\n            event_type (type[events.Base.Event]): Type of the event to unsubscribe from,\n                 must be a subclass of `events.Base.Event`.\n            event_handler (Callable[events.Base.Event, None]): Event handler to remove\n                 from the subscribers list (this will also remove the associated filter\n                 function).\n        \"\"\"\n        if not issubclass(event_type, events.Base.Event):\n            console.logger.error(\n                f\"Invalid unsubscription attempt: event_type must be a subclass of \"\n                f\"Event, got {type(event_type).__name__}\"\n            )\n            return\n\n        if not callable(event_handler):\n            console.logger.error(\n                f\"Invalid unsubscription attempt: callback must be callable, \"\n                f\"got {type(event_handler).__name__}\"\n            )\n            return\n\n        with self._lock:\n            if event_type not in self._handlers:\n                console.logger.warning(\n                    f\"Attempted to unsubscribe from {event_type.__name__}, \"\n                    f\"but no subscribers exist\"\n                )\n                return\n\n            current_handlers = self._handlers[event_type]\n            new_handlers = [\n                (existing_handler, existing_filter)\n                for existing_handler, existing_filter in current_handlers\n                if existing_handler != event_handler\n            ]\n\n            removed_count = len(current_handlers) - len(new_handlers)\n            if removed_count == 0:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.warning(\n                    f\"Attempted to unsubscribe {handler_name} from \"\n                    f\"{event_type.__name__}, but it was not subscribed\"\n                )\n                return\n\n            if new_handlers:\n                self._handlers[event_type] = new_handlers\n            else:\n                # Clean up empty lists\n                del self._handlers[event_type]\n\n            self._rebuild_cache()\n\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.info(\n                f\"Unsubscribed {handler_name} from \"\n                f\"{event_type.__name__} (removed {removed_count} subscription(s))\"\n            )\n\n    def publish(self, event: events.Base.Event) -&gt; None:\n        \"\"\"\n        The `publish` method delivers the event to all handlers subscribed to the\n         event's type or any of its parent types (inheritance-based subscription).\n        Handlers are only called if their filter function returns True for this event.\n        Handlers are called synchronously in the order they were subscribed.\n\n        This method uses a pre-computed handler cache for O(1) lookup performance\n        and runs without locks for maximum concurrency.\n\n        Arguments:\n            event (events.Base.Event): Event to publish. Must be an instance of\n                 `events.Base.Event` or one of its subclasses.\n        \"\"\"\n        if not isinstance(event, events.Base.Event):\n            console.logger.error(\n                f\"Invalid publish attempt: event must be an instance of Event, \"\n                f\"got {type(event).__name__}\"\n            )\n            return\n\n        object.__setattr__(\n            event, \"event_bus_sequence_number\", self._set_sequence_number()\n        )\n\n        event_type: type[events.Base.Event] = type(event)\n\n        handlers = self._publish_cache.get(event_type, [])\n\n        if not handlers:\n            console.logger.warning(\n                f\"Published {event_type.__name__} but no subscribers exist - \"\n                f\"check event wiring\"\n            )\n            return\n\n        delivered_count = 0\n        for event_handler, event_filter in handlers:\n            try:\n                should_handle = event_filter(event)\n\n                if not isinstance(should_handle, bool):\n                    handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                    console.logger.warning(\n                        f\"Filter for handler {handler_name} returned \"\n                        f\"{type(should_handle).__name__}, expected bool. \"\n                        f\"Treating as False.\"\n                    )\n                    should_handle = False\n\n            except TypeError as type_error:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                if \"takes\" in str(type_error) and \"positional argument\" in str(\n                    type_error\n                ):\n                    console.logger.error(\n                        f\"Filter for handler {handler_name} has wrong signature: \"\n                        f\"{type_error}\"\n                    )\n                else:\n                    console.logger.exception(\n                        f\"Filter function for handler {handler_name} failed \"\n                        f\"processing {event_type.__name__}: {type_error}\"\n                    )\n                continue\n            except Exception as filter_exception:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.exception(\n                    f\"Filter function for handler {handler_name} failed \"\n                    f\"processing {event_type.__name__}: {filter_exception}\"\n                )\n                continue\n\n            if should_handle:\n                try:\n                    event_handler(event)\n                    delivered_count += 1\n                except Exception as handler_exception:\n                    handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                    console.logger.exception(\n                        f\"Handler {handler_name} failed processing \"\n                        f\"{event_type.__name__}: {handler_exception}\"\n                    )\n\n        if delivered_count == 0:\n            console.logger.warning(\n                f\"Published {event_type.__name__} but no handlers received it - \"\n                f\"all {len(handlers)} handler(s) filtered out the event\"\n            )\n        else:\n            # Conditional debug logging to avoid string formatting overhead\n            if console.logger.isEnabledFor(logging.DEBUG):\n                console.logger.debug(\n                    f\"Published {event_type.__name__} to {delivered_count} handler(s)\"\n                )\n\n    @staticmethod\n    def _validate_filter_signature(\n        event_filter: Callable[[events.Base.Event], bool],\n    ) -&gt; tuple[bool, str | None]:\n        \"\"\"\n        Validate that filter function has the correct signature.\n\n        A valid filter function must:\n        - Accept exactly 1 parameter (the event)\n        - Not use *args or **kwargs\n        - Optionally return bool (if type annotated)\n\n        Arguments:\n            event_filter (Callable): The filter function to validate\n\n        Returns:\n            tuple[bool, str | None]: (is_valid, error_message)\n                is_valid: True if signature is valid, False otherwise\n                error_message: Description of the issue if invalid, None if valid\n        \"\"\"\n        try:\n            sig = inspect.signature(event_filter)\n            params = list(sig.parameters.values())\n\n            if len(params) != 1:\n                return (\n                    False,\n                    f\"Filter must accept exactly 1 parameter, got {len(params)}\",\n                )\n\n            param = params[0]\n            if param.kind == inspect.Parameter.VAR_POSITIONAL:\n                return (\n                    False,\n                    \"Filter cannot use *args - must accept exactly 1 event parameter\",\n                )\n            if param.kind == inspect.Parameter.VAR_KEYWORD:\n                return (\n                    False,\n                    \"Filter cannot use **kwargs - must accept exactly 1 event \"\n                    \"parameter\",\n                )\n\n            if sig.return_annotation is not inspect.Parameter.empty:\n                if sig.return_annotation is not bool:\n                    return (\n                        False,\n                        f\"Filter return type should be bool, got \"\n                        f\"{sig.return_annotation}\",\n                    )\n\n            return True, None\n\n        except Exception as e:\n            return False, f\"Could not inspect filter signature: {e}\"\n\n    def _set_sequence_number(self) -&gt; int:\n        \"\"\"\n        Increment and return the event bus sequence number in a thread-safe manner.\n        \"\"\"\n        with self._lock:\n            self._sequence_number += 1\n            return self._sequence_number\n\n    @staticmethod\n    def _get_all_concrete_event_types() -&gt; list[type[events.Base.Event]]:\n        \"\"\"\n        Dynamically discover all concrete event types from the events module.\n        Automatically adapts to namespace changes without code modifications.\n\n        Returns:\n            list[type[events.Base.Event]]: List of concrete event classes that can be\n                instantiated and published.\n        \"\"\"\n        concrete_types = []\n\n        for attr_name in dir(events):\n            if attr_name.startswith(\"_\"):\n                continue\n\n            attr = getattr(events, attr_name)\n\n            if not inspect.isclass(attr) or attr_name == \"Base\":\n                continue\n\n            for member_name, member_obj in inspect.getmembers(attr, inspect.isclass):\n                if (\n                    issubclass(member_obj, events.Base.Event)\n                    and member_obj != events.Base.Event\n                    and not inspect.isabstract(member_obj)\n                ):\n                    concrete_types.append(member_obj)\n\n        return concrete_types\n\n    def _rebuild_cache(self) -&gt; None:\n        \"\"\"\n        Rebuild the pre-computed publish cache for all concrete event types.\n        This method should be called whenever subscriptions change.\n        \"\"\"\n        new_cache = {}\n        concrete_event_types = self._get_all_concrete_event_types()\n\n        for concrete_event_type in concrete_event_types:\n            handlers = []\n            seen_handler_ids = set()\n\n            for handler_type, handler_list in self._handlers.items():\n                if issubclass(concrete_event_type, handler_type):\n                    for handler, filter_func in handler_list:\n                        handler_id = id(handler)\n                        if handler_id not in seen_handler_ids:\n                            handlers.append((handler, filter_func))\n                            seen_handler_ids.add(handler_id)\n\n            if handlers:\n                new_cache[concrete_event_type] = handlers\n\n        self._publish_cache = new_cache\n\n        if console.logger.isEnabledFor(logging.DEBUG):\n            console.logger.debug(\n                f\"Publish cache rebuilt: {len(new_cache)} event types cached, \"\n                f\"total handlers: \"\n                f\"{sum(len(handlers) for handlers in new_cache.values())}\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the event bus with optimized data structures for high-performance event publishing.</p> <p>Attributes:</p> Name Type Description <code>self._handlers</code> <code>defaultdict</code> <p>Direct storage mapping event types  to handler lists</p> <code>self._publish_cache</code> <code>dict</code> <p>Pre-computed cache for O(1) publish operations</p> <code>self._lock</code> <code>Lock</code> <p>Single lock for all operations (subscribe/unsubscribe are rare)</p> <code>self._sequence_number</code> <code>int</code> <p>Sequence number counter for events</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initializes the event bus with optimized data structures for high-performance\n    event publishing.\n\n    Attributes:\n        self._handlers (collections.defaultdict): Direct storage mapping event types\n             to handler lists\n        self._publish_cache (dict): Pre-computed cache for O(1) publish operations\n        self._lock (threading.Lock): Single lock for all operations\n            (subscribe/unsubscribe are rare)\n        self._sequence_number (int): Sequence number counter for events\n    \"\"\"\n    self._handlers: dict[\n        type[events.Base.Event],\n        list[\n            tuple[\n                Callable[[events.Base.Event], None],\n                Callable[[events.Base.Event], bool],\n            ]\n        ],\n    ] = collections.defaultdict(list)\n\n    self._publish_cache: dict[\n        type[events.Base.Event],\n        list[\n            tuple[\n                Callable[[events.Base.Event], None],\n                Callable[[events.Base.Event], bool],\n            ]\n        ],\n    ] = {}\n\n    self._lock: threading.Lock = threading.Lock()\n    self._sequence_number: int = -1\n\n    self._rebuild_cache()\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.subscribe","title":"<code>subscribe(event_type, event_handler, event_filter=None)</code>","text":"<p>The <code>subscribe</code> method registers an event handler for event messages of a  specified type and all its subtypes (expressed as subclasses in the event   dataclass hierarchy, so-called inheritance-based subscription). When an event of that type or any subtype is published, the handler will be  invoked if the associated <code>event_filter</code> returns <code>True</code> for that event  instance. A given handler can only be subscribed once per event type. If the handler is already subscribed to the given event type  \u2014regardless of the filter function\u2014 the subscription attempt is ignored and a warning is logged.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>type[Event]</code> <p>Type of the event to subscribe to, must be a subclass of <code>events.Base.Event</code>.</p> required <code>event_handler</code> <code>Callable[Event, None]</code> <p>Function to call when an  event of the given type is published. This callable must accept a single argument of type <code>events.Base.Event</code>  (or its subclass).</p> required <code>event_filter</code> <code>Callable[[Event], bool] | None</code> <p>Function to  determine whether to call the event handler for a given event. Should accept one event and return <code>True</code> to handle or <code>False</code> to  ignore. Defaults to <code>None</code>, which creates a filter that always returns <code>True</code>  (i.e. always call the event handler).</p> <code>None</code> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def subscribe(\n    self,\n    event_type: type[events.Base.Event],\n    event_handler: Callable[[events.Base.Event], None],\n    event_filter: Callable[[events.Base.Event], bool] | None = None,\n) -&gt; None:\n    \"\"\"\n    The `subscribe` method registers an event handler for event messages of a\n     specified type and all its subtypes (expressed as subclasses in the event\n      dataclass hierarchy, so-called inheritance-based subscription).\n    When an event of that type or any subtype is published, the handler will be\n     invoked if the associated `event_filter` returns `True` for that event\n     instance.\n    A given handler can only be subscribed once per event type.\n    If the handler is already subscribed to the given event type\n     \u2014regardless of the filter function\u2014\n    the subscription attempt is ignored and a warning is logged.\n\n    Arguments:\n        event_type (type[events.Base.Event]): Type of the event to subscribe to,\n         must be a subclass of `events.Base.Event`.\n        event_handler (Callable[events.Base.Event, None]): Function to call when an\n             event of the given type is published.\n            This callable must accept a single argument of type `events.Base.Event`\n             (or its subclass).\n        event_filter (Callable[[events.Base.Event], bool] | None): Function to\n             determine whether to call the event handler for a given event.\n            Should accept one event and return `True` to handle or `False` to\n             ignore.\n            Defaults to `None`, which creates a filter that always returns `True`\n             (i.e. always call the event handler).\n    \"\"\"\n\n    if not issubclass(event_type, events.Base.Event):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_type must be a subclass of \"\n            f\"Event, got {type(event_type).__name__}\"\n        )\n        return\n\n    if not callable(event_handler):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_handler must be callable, \"\n            f\"got {type(event_handler).__name__}\"\n        )\n        return\n\n    if event_filter is None:\n\n        def event_filter(event: events.Base.Event) -&gt; bool:\n            return True\n\n    if not callable(event_filter):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_filter must be callable, \"\n            f\"got {type(event_filter).__name__}\"\n        )\n        return\n\n    is_valid, error_msg = self._validate_filter_signature(event_filter)\n    if not is_valid:\n        console.logger.error(f\"Invalid subscription attempt: {error_msg}\")\n        return\n\n    with self._lock:\n        if any(\n            event_handler == existing_handler\n            for existing_handler, _ in self._handlers[event_type]\n        ):\n            console.logger.warning(\n                f\"Duplicate subscription attempt: event_handler was already \"\n                f\"subscribed to {event_type.__name__}\"\n            )\n            return\n\n        self._handlers[event_type].append((event_handler, event_filter))\n\n        self._rebuild_cache()\n\n        handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n        console.logger.info(f\"Subscribed {handler_name} to {event_type.__name__}.\")\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(event_type, event_handler)</code>","text":"<p>The <code>unsubscribe</code> method removes an event handler from the subscribers list for  the specified event type. If the event handler is not subscribed to the given event type, the  unsubscription attempt is ignored and a warning is logged. After removing the event handler, the event type may have an empty subscribers  list but remains in the <code>subscribers</code> dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>type[Event]</code> <p>Type of the event to unsubscribe from,  must be a subclass of <code>events.Base.Event</code>.</p> required <code>event_handler</code> <code>Callable[Event, None]</code> <p>Event handler to remove  from the subscribers list (this will also remove the associated filter  function).</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def unsubscribe(\n    self,\n    event_type: type[events.Base.Event],\n    event_handler: Callable[[events.Base.Event], None],\n) -&gt; None:\n    \"\"\"\n    The `unsubscribe` method removes an event handler from the subscribers list for\n     the specified event type.\n    If the event handler is not subscribed to the given event type, the\n     unsubscription attempt is ignored and a warning is logged.\n    After removing the event handler, the event type may have an empty subscribers\n     list but remains in the `subscribers` dictionary.\n\n    Arguments:\n        event_type (type[events.Base.Event]): Type of the event to unsubscribe from,\n             must be a subclass of `events.Base.Event`.\n        event_handler (Callable[events.Base.Event, None]): Event handler to remove\n             from the subscribers list (this will also remove the associated filter\n             function).\n    \"\"\"\n    if not issubclass(event_type, events.Base.Event):\n        console.logger.error(\n            f\"Invalid unsubscription attempt: event_type must be a subclass of \"\n            f\"Event, got {type(event_type).__name__}\"\n        )\n        return\n\n    if not callable(event_handler):\n        console.logger.error(\n            f\"Invalid unsubscription attempt: callback must be callable, \"\n            f\"got {type(event_handler).__name__}\"\n        )\n        return\n\n    with self._lock:\n        if event_type not in self._handlers:\n            console.logger.warning(\n                f\"Attempted to unsubscribe from {event_type.__name__}, \"\n                f\"but no subscribers exist\"\n            )\n            return\n\n        current_handlers = self._handlers[event_type]\n        new_handlers = [\n            (existing_handler, existing_filter)\n            for existing_handler, existing_filter in current_handlers\n            if existing_handler != event_handler\n        ]\n\n        removed_count = len(current_handlers) - len(new_handlers)\n        if removed_count == 0:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.warning(\n                f\"Attempted to unsubscribe {handler_name} from \"\n                f\"{event_type.__name__}, but it was not subscribed\"\n            )\n            return\n\n        if new_handlers:\n            self._handlers[event_type] = new_handlers\n        else:\n            # Clean up empty lists\n            del self._handlers[event_type]\n\n        self._rebuild_cache()\n\n        handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n        console.logger.info(\n            f\"Unsubscribed {handler_name} from \"\n            f\"{event_type.__name__} (removed {removed_count} subscription(s))\"\n        )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"<p>The <code>publish</code> method delivers the event to all handlers subscribed to the  event's type or any of its parent types (inheritance-based subscription). Handlers are only called if their filter function returns True for this event. Handlers are called synchronously in the order they were subscribed.</p> <p>This method uses a pre-computed handler cache for O(1) lookup performance and runs without locks for maximum concurrency.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event to publish. Must be an instance of  <code>events.Base.Event</code> or one of its subclasses.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def publish(self, event: events.Base.Event) -&gt; None:\n    \"\"\"\n    The `publish` method delivers the event to all handlers subscribed to the\n     event's type or any of its parent types (inheritance-based subscription).\n    Handlers are only called if their filter function returns True for this event.\n    Handlers are called synchronously in the order they were subscribed.\n\n    This method uses a pre-computed handler cache for O(1) lookup performance\n    and runs without locks for maximum concurrency.\n\n    Arguments:\n        event (events.Base.Event): Event to publish. Must be an instance of\n             `events.Base.Event` or one of its subclasses.\n    \"\"\"\n    if not isinstance(event, events.Base.Event):\n        console.logger.error(\n            f\"Invalid publish attempt: event must be an instance of Event, \"\n            f\"got {type(event).__name__}\"\n        )\n        return\n\n    object.__setattr__(\n        event, \"event_bus_sequence_number\", self._set_sequence_number()\n    )\n\n    event_type: type[events.Base.Event] = type(event)\n\n    handlers = self._publish_cache.get(event_type, [])\n\n    if not handlers:\n        console.logger.warning(\n            f\"Published {event_type.__name__} but no subscribers exist - \"\n            f\"check event wiring\"\n        )\n        return\n\n    delivered_count = 0\n    for event_handler, event_filter in handlers:\n        try:\n            should_handle = event_filter(event)\n\n            if not isinstance(should_handle, bool):\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.warning(\n                    f\"Filter for handler {handler_name} returned \"\n                    f\"{type(should_handle).__name__}, expected bool. \"\n                    f\"Treating as False.\"\n                )\n                should_handle = False\n\n        except TypeError as type_error:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            if \"takes\" in str(type_error) and \"positional argument\" in str(\n                type_error\n            ):\n                console.logger.error(\n                    f\"Filter for handler {handler_name} has wrong signature: \"\n                    f\"{type_error}\"\n                )\n            else:\n                console.logger.exception(\n                    f\"Filter function for handler {handler_name} failed \"\n                    f\"processing {event_type.__name__}: {type_error}\"\n                )\n            continue\n        except Exception as filter_exception:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.exception(\n                f\"Filter function for handler {handler_name} failed \"\n                f\"processing {event_type.__name__}: {filter_exception}\"\n            )\n            continue\n\n        if should_handle:\n            try:\n                event_handler(event)\n                delivered_count += 1\n            except Exception as handler_exception:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.exception(\n                    f\"Handler {handler_name} failed processing \"\n                    f\"{event_type.__name__}: {handler_exception}\"\n                )\n\n    if delivered_count == 0:\n        console.logger.warning(\n            f\"Published {event_type.__name__} but no handlers received it - \"\n            f\"all {len(handlers)} handler(s) filtered out the event\"\n        )\n    else:\n        # Conditional debug logging to avoid string formatting overhead\n        if console.logger.isEnabledFor(logging.DEBUG):\n            console.logger.debug(\n                f\"Published {event_type.__name__} to {delivered_count} handler(s)\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._validate_filter_signature","title":"<code>_validate_filter_signature(event_filter)</code>  <code>staticmethod</code>","text":"<p>Validate that filter function has the correct signature.</p> <p>A valid filter function must: - Accept exactly 1 parameter (the event) - Not use args or *kwargs - Optionally return bool (if type annotated)</p> <p>Parameters:</p> Name Type Description Default <code>event_filter</code> <code>Callable</code> <p>The filter function to validate</p> required <p>Returns:</p> Type Description <code>tuple[bool, str | None]</code> <p>tuple[bool, str | None]: (is_valid, error_message) is_valid: True if signature is valid, False otherwise error_message: Description of the issue if invalid, None if valid</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>@staticmethod\ndef _validate_filter_signature(\n    event_filter: Callable[[events.Base.Event], bool],\n) -&gt; tuple[bool, str | None]:\n    \"\"\"\n    Validate that filter function has the correct signature.\n\n    A valid filter function must:\n    - Accept exactly 1 parameter (the event)\n    - Not use *args or **kwargs\n    - Optionally return bool (if type annotated)\n\n    Arguments:\n        event_filter (Callable): The filter function to validate\n\n    Returns:\n        tuple[bool, str | None]: (is_valid, error_message)\n            is_valid: True if signature is valid, False otherwise\n            error_message: Description of the issue if invalid, None if valid\n    \"\"\"\n    try:\n        sig = inspect.signature(event_filter)\n        params = list(sig.parameters.values())\n\n        if len(params) != 1:\n            return (\n                False,\n                f\"Filter must accept exactly 1 parameter, got {len(params)}\",\n            )\n\n        param = params[0]\n        if param.kind == inspect.Parameter.VAR_POSITIONAL:\n            return (\n                False,\n                \"Filter cannot use *args - must accept exactly 1 event parameter\",\n            )\n        if param.kind == inspect.Parameter.VAR_KEYWORD:\n            return (\n                False,\n                \"Filter cannot use **kwargs - must accept exactly 1 event \"\n                \"parameter\",\n            )\n\n        if sig.return_annotation is not inspect.Parameter.empty:\n            if sig.return_annotation is not bool:\n                return (\n                    False,\n                    f\"Filter return type should be bool, got \"\n                    f\"{sig.return_annotation}\",\n                )\n\n        return True, None\n\n    except Exception as e:\n        return False, f\"Could not inspect filter signature: {e}\"\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._set_sequence_number","title":"<code>_set_sequence_number()</code>","text":"<p>Increment and return the event bus sequence number in a thread-safe manner.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def _set_sequence_number(self) -&gt; int:\n    \"\"\"\n    Increment and return the event bus sequence number in a thread-safe manner.\n    \"\"\"\n    with self._lock:\n        self._sequence_number += 1\n        return self._sequence_number\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._get_all_concrete_event_types","title":"<code>_get_all_concrete_event_types()</code>  <code>staticmethod</code>","text":"<p>Dynamically discover all concrete event types from the events module. Automatically adapts to namespace changes without code modifications.</p> <p>Returns:</p> Type Description <code>list[type[Event]]</code> <p>list[type[events.Base.Event]]: List of concrete event classes that can be instantiated and published.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>@staticmethod\ndef _get_all_concrete_event_types() -&gt; list[type[events.Base.Event]]:\n    \"\"\"\n    Dynamically discover all concrete event types from the events module.\n    Automatically adapts to namespace changes without code modifications.\n\n    Returns:\n        list[type[events.Base.Event]]: List of concrete event classes that can be\n            instantiated and published.\n    \"\"\"\n    concrete_types = []\n\n    for attr_name in dir(events):\n        if attr_name.startswith(\"_\"):\n            continue\n\n        attr = getattr(events, attr_name)\n\n        if not inspect.isclass(attr) or attr_name == \"Base\":\n            continue\n\n        for member_name, member_obj in inspect.getmembers(attr, inspect.isclass):\n            if (\n                issubclass(member_obj, events.Base.Event)\n                and member_obj != events.Base.Event\n                and not inspect.isabstract(member_obj)\n            ):\n                concrete_types.append(member_obj)\n\n    return concrete_types\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._rebuild_cache","title":"<code>_rebuild_cache()</code>","text":"<p>Rebuild the pre-computed publish cache for all concrete event types. This method should be called whenever subscriptions change.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def _rebuild_cache(self) -&gt; None:\n    \"\"\"\n    Rebuild the pre-computed publish cache for all concrete event types.\n    This method should be called whenever subscriptions change.\n    \"\"\"\n    new_cache = {}\n    concrete_event_types = self._get_all_concrete_event_types()\n\n    for concrete_event_type in concrete_event_types:\n        handlers = []\n        seen_handler_ids = set()\n\n        for handler_type, handler_list in self._handlers.items():\n            if issubclass(concrete_event_type, handler_type):\n                for handler, filter_func in handler_list:\n                    handler_id = id(handler)\n                    if handler_id not in seen_handler_ids:\n                        handlers.append((handler, filter_func))\n                        seen_handler_ids.add(handler_id)\n\n        if handlers:\n            new_cache[concrete_event_type] = handlers\n\n    self._publish_cache = new_cache\n\n    if console.logger.isEnabledFor(logging.DEBUG):\n        console.logger.debug(\n            f\"Publish cache rebuilt: {len(new_cache)} event types cached, \"\n            f\"total handlers: \"\n            f\"{sum(len(handlers) for handlers in new_cache.values())}\"\n        )\n</code></pre>"},{"location":"api-reference/messaging/events/","title":"Events","text":"<p>This module provides the event messages used for decoupled communication between the  trading infrastructure's components. Events are organized into namespaces (<code>Market</code>, <code>Request</code>, <code>Response</code>, and <code>System</code>)  to provide clear semantic groupings. Base event messages used for structure inheritance are grouped under the  <code>Base</code> namespace. Dataclass field validation logic is grouped under the <code>_Validate</code> namespace.</p> Module Overview: <code>events.py</code> <pre><code>---\nconfig:\n  themeVariables:\n    fontSize: \"11px\"\n---\ngraph LR\n\nR[events.Base.Event]\nR1[events.Base.Market]\nR2[events.Base.Request]\nR21[events.Base.OrderRequest]\nR22[events.Base.CancelRequest]\nR3[events.Base.Response]\nR4[events.Base.System]\n\nR --&gt; R1\nR --&gt; R2\nR --&gt; R3\nR --&gt; R4\n\nR2 --&gt; R21\nR2 --&gt; R22\n\nA1[events.Market.IncomingBar]\n\nR1 --&gt; A1\n\nstyle A1 fill:#6F42C1,fill-opacity:0.3\n\nB1[events.Request.MarketOrder]\nB2[events.Request.LimitOrder]\nB3[events.Request.StopOrder]\nB4[events.Request.StopLimitOrder]\nB5[events.Request.CancelOrder]\nB6[events.Request.FlushSymbol]\nB7[events.Request.FlushAll]\n\nR21 --&gt; B1\nR21 --&gt; B2\nR21 --&gt; B3\nR21 --&gt; B4\nR22 --&gt; B5\nR22 --&gt; B6\nR22 --&gt; B7\n\nstyle B1 fill:#6F42C1,fill-opacity:0.3\nstyle B2 fill:#6F42C1,fill-opacity:0.3\nstyle B3 fill:#6F42C1,fill-opacity:0.3\nstyle B4 fill:#6F42C1,fill-opacity:0.3\nstyle B5 fill:#6F42C1,fill-opacity:0.3\nstyle B6 fill:#6F42C1,fill-opacity:0.3\nstyle B7 fill:#6F42C1,fill-opacity:0.3\n\nC1[events.Response.OrderSubmitted]\nC2[events.Response.OrderFilled]\nC3[events.Response.OrderCancelled]\nC4[events.Response.OrderRejected]\n\nR3 --&gt; C1\nR3 --&gt; C2\nR3 --&gt; C3\nR3 --&gt; C4\n\nstyle C1 fill:#6F42C1,fill-opacity:0.3\nstyle C2 fill:#6F42C1,fill-opacity:0.3\nstyle C3 fill:#6F42C1,fill-opacity:0.3\nstyle C4 fill:#6F42C1,fill-opacity:0.3\n\nD1[events.System.Shutdown]\n\nR4 --&gt; D1\n\nstyle D1 fill:#6F42C1,fill-opacity:0.3\n\n\nsubgraph Market [\"Market Update Event Messages\"]\n    R1\n    A1\n\n    subgraph MarketNamespace [\"events.Market Namespace\"]\n        A1\n    end\n\nend\n\n\nsubgraph Request [\"Broker Request Event Messages\"]\n    R2\n    R21\n    R22\n    B1\n    B2\n    B3\n    B4\n    B5\n    B6\n    B7\n\n    subgraph RequestNamespace [\"events.Request Namespace\"]\n        B1\n        B2\n        B3\n        B4\n        B5\n        B6\n        B7\n    end\n\nend\n\nsubgraph Response [\"Broker Response Event Messages\"]\n    R3\n    C1\n    C2\n    C3\n    C4\n\n    subgraph ResponseNamespace [\"events.Response Namespace\"]\n        C1\n        C2\n        C3\n        C4\n    end\n\nend\n\nsubgraph System [\"System-Internal Event Messages\"]\n    R4\n    D1\n\n    subgraph SystemNamespace [\"events.System Namespace\"]\n        D1\n    end\n\nend</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base","title":"<code>Base</code>","text":"<p>Namespace for event base dataclasses.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Base:\n    \"\"\"\n    Namespace for event base dataclasses.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Event:\n        \"\"\"\n        Base event message dataclass.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            ts_event (pd.Timestamp): Timestamp of the event in pandas Timestamp format.\n                (Must be timezone-aware.)\n            event_bus_sequence_number (int | None): Auto-generated Sequence number of\n                 the event.\n                This will be assigned as soon as the event enters the event bus via\n                 `messaging.EventBus.publish(&lt;event&gt;)`.\n        \"\"\"\n\n        ts_event: pd.Timestamp\n        event_bus_sequence_number: int | None = dataclasses.field(\n            default=None, init=False\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Event:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            _Validate.timezone_aware(self.ts_event, \"ts_event\", \"Event\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Market(Event):\n        \"\"\"\n        Base event message dataclass for market events.\n        Inherits from `Base.Event`.\n        Each market event message is associated with a specific financial instrument via\n         the `symbol` field.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            symbol (str): Symbol of the financial instrument.\n        \"\"\"\n\n        symbol: str\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Market:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, \"Market event\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Request(Event):\n        \"\"\"\n        Base event message dataclass for broker requests.\n        This dataclass cannot be instantiated directly.\n        `ts_event` is auto-generated by default.\n\n        Attributes:\n            ts_event: Timestamp of the event. (defaults to current UTC time;\n                auto-generated)\n        \"\"\"\n\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Request:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderRequest(Request):\n        \"\"\"\n        Base event message dataclass for order requests.\n        Inherits from `Base.Request`.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            symbol (str): Symbol of the financial instrument.\n            side (models.Side): Side of the order.\n            quantity (float): Quantity of the order.\n            time_in_force (models.TimeInForce): Time in force of the order.\n            order_expiration (pd.Timestamp | None): Expiration timestamp of the order\n                (optional).\n                Only relevant if `time_in_force` is `models.TimeInForce.GTD`.\n            order_id (uuid.UUID): Unique ID of the order. (auto-generated)\n        \"\"\"\n\n        symbol: str\n        side: models.Side\n        quantity: float\n        time_in_force: models.TimeInForce\n        order_expiration: pd.Timestamp | None = None\n        order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.OrderRequest:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, f\"Order {self.order_id}\")\n\n            _Validate.timezone_aware(\n                self.order_expiration, \"order_expiration\", f\"Order {self.order_id}\"\n            )\n            _Validate.quantity(self.quantity, f\"Order {self.order_id}\")\n\n            if self.time_in_force.value == 4:\n                if self.order_expiration is None:\n                    console.logger.error(\n                        f\"Order {self.order_id}: GTD order missing expiration \"\n                        f\"timestamp.\"\n                    )\n                elif self.order_expiration &lt;= self.ts_event:\n                    console.logger.error(\n                        f\"Order {self.order_id}: GTD expiration \"\n                        f\"{self.order_expiration} \"\n                        f\"is not after event timestamp {self.ts_event}.\"\n                    )\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelRequest(Request):\n        \"\"\"\n        Base event message dataclass for order cancellation requests.\n        Inherits from `Base.Request`.\n        This dataclass cannot be instantiated directly.\n        \"\"\"\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.CancelRequest:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Response(Event):\n        \"\"\"\n        Base event message dataclass for broker responses.\n        This dataclass cannot be instantiated directly.\n        \"\"\"\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Response:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class System(Event):\n        \"\"\"\n        Base event message dataclass for system-internal messages.\n        This dataclass cannot be instantiated directly.\n        `ts_event` is auto-generated by default.\n\n        Attributes:\n            ts_event: Timestamp of the event. (defaults to current UTC time;\n                auto-generated)\n        \"\"\"\n\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.System:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>Base event message dataclass. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event in pandas Timestamp format. (Must be timezone-aware.)</p> <code>event_bus_sequence_number</code> <code>int | None</code> <p>Auto-generated Sequence number of  the event. This will be assigned as soon as the event enters the event bus via  <code>messaging.EventBus.publish(&lt;event&gt;)</code>.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Event:\n    \"\"\"\n    Base event message dataclass.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        ts_event (pd.Timestamp): Timestamp of the event in pandas Timestamp format.\n            (Must be timezone-aware.)\n        event_bus_sequence_number (int | None): Auto-generated Sequence number of\n             the event.\n            This will be assigned as soon as the event enters the event bus via\n             `messaging.EventBus.publish(&lt;event&gt;)`.\n    \"\"\"\n\n    ts_event: pd.Timestamp\n    event_bus_sequence_number: int | None = dataclasses.field(\n        default=None, init=False\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Event:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        _Validate.timezone_aware(self.ts_event, \"ts_event\", \"Event\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Market","title":"<code>Market</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for market events. Inherits from <code>Base.Event</code>. Each market event message is associated with a specific financial instrument via  the <code>symbol</code> field. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol of the financial instrument.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Market(Event):\n    \"\"\"\n    Base event message dataclass for market events.\n    Inherits from `Base.Event`.\n    Each market event message is associated with a specific financial instrument via\n     the `symbol` field.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        symbol (str): Symbol of the financial instrument.\n    \"\"\"\n\n    symbol: str\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Market:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, \"Market event\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for broker requests. This dataclass cannot be instantiated directly. <code>ts_event</code> is auto-generated by default.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event. (defaults to current UTC time; auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Request(Event):\n    \"\"\"\n    Base event message dataclass for broker requests.\n    This dataclass cannot be instantiated directly.\n    `ts_event` is auto-generated by default.\n\n    Attributes:\n        ts_event: Timestamp of the event. (defaults to current UTC time;\n            auto-generated)\n    \"\"\"\n\n    ts_event: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Request:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.OrderRequest","title":"<code>OrderRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Base event message dataclass for order requests. Inherits from <code>Base.Request</code>. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol of the financial instrument.</p> <code>side</code> <code>Side</code> <p>Side of the order.</p> <code>quantity</code> <code>float</code> <p>Quantity of the order.</p> <code>time_in_force</code> <code>TimeInForce</code> <p>Time in force of the order.</p> <code>order_expiration</code> <code>Timestamp | None</code> <p>Expiration timestamp of the order (optional). Only relevant if <code>time_in_force</code> is <code>models.TimeInForce.GTD</code>.</p> <code>order_id</code> <code>UUID</code> <p>Unique ID of the order. (auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderRequest(Request):\n    \"\"\"\n    Base event message dataclass for order requests.\n    Inherits from `Base.Request`.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        symbol (str): Symbol of the financial instrument.\n        side (models.Side): Side of the order.\n        quantity (float): Quantity of the order.\n        time_in_force (models.TimeInForce): Time in force of the order.\n        order_expiration (pd.Timestamp | None): Expiration timestamp of the order\n            (optional).\n            Only relevant if `time_in_force` is `models.TimeInForce.GTD`.\n        order_id (uuid.UUID): Unique ID of the order. (auto-generated)\n    \"\"\"\n\n    symbol: str\n    side: models.Side\n    quantity: float\n    time_in_force: models.TimeInForce\n    order_expiration: pd.Timestamp | None = None\n    order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.OrderRequest:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, f\"Order {self.order_id}\")\n\n        _Validate.timezone_aware(\n            self.order_expiration, \"order_expiration\", f\"Order {self.order_id}\"\n        )\n        _Validate.quantity(self.quantity, f\"Order {self.order_id}\")\n\n        if self.time_in_force.value == 4:\n            if self.order_expiration is None:\n                console.logger.error(\n                    f\"Order {self.order_id}: GTD order missing expiration \"\n                    f\"timestamp.\"\n                )\n            elif self.order_expiration &lt;= self.ts_event:\n                console.logger.error(\n                    f\"Order {self.order_id}: GTD expiration \"\n                    f\"{self.order_expiration} \"\n                    f\"is not after event timestamp {self.ts_event}.\"\n                )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.CancelRequest","title":"<code>CancelRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Base event message dataclass for order cancellation requests. Inherits from <code>Base.Request</code>. This dataclass cannot be instantiated directly.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass CancelRequest(Request):\n    \"\"\"\n    Base event message dataclass for order cancellation requests.\n    Inherits from `Base.Request`.\n    This dataclass cannot be instantiated directly.\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.CancelRequest:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Response","title":"<code>Response</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for broker responses. This dataclass cannot be instantiated directly.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Response(Event):\n    \"\"\"\n    Base event message dataclass for broker responses.\n    This dataclass cannot be instantiated directly.\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Response:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.System","title":"<code>System</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for system-internal messages. This dataclass cannot be instantiated directly. <code>ts_event</code> is auto-generated by default.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event. (defaults to current UTC time; auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass System(Event):\n    \"\"\"\n    Base event message dataclass for system-internal messages.\n    This dataclass cannot be instantiated directly.\n    `ts_event` is auto-generated by default.\n\n    Attributes:\n        ts_event: Timestamp of the event. (defaults to current UTC time;\n            auto-generated)\n    \"\"\"\n\n    ts_event: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.System:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Market","title":"<code>Market</code>","text":"<p>Namespace for market update event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Market:\n    \"\"\"\n    Namespace for market update event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class IncomingBar(Base.Market):\n        \"\"\"\n        Event message dataclass for incoming market data bars.\n        Inherits from `Base.Market`.\n\n        Attributes:\n            bar (models.Bar): Bar of market data.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; event = events.Market.IncomingBar(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     symbol=\"AAPL\",\n            ...     bar=models.Bar(\n            ...         open=100.0,\n            ...         high=101.0,\n            ...         low=99.0,\n            ...         close=100.5,\n            ...         volume=10000,\n            ...     ),\n            ... )\n            ```\n        \"\"\"\n\n        bar: models.Bar\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Market.IncomingBar","title":"<code>IncomingBar</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Market</code></p> <p>Event message dataclass for incoming market data bars. Inherits from <code>Base.Market</code>.</p> <p>Attributes:</p> Name Type Description <code>bar</code> <code>Bar</code> <p>Bar of market data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     symbol=\"AAPL\",\n...     bar=models.Bar(\n...         open=100.0,\n...         high=101.0,\n...         low=99.0,\n...         close=100.5,\n...         volume=10000,\n...     ),\n... )\n```\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass IncomingBar(Base.Market):\n    \"\"\"\n    Event message dataclass for incoming market data bars.\n    Inherits from `Base.Market`.\n\n    Attributes:\n        bar (models.Bar): Bar of market data.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     symbol=\"AAPL\",\n        ...     bar=models.Bar(\n        ...         open=100.0,\n        ...         high=101.0,\n        ...         low=99.0,\n        ...         close=100.5,\n        ...         volume=10000,\n        ...     ),\n        ... )\n        ```\n    \"\"\"\n\n    bar: models.Bar\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request","title":"<code>Request</code>","text":"<p>Namespace for broker request event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Request:\n    \"\"\"\n    Namespace for broker request event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class MarketOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a market order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.MARKET).\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.MarketOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.MARKET\n        )\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class LimitOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a limit order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.LIMIT).\n            limit_price (float): Limit price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.LimitOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     limit_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.LIMIT\n        )\n        limit_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class StopOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a stop order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.STOP).\n            stop_price (float): Stop price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.StopOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     stop_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.STOP\n        )\n        stop_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class StopLimitOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a stop-limit order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.STOP_LIMIT).\n            stop_price (float): Stop price of the order.\n            limit_price (float): Limit price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.StopLimitOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     stop_price=100.0,\n            ...     limit_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.STOP_LIMIT\n        )\n        stop_price: float\n        limit_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelOrder(Base.CancelRequest):\n        \"\"\"\n        Event message dataclass for cancelling an order.\n\n        Attributes:\n            order_id (uuid.UUID): Unique ID of the order to cancel.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.CancelOrder(\n            ...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n            ... )\n        \"\"\"\n\n        order_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class FlushSymbol(Base.Request):\n        \"\"\"\n        Event message dataclass for flushing all orders for a symbol.\n\n        Attributes:\n            symbol (str): Symbol to flush.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.FlushSymbol(\n            ...     symbol=\"AAPL\",\n            ... )\n        \"\"\"\n\n        symbol: str\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, \"Flush request\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class FlushAll(Base.Request):\n        \"\"\"\n        Event message dataclass for flushing all orders for all symbols.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.FlushAll()\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.MarketOrder","title":"<code>MarketOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a market order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.MarketOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass MarketOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a market order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.MARKET).\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.MarketOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.MARKET\n    )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.LimitOrder","title":"<code>LimitOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a limit order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>limit_price</code> <code>float</code> <p>Limit price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.LimitOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     limit_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass LimitOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a limit order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.LIMIT).\n        limit_price (float): Limit price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.LimitOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     limit_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.LIMIT\n    )\n    limit_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.StopOrder","title":"<code>StopOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a stop order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>stop_price</code> <code>float</code> <p>Stop price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.StopOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     stop_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass StopOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a stop order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.STOP).\n        stop_price (float): Stop price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.StopOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     stop_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.STOP\n    )\n    stop_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.StopLimitOrder","title":"<code>StopLimitOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a stop-limit order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>stop_price</code> <code>float</code> <p>Stop price of the order.</p> <code>limit_price</code> <code>float</code> <p>Limit price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.StopLimitOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     stop_price=100.0,\n...     limit_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass StopLimitOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a stop-limit order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.STOP_LIMIT).\n        stop_price (float): Stop price of the order.\n        limit_price (float): Limit price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.StopLimitOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     stop_price=100.0,\n        ...     limit_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.STOP_LIMIT\n    )\n    stop_price: float\n    limit_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.CancelOrder","title":"<code>CancelOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CancelRequest</code></p> <p>Event message dataclass for cancelling an order.</p> <p>Attributes:</p> Name Type Description <code>order_id</code> <code>UUID</code> <p>Unique ID of the order to cancel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.CancelOrder(\n...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass CancelOrder(Base.CancelRequest):\n    \"\"\"\n    Event message dataclass for cancelling an order.\n\n    Attributes:\n        order_id (uuid.UUID): Unique ID of the order to cancel.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.CancelOrder(\n        ...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n        ... )\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.FlushSymbol","title":"<code>FlushSymbol</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Event message dataclass for flushing all orders for a symbol.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol to flush.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.FlushSymbol(\n...     symbol=\"AAPL\",\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass FlushSymbol(Base.Request):\n    \"\"\"\n    Event message dataclass for flushing all orders for a symbol.\n\n    Attributes:\n        symbol (str): Symbol to flush.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.FlushSymbol(\n        ...     symbol=\"AAPL\",\n        ... )\n    \"\"\"\n\n    symbol: str\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, \"Flush request\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.FlushAll","title":"<code>FlushAll</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Event message dataclass for flushing all orders for all symbols.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.FlushAll()\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass FlushAll(Base.Request):\n    \"\"\"\n    Event message dataclass for flushing all orders for all symbols.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.FlushAll()\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response","title":"<code>Response</code>","text":"<p>Namespace for broker response event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Response:\n    \"\"\"\n    Namespace for broker response event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderSubmitted(Base.Response):\n        \"\"\"\n        Event message dataclass for order submission confirmation from the broker.\n\n        Attributes:\n            order_submitted_id (uuid.UUID): Unique ID of the submitted order.\n            associated_request_id (uuid.UUID): Unique ID of the request that triggered\n                the order submission.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderSubmitted(\n            ...     ts_event=pd.Timestamp(\n            ...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"),\n            ...     associated_request_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ... )\n        \"\"\"\n\n        order_submitted_id: uuid.UUID\n        associated_request_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderFilled(Base.Response):\n        \"\"\"\n        Event message dataclass for order fill confirmation from the broker.\n\n        Attributes:\n            fill_id (uuid.UUID): Unique ID of the fill. (auto-generated)\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that triggered the fill.\n            side (models.Side): Side of the fill.\n            quantity_filled (float): Quantity filled.\n            filled_at_price (float): Price at which the fill was executed.\n            commission_and_fees (float): Commission and fees for the fill.\n            net_fill_value (float): Net fill value (auto-generated).\n            exchange (str | None): Exchange on which the fill was executed. (optional;\n                defaults to \"SIMULATED\")\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderFilled(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ...     side=models.Side.BUY,\n            ...     quantity_filled=100.0,\n            ...     filled_at_price=100.0,\n            ...     commission_and_fees=1.0,\n            ... )\n        \"\"\"\n\n        fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n        associated_order_submitted_id: uuid.UUID\n        side: models.Side\n        quantity_filled: float\n        filled_at_price: float\n        commission_and_fees: float\n        net_fill_value: float = dataclasses.field(init=False)\n        exchange: str | None = None\n\n        def __post_init__(self):\n            object.__setattr__(self, \"fill_id\", self.fill_id or uuid.uuid4())\n\n            gross_value = self.filled_at_price * self.quantity_filled\n\n            if self.side.value == 1:\n                net_value = gross_value + self.commission_and_fees\n            else:\n                net_value = gross_value - self.commission_and_fees\n\n            object.__setattr__(self, \"net_fill_value\", net_value)\n\n            object.__setattr__(self, \"exchange\", self.exchange or \"SIMULATED\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderCancelled(Base.Response):\n        \"\"\"\n        Event message dataclass for order cancellation confirmation from the broker.\n\n        Attributes:\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that was cancelled.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderCancelled(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ... )\n        \"\"\"\n\n        associated_order_submitted_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderRejected(Base.Response):\n        \"\"\"\n        Event message dataclass for order rejection confirmation from the broker.\n\n        Attributes:\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that was rejected.\n            reason (models.OrderRejectionReason): Reason for the rejection.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderRejected(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n            ... )\n        \"\"\"\n\n        associated_order_submitted_id: uuid.UUID\n        reason: models.OrderRejectionReason\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderSubmitted","title":"<code>OrderSubmitted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order submission confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order.</p> <code>associated_request_id</code> <code>UUID</code> <p>Unique ID of the request that triggered the order submission.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderSubmitted(\n...     ts_event=pd.Timestamp(\n...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"),\n...     associated_request_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderSubmitted(Base.Response):\n    \"\"\"\n    Event message dataclass for order submission confirmation from the broker.\n\n    Attributes:\n        order_submitted_id (uuid.UUID): Unique ID of the submitted order.\n        associated_request_id (uuid.UUID): Unique ID of the request that triggered\n            the order submission.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderSubmitted(\n        ...     ts_event=pd.Timestamp(\n        ...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"),\n        ...     associated_request_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ... )\n    \"\"\"\n\n    order_submitted_id: uuid.UUID\n    associated_request_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderFilled","title":"<code>OrderFilled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order fill confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>fill_id</code> <code>UUID</code> <p>Unique ID of the fill. (auto-generated)</p> <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that triggered the fill.</p> <code>side</code> <code>Side</code> <p>Side of the fill.</p> <code>quantity_filled</code> <code>float</code> <p>Quantity filled.</p> <code>filled_at_price</code> <code>float</code> <p>Price at which the fill was executed.</p> <code>commission_and_fees</code> <code>float</code> <p>Commission and fees for the fill.</p> <code>net_fill_value</code> <code>float</code> <p>Net fill value (auto-generated).</p> <code>exchange</code> <code>str | None</code> <p>Exchange on which the fill was executed. (optional; defaults to \"SIMULATED\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderFilled(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n...     side=models.Side.BUY,\n...     quantity_filled=100.0,\n...     filled_at_price=100.0,\n...     commission_and_fees=1.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderFilled(Base.Response):\n    \"\"\"\n    Event message dataclass for order fill confirmation from the broker.\n\n    Attributes:\n        fill_id (uuid.UUID): Unique ID of the fill. (auto-generated)\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that triggered the fill.\n        side (models.Side): Side of the fill.\n        quantity_filled (float): Quantity filled.\n        filled_at_price (float): Price at which the fill was executed.\n        commission_and_fees (float): Commission and fees for the fill.\n        net_fill_value (float): Net fill value (auto-generated).\n        exchange (str | None): Exchange on which the fill was executed. (optional;\n            defaults to \"SIMULATED\")\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderFilled(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ...     side=models.Side.BUY,\n        ...     quantity_filled=100.0,\n        ...     filled_at_price=100.0,\n        ...     commission_and_fees=1.0,\n        ... )\n    \"\"\"\n\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    associated_order_submitted_id: uuid.UUID\n    side: models.Side\n    quantity_filled: float\n    filled_at_price: float\n    commission_and_fees: float\n    net_fill_value: float = dataclasses.field(init=False)\n    exchange: str | None = None\n\n    def __post_init__(self):\n        object.__setattr__(self, \"fill_id\", self.fill_id or uuid.uuid4())\n\n        gross_value = self.filled_at_price * self.quantity_filled\n\n        if self.side.value == 1:\n            net_value = gross_value + self.commission_and_fees\n        else:\n            net_value = gross_value - self.commission_and_fees\n\n        object.__setattr__(self, \"net_fill_value\", net_value)\n\n        object.__setattr__(self, \"exchange\", self.exchange or \"SIMULATED\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderCancelled","title":"<code>OrderCancelled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order cancellation confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that was cancelled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderCancelled(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderCancelled(Base.Response):\n    \"\"\"\n    Event message dataclass for order cancellation confirmation from the broker.\n\n    Attributes:\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that was cancelled.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderCancelled(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ... )\n    \"\"\"\n\n    associated_order_submitted_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderRejected","title":"<code>OrderRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order rejection confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that was rejected.</p> <code>reason</code> <code>OrderRejectionReason</code> <p>Reason for the rejection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderRejected(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderRejected(Base.Response):\n    \"\"\"\n    Event message dataclass for order rejection confirmation from the broker.\n\n    Attributes:\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that was rejected.\n        reason (models.OrderRejectionReason): Reason for the rejection.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderRejected(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n        ... )\n    \"\"\"\n\n    associated_order_submitted_id: uuid.UUID\n    reason: models.OrderRejectionReason\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.System","title":"<code>System</code>","text":"<p>Namespace for system-internal event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class System:\n    \"\"\"\n    Namespace for system-internal event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Shutdown(Base.System):\n        \"\"\"\n        Event message dataclass for system shutdown.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.System.Shutdown()\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.System.Shutdown","title":"<code>Shutdown</code>  <code>dataclass</code>","text":"<p>               Bases: <code>System</code></p> <p>Event message dataclass for system shutdown.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.System.Shutdown()\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Shutdown(Base.System):\n    \"\"\"\n    Event message dataclass for system shutdown.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.System.Shutdown()\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate","title":"<code>_Validate</code>","text":"<p>Internal validation utilities for events.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class _Validate:\n    \"\"\"Internal validation utilities for events.\"\"\"\n\n    @staticmethod\n    def symbol(symbol: str, context: str = \"\") -&gt; None:\n        \"\"\"Validate symbol format and log errors.\"\"\"\n        if not symbol or not symbol.strip():\n            console.logger.error(f\"{context}: Symbol cannot be empty or whitespace\")\n            return\n\n        if not re.fullmatch(r\"[A-Z0-9._-]+\", symbol):\n            console.logger.error(f\"{context}: Invalid symbol format: {symbol}\")\n\n    @staticmethod\n    def quantity(quantity: float, context: str = \"\") -&gt; None:\n        \"\"\"Validate quantity values and log errors.\"\"\"\n        if (\n            quantity != quantity\n            or quantity == float(\"inf\")\n            or quantity == float(\"-inf\")\n        ):\n            console.logger.error(f\"{context}: quantity cannot be NaN or infinite\")\n            return\n\n        if quantity &lt;= 0:\n            console.logger.error(\n                f\"{context}: quantity must be positive, got {quantity}\"\n            )\n\n        if quantity &gt; 1e9:\n            console.logger.error(f\"{context}: quantity too large: {quantity}\")\n\n    @staticmethod\n    def timezone_aware(\n        timestamp: pd.Timestamp | None, field_name: str, context: str = \"\"\n    ) -&gt; None:\n        \"\"\"Validate that timestamp is timezone-aware and log errors.\"\"\"\n        if timestamp is not None and timestamp.tz is None:\n            console.logger.error(\n                f\"{context}: {field_name} must be timezone-aware, got {timestamp}\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.symbol","title":"<code>symbol(symbol, context='')</code>  <code>staticmethod</code>","text":"<p>Validate symbol format and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef symbol(symbol: str, context: str = \"\") -&gt; None:\n    \"\"\"Validate symbol format and log errors.\"\"\"\n    if not symbol or not symbol.strip():\n        console.logger.error(f\"{context}: Symbol cannot be empty or whitespace\")\n        return\n\n    if not re.fullmatch(r\"[A-Z0-9._-]+\", symbol):\n        console.logger.error(f\"{context}: Invalid symbol format: {symbol}\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.quantity","title":"<code>quantity(quantity, context='')</code>  <code>staticmethod</code>","text":"<p>Validate quantity values and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef quantity(quantity: float, context: str = \"\") -&gt; None:\n    \"\"\"Validate quantity values and log errors.\"\"\"\n    if (\n        quantity != quantity\n        or quantity == float(\"inf\")\n        or quantity == float(\"-inf\")\n    ):\n        console.logger.error(f\"{context}: quantity cannot be NaN or infinite\")\n        return\n\n    if quantity &lt;= 0:\n        console.logger.error(\n            f\"{context}: quantity must be positive, got {quantity}\"\n        )\n\n    if quantity &gt; 1e9:\n        console.logger.error(f\"{context}: quantity too large: {quantity}\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.timezone_aware","title":"<code>timezone_aware(timestamp, field_name, context='')</code>  <code>staticmethod</code>","text":"<p>Validate that timestamp is timezone-aware and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef timezone_aware(\n    timestamp: pd.Timestamp | None, field_name: str, context: str = \"\"\n) -&gt; None:\n    \"\"\"Validate that timestamp is timezone-aware and log errors.\"\"\"\n    if timestamp is not None and timestamp.tz is None:\n        console.logger.error(\n            f\"{context}: {field_name} must be timezone-aware, got {timestamp}\"\n        )\n</code></pre>"},{"location":"api-reference/monitoring/console/","title":"Console","text":"<p>Console logging utilities for OneSecondTrader.</p> <p>Simple console logging configuration for terminal output.</p> Source code in <code>console.py</code> <pre><code>\"\"\"Console logging utilities for OneSecondTrader.\n\nSimple console logging configuration for terminal output.\n\"\"\"\n\nimport logging\n\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(asctime)s - %(levelname)s - %(threadName)s - %(message)s\",\n)\n\nlogger = logging.getLogger(\"onesecondtrader\")\n</code></pre>"},{"location":"documentation/architecture/","title":"Package Architecture","text":""},{"location":"documentation/architecture/#event-driven-paradigm","title":"Event-Driven Paradigm","text":"<p>OneSecondTrader is designed as an event-driven system, with an event bus managing  communication between decoupled system components via a publish-subscribe messaging  pattern based on standardized event messages.</p>"},{"location":"documentation/backtesting/","title":"Strategy Backtesting","text":""},{"location":"documentation/overview/","title":"Package Documentation","text":"<ul> <li> <p> Package Architecture </p> <p> Read Architecture Documentation Page</p> </li> </ul>"},{"location":"documentation/trading/","title":"Live Trading","text":""}]}