{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"explanation/overview/","title":"Explanation","text":""},{"location":"explanation/overview/#models-package","title":"Models Package","text":"<p>The <code>models</code> package defines the fundamental domain concepts used throughout the trading system.</p> <p>Concrete definitions and their semantics are documented in the API Reference.</p> <p> View Models Package API Reference.</p>"},{"location":"explanation/overview/#events-package","title":"Events Package","text":"<p>The <code>events</code> package defines the event message objects propagated through the system.</p> <p>Concrete types of event message objects and their payloads are documented in the API Reference.</p> <p> View Events Package API Reference.</p>"},{"location":"explanation/overview/#indicators-package","title":"Indicators Package","text":"<p>The <code>indicators</code> package provides a library of common technical indicators and a base class for creating custom ones. Indicators are intended to be used in the context of (multi-symbol) strategies and provide a thread-safe mechanism for storing and retrieving per-symbol indicator values computed from incoming market bars.</p> <p>Concrete indicators and their computation logic, as well as the base class for creating custom indicators, are documented in the API Reference.</p> <p> View Indicators Package API Reference.</p>"},{"location":"explanation/overview/#messaging-package","title":"Messaging Package","text":"<p>The <code>messaging</code> package provides the infrastructure for event-based communication between system components. It provides an event dispatch mechanism for propagating event objects to subscribers and a base class for system components that subscribe to or publish events.</p> <p>The event bus and subscriber base class are documented in the API Reference.</p> <p> View Messaging Package API Reference.</p>"},{"location":"reference/overview/","title":"Reference","text":"<ul> <li> <p>Brokers </p> <p>Provides interfaces for order execution via a simulated broker and adapters to real venues.</p> <p> View <code>brokers</code> package API</p> </li> <li> <p>Dashboard </p> <p>Provides a web dashboard for running backtests and viewing run history.</p> <p> View <code>dashboard</code> package API</p> </li> <li> <p>Datafeeds </p> <p>Provides data feed components for ingesting market data into the system.</p> <p> View <code>datafeeds</code> package API</p> </li> <li> <p>Events </p> <p>Defines the event message objects propagated through the system.</p> <p> View <code>events</code> package API</p> </li> <li> <p>Indicators </p> <p>Provides a library of common technical indicators and a base class for creating custom ones.</p> <p> View <code>indicators</code> package API</p> </li> <li> <p>Messaging </p> <p>Provides the infrastructure for event-based communication between system components.</p> <p> View <code>messaging</code> package API</p> </li> <li> <p>Models </p> <p>Defines the fundamental domain concepts used throughout the trading system.</p> <p> View <code>models</code> package API</p> </li> <li> <p>Orchestrator </p> <p>Orchestrates the execution of a trading run and records all events to a SQLite database.</p> <p> View <code>orchestrator</code> package API</p> </li> <li> <p>Secmaster </p> <p>Provides a schema for creating and utilities to populate the security master database.</p> <p> View <code>secmaster</code> package API</p> </li> <li> <p>Strategies </p> <p>Provides a base class for creating custom trading strategies and provides example strategies.</p> <p> View <code>strategies</code> package API</p> </li> </ul>"},{"location":"reference/brokers/base/","title":"Base","text":""},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase","title":"<code>BrokerBase</code>","text":"<p>               Bases: <code>Subscriber</code></p> <p>Abstract base class for broker components.</p> <p>A broker component receives order-related request events from the event bus and translates them into actions against an external execution venue or simulated environment. Responses to these requests are published back onto the event bus.</p> <p>This class defines the event-handling interface and subscription logic common to all broker implementations.</p>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the broker and subscribe to order request events.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for receiving order requests and publishing response events.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Initialize the broker and subscribe to order request events.\n\n    Parameters:\n        event_bus:\n            Event bus used for receiving order requests and publishing response events.\n    \"\"\"\n    super().__init__(event_bus)\n\n    self._subscribe(\n        events.requests.OrderSubmissionRequest,\n        events.requests.OrderCancellationRequest,\n        events.requests.OrderModificationRequest,\n    )\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Establish a connection to the external broker API. For simulated broker, this method is a no-op.</p> <p>Implementations are responsible for initializing any external resources required to submit, modify, or cancel orders.</p> Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef connect(self) -&gt; None:\n    \"\"\"\n    Establish a connection to the external broker API.\n    For simulated broker, this method is a no-op.\n\n    Implementations are responsible for initializing any external resources required to submit, modify, or cancel orders.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect the external broker API and stop event processing. For simulated broker, this method is a no-op.</p> <p>This method shuts down the subscriber and releases associated resources.</p> Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect the external broker API and stop event processing.\n    For simulated broker, this method is a no-op.\n\n    This method shuts down the subscriber and releases associated resources.\n    \"\"\"\n    self.shutdown()\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_event","title":"<code>_on_event(event)</code>","text":"<p>Dispatch incoming order-related events to the appropriate handler.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Incoming event received from the event bus.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Dispatch incoming order-related events to the appropriate handler.\n\n    Parameters:\n        event:\n            Incoming event received from the event bus.\n    \"\"\"\n    match event:\n        case events.requests.OrderSubmissionRequest() as submit_order:\n            self._on_submit_order(submit_order)\n        case events.requests.OrderCancellationRequest() as cancel_order:\n            self._on_cancel_order(cancel_order)\n        case events.requests.OrderModificationRequest() as modify_order:\n            self._on_modify_order(modify_order)\n        case _:\n            return\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_submit_order","title":"<code>_on_submit_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order submission request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_submit_order(self, event: events.requests.OrderSubmissionRequest) -&gt; None:\n    \"\"\"\n    Handle an order submission request.\n\n    Parameters:\n        event:\n            Order submission request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_cancel_order","title":"<code>_on_cancel_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order cancellation request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderCancellationRequest</code> <p>Order cancellation request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_cancel_order(self, event: events.requests.OrderCancellationRequest) -&gt; None:\n    \"\"\"\n    Handle an order cancellation request.\n\n    Parameters:\n        event:\n            Order cancellation request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._on_modify_order","title":"<code>_on_modify_order(event)</code>  <code>abstractmethod</code>","text":"<p>Handle an order modification request.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_modify_order(self, event: events.requests.OrderModificationRequest) -&gt; None:\n    \"\"\"\n    Handle an order modification request.\n\n    Parameters:\n        event:\n            Order modification request event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/base/#onesecondtrader.brokers.base.BrokerBase._respond","title":"<code>_respond(response_event)</code>","text":"<p>Publish a response event to the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>response_event</code> <code>ResponseBase</code> <p>Response event generated by the broker.</p> required Source code in <code>src/onesecondtrader/brokers/base.py</code> <pre><code>def _respond(self, response_event: events.responses.ResponseBase) -&gt; None:\n    \"\"\"\n    Publish a response event to the event bus.\n\n    Parameters:\n        response_event:\n            Response event generated by the broker.\n    \"\"\"\n    self._publish(response_event)\n</code></pre>"},{"location":"reference/brokers/simulated/","title":"Simulated","text":""},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated._PendingOrder","title":"<code>_PendingOrder</code>  <code>dataclass</code>","text":"<p>Internal order state tracked by the simulated broker.</p> <p>This structure represents broker-side pending order state and is distinct from order request events. It is used to evaluate trigger conditions against incoming market bars and to generate fills when conditions are met.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>@dataclasses.dataclass\nclass _PendingOrder:\n    \"\"\"\n    Internal order state tracked by the simulated broker.\n\n    This structure represents broker-side pending order state and is distinct from order request events.\n    It is used to evaluate trigger conditions against incoming market bars and to generate fills when conditions are met.\n    \"\"\"\n\n    order_id: uuid.UUID\n    symbol: str\n    order_type: models.OrderType\n    side: models.TradeSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker","title":"<code>SimulatedBroker</code>","text":"<p>               Bases: <code>BrokerBase</code></p> <p>Event-driven simulated broker for backtesting.</p> <p>The broker subscribes to order request events and market bar events. Order requests are validated and accepted or rejected immediately. Accepted orders are stored as pending broker-side state and evaluated against each incoming bar. When an order triggers, a fill event is published with a deterministic fill price model based on the bar's OHLC values.</p> <p>The broker publishes response events using the event timestamp to preserve simulated time consistency.</p>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used to receive order requests and market bars, and to publish broker responses and fills.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    parameters:\n        event_bus:\n            Event bus used to receive order requests and market bars, and to publish broker responses and fills.\n    \"\"\"\n    self._pending_market_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n\n    super().__init__(event_bus)\n    self._subscribe(events.market.BarReceived)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker.connect","title":"<code>connect()</code>","text":"<p>Establish broker readiness.</p> <p>The simulated broker has no external connectivity requirements. This method is a no-op and exists to satisfy the broker interface.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"\n    Establish broker readiness.\n\n    The simulated broker has no external connectivity requirements.\n    This method is a no-op and exists to satisfy the broker interface.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_event","title":"<code>_on_event(event)</code>","text":"<p>Dispatch incoming events.</p> <p>Market bar events are routed to bar processing. All other events are delegated to the broker base class for order request handling.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Incoming event received from the event bus.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Dispatch incoming events.\n\n    Market bar events are routed to bar processing.\n    All other events are delegated to the broker base class for order request handling.\n\n    parameters:\n        event:\n            Incoming event received from the event bus.\n    \"\"\"\n    match event:\n        case events.market.BarReceived() as bar:\n            self._on_bar(bar)\n        case _:\n            super()._on_event(event)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_bar","title":"<code>_on_bar(event)</code>","text":"<p>Process an incoming market bar.</p> <p>Pending orders are evaluated against the bar in a fixed sequence to provide deterministic behavior. Crucially, limit orders are processed after stop limit orders to ensure that limit orders created by stop limit orders are evaluated against the same bar.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to trigger and price simulated fills.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_bar(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Process an incoming market bar.\n\n    Pending orders are evaluated against the bar in a fixed sequence to provide deterministic behavior.\n    Crucially, limit orders are processed after stop limit orders to ensure that limit orders created by stop limit orders are evaluated against the same bar.\n\n    parameters:\n        event:\n            Market bar used to trigger and price simulated fills.\n    \"\"\"\n    self._process_market_orders(event)\n    self._process_stop_orders(event)\n    self._process_stop_limit_orders(event)\n    self._process_limit_orders(event)\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_market_orders","title":"<code>_process_market_orders(event)</code>","text":"<p>Fill pending market orders for the bar symbol.</p> <p>Market orders are filled at the bar open price on the next received bar for the matching symbol.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar providing the simulated fill price and timestamps.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_market_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Fill pending market orders for the bar symbol.\n\n    Market orders are filled at the bar open price on the next received bar for the matching symbol.\n\n    parameters:\n        event:\n            Market bar providing the simulated fill price and timestamps.\n    \"\"\"\n    for order_id, order in list(self._pending_market_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=event.open,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_market_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_stop_orders","title":"<code>_process_stop_orders(event)</code>","text":"<p>Evaluate and fill pending stop orders for the bar symbol.</p> <p>Stop orders trigger when the bar crosses the stop level. The fill price is modeled as the worse of the stop price and the bar open in the direction of the trade.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate triggers and determine fill prices.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_stop_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate and fill pending stop orders for the bar symbol.\n\n    Stop orders trigger when the bar crosses the stop level.\n    The fill price is modeled as the worse of the stop price and the bar open in the direction of the trade.\n\n    parameters:\n        event:\n            Market bar used to evaluate triggers and determine fill prices.\n    \"\"\"\n    for order_id, order in list(self._pending_stop_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        # This is for mypy, it has already been validated on submission\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.TradeSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.TradeSide.BUY:\n                fill_price = max(order.stop_price, event.open)\n            case models.TradeSide.SELL:\n                fill_price = min(order.stop_price, event.open)\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_stop_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_stop_limit_orders","title":"<code>_process_stop_limit_orders(event)</code>","text":"<p>Evaluate pending stop-limit orders for the bar symbol.</p> <p>Stop-limit orders trigger on stop conditions. When triggered, they are converted into pending limit orders at the same identifier.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate stop triggers.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_stop_limit_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate pending stop-limit orders for the bar symbol.\n\n    Stop-limit orders trigger on stop conditions.\n    When triggered, they are converted into pending limit orders at the same identifier.\n\n    parameters:\n        event:\n            Market bar used to evaluate stop triggers.\n    \"\"\"\n    for order_id, order in list(self._pending_stop_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.TradeSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        limit_order = dataclasses.replace(order, order_type=models.OrderType.LIMIT)\n        self._pending_limit_orders[order_id] = limit_order\n        del self._pending_stop_limit_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._process_limit_orders","title":"<code>_process_limit_orders(event)</code>","text":"<p>Evaluate and fill pending limit orders for the bar symbol.</p> <p>Limit orders trigger when the bar crosses the limit level. The fill price is modeled as the better of the limit price and the bar open in the direction of the trade.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Market bar used to evaluate triggers and determine fill prices.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _process_limit_orders(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Evaluate and fill pending limit orders for the bar symbol.\n\n    Limit orders trigger when the bar crosses the limit level.\n    The fill price is modeled as the better of the limit price and the bar open in the direction of the trade.\n\n    parameters:\n        event:\n            Market bar used to evaluate triggers and determine fill prices.\n    \"\"\"\n    for order_id, order in list(self._pending_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        assert order.limit_price is not None\n\n        triggered = False\n        match order.side:\n            case models.TradeSide.BUY:\n                triggered = event.low &lt;= order.limit_price\n            case models.TradeSide.SELL:\n                triggered = event.high &gt;= order.limit_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.TradeSide.BUY:\n                fill_price = min(order.limit_price, event.open)\n            case models.TradeSide.SELL:\n                fill_price = max(order.limit_price, event.open)\n\n        self._publish(\n            events.orders.FillEvent(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_limit_orders[order_id]\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._reject_if_invalid_submission","title":"<code>_reject_if_invalid_submission(event)</code>","text":"<p>Validate an order submission request.</p> <p>Invalid submissions are rejected immediately by publishing an <code>OrderRejected</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the submission is invalid and was rejected, otherwise False.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_submission(\n    self, event: events.requests.OrderSubmissionRequest\n) -&gt; bool:\n    \"\"\"\n    Validate an order submission request.\n\n    Invalid submissions are rejected immediately by publishing an `OrderRejected` response event.\n\n    parameters:\n        event:\n            Order submission request event to validate.\n\n    returns:\n        True if the submission is invalid and was rejected, otherwise False.\n    \"\"\"\n    is_invalid = event.quantity &lt;= 0\n\n    match event.order_type:\n        case models.OrderType.LIMIT:\n            is_invalid = (\n                is_invalid or event.limit_price is None or event.limit_price &lt;= 0\n            )\n        case models.OrderType.STOP:\n            is_invalid = (\n                is_invalid or event.stop_price is None or event.stop_price &lt;= 0\n            )\n        case models.OrderType.STOP_LIMIT:\n            is_invalid = is_invalid or (\n                event.limit_price is None\n                or event.limit_price &lt;= 0\n                or event.stop_price is None\n                or event.stop_price &lt;= 0\n            )\n\n    if is_invalid:\n        self._publish(\n            events.responses.OrderRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=event.system_order_id,\n                rejection_reason=models.OrderRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_submit_order","title":"<code>_on_submit_order(event)</code>","text":"<p>Handle an order submission request.</p> <p>Valid orders are stored as pending broker-side state and acknowledged via an <code>OrderAccepted</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_submit_order(self, event: events.requests.OrderSubmissionRequest) -&gt; None:\n    \"\"\"\n    Handle an order submission request.\n\n    Valid orders are stored as pending broker-side state and acknowledged via an `OrderAccepted` response event.\n\n    parameters:\n        event:\n            Order submission request event.\n    \"\"\"\n    if self._reject_if_invalid_submission(event):\n        return\n\n    order = _PendingOrder(\n        order_id=event.system_order_id,\n        symbol=event.symbol,\n        order_type=event.order_type,\n        side=event.side,\n        quantity=event.quantity,\n        limit_price=event.limit_price,\n        stop_price=event.stop_price,\n    )\n\n    match order.order_type:\n        case models.OrderType.MARKET:\n            self._pending_market_orders[order.order_id] = order\n        case models.OrderType.LIMIT:\n            self._pending_limit_orders[order.order_id] = order\n        case models.OrderType.STOP:\n            self._pending_stop_orders[order.order_id] = order\n        case models.OrderType.STOP_LIMIT:\n            self._pending_stop_limit_orders[order.order_id] = order\n\n    self._publish(\n        events.responses.OrderAccepted(\n            ts_event_ns=event.ts_event_ns,\n            ts_broker_ns=event.ts_event_ns,\n            associated_order_id=order.order_id,\n        )\n    )\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_cancel_order","title":"<code>_on_cancel_order(event)</code>","text":"<p>Handle an order cancellation request.</p> <p>If the referenced order is pending, it is removed and acknowledged via <code>CancellationAccepted</code>. Otherwise, <code>CancellationRejected</code> is published.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderCancellationRequest</code> <p>Order cancellation request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_cancel_order(self, event: events.requests.OrderCancellationRequest) -&gt; None:\n    \"\"\"\n    Handle an order cancellation request.\n\n    If the referenced order is pending, it is removed and acknowledged via `CancellationAccepted`.\n    Otherwise, `CancellationRejected` is published.\n\n    parameters:\n        event:\n            Order cancellation request event.\n    \"\"\"\n    order_id = event.system_order_id\n\n    removed = False\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            del pending_orders[order_id]\n            removed = True\n            break\n\n    if removed:\n        self._publish(\n            events.responses.CancellationAccepted(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order_id,\n            )\n        )\n    else:\n        self._publish(\n            events.responses.CancellationRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=order_id,\n                rejection_reason=models.CancellationRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._reject_if_invalid_modification","title":"<code>_reject_if_invalid_modification(event)</code>","text":"<p>Validate an order modification request.</p> <p>Invalid modifications are rejected immediately by publishing a <code>ModificationRejected</code> response event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the modification is invalid and was rejected, otherwise False.</p> Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_modification(\n    self, event: events.requests.OrderModificationRequest\n) -&gt; bool:\n    \"\"\"\n    Validate an order modification request.\n\n    Invalid modifications are rejected immediately by publishing a `ModificationRejected` response event.\n\n    parameters:\n        event:\n            Order modification request event to validate.\n\n    returns:\n        True if the modification is invalid and was rejected, otherwise False.\n    \"\"\"\n    is_invalid = (\n        (event.quantity is not None and event.quantity &lt;= 0)\n        or (event.limit_price is not None and event.limit_price &lt;= 0)\n        or (event.stop_price is not None and event.stop_price &lt;= 0)\n    )\n\n    if is_invalid:\n        self._publish(\n            events.responses.ModificationRejected(\n                ts_event_ns=event.ts_event_ns,\n                ts_broker_ns=event.ts_event_ns,\n                associated_order_id=event.system_order_id,\n                rejection_reason=models.ModificationRejectionReason.UNKNOWN,\n                rejection_message=\"Unknown\",\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"reference/brokers/simulated/#onesecondtrader.brokers.simulated.SimulatedBroker._on_modify_order","title":"<code>_on_modify_order(event)</code>","text":"<p>Handle an order modification request.</p> <p>If the referenced order is pending, its fields are updated and acknowledged via <code>ModificationAccepted</code>. Otherwise, <code>ModificationRejected</code> is published.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request event.</p> required Source code in <code>src/onesecondtrader/brokers/simulated.py</code> <pre><code>def _on_modify_order(self, event: events.requests.OrderModificationRequest) -&gt; None:\n    \"\"\"\n    Handle an order modification request.\n\n    If the referenced order is pending, its fields are updated and acknowledged via `ModificationAccepted`.\n    Otherwise, `ModificationRejected` is published.\n\n    parameters:\n        event:\n            Order modification request event.\n    \"\"\"\n    if self._reject_if_invalid_modification(event):\n        return\n\n    order_id = event.system_order_id\n\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            order = pending_orders[order_id]\n\n            new_quantity = (\n                event.quantity if event.quantity is not None else order.quantity\n            )\n            new_limit_price = (\n                event.limit_price\n                if event.limit_price is not None\n                else order.limit_price\n            )\n            new_stop_price = (\n                event.stop_price\n                if event.stop_price is not None\n                else order.stop_price\n            )\n\n            pending_orders[order_id] = dataclasses.replace(\n                order,\n                quantity=new_quantity,\n                limit_price=new_limit_price,\n                stop_price=new_stop_price,\n            )\n\n            self._publish(\n                events.responses.ModificationAccepted(\n                    ts_event_ns=event.ts_event_ns,\n                    ts_broker_ns=event.ts_event_ns,\n                    associated_order_id=order_id,\n                )\n            )\n            return\n\n    self._publish(\n        events.responses.ModificationRejected(\n            ts_event_ns=event.ts_event_ns,\n            ts_broker_ns=event.ts_event_ns,\n            associated_order_id=order_id,\n            rejection_reason=models.ModificationRejectionReason.UNKNOWN,\n            rejection_message=\"Unknown\",\n        )\n    )\n</code></pre>"},{"location":"reference/dashboard/app/","title":"App","text":""},{"location":"reference/dashboard/app/#onesecondtrader.dashboard.app.app","title":"<code>app = FastAPI(title='OneSecondTrader Dashboard')</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/app/#onesecondtrader.dashboard.app.index","title":"<code>index()</code>  <code>async</code>","text":"Source code in <code>src/onesecondtrader/dashboard/app.py</code> <pre><code>@app.get(\"/\", response_class=RedirectResponse)\nasync def index():\n    return RedirectResponse(url=\"/backtest\", status_code=302)\n</code></pre>"},{"location":"reference/dashboard/app/#onesecondtrader.dashboard.app.backtest","title":"<code>backtest()</code>  <code>async</code>","text":"Source code in <code>src/onesecondtrader/dashboard/app.py</code> <pre><code>@app.get(\"/backtest\", response_class=HTMLResponse)\nasync def backtest():\n    return backtest_page()\n</code></pre>"},{"location":"reference/dashboard/app/#onesecondtrader.dashboard.app.performance","title":"<code>performance()</code>  <code>async</code>","text":"Source code in <code>src/onesecondtrader/dashboard/app.py</code> <pre><code>@app.get(\"/performance\", response_class=HTMLResponse)\nasync def performance():\n    return performance_page()\n</code></pre>"},{"location":"reference/dashboard/app/#onesecondtrader.dashboard.app.health","title":"<code>health()</code>  <code>async</code>","text":"Source code in <code>src/onesecondtrader/dashboard/app.py</code> <pre><code>@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/dashboard/backtest/","title":"Backtest","text":"<p>Backtest execution logic for the dashboard.</p> <p>Provides the request model, job tracking, and execution function for running backtests from the dashboard UI.</p>"},{"location":"reference/dashboard/backtest/#onesecondtrader.dashboard.backtest.running_jobs","title":"<code>running_jobs = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/backtest/#onesecondtrader.dashboard.backtest.RTYPE_TO_BAR_PERIOD","title":"<code>RTYPE_TO_BAR_PERIOD = {32: 'SECOND', 33: 'MINUTE', 34: 'HOUR', 35: 'DAY'}</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/backtest/#onesecondtrader.dashboard.backtest.BacktestRequest","title":"<code>BacktestRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for backtest execution.</p> <p>Attributes:</p> Name Type Description <code>strategy</code> <code>str</code> <p>Name of the strategy class to run.</p> <code>strategy_params</code> <code>dict</code> <p>Dictionary of parameter overrides for the strategy.</p> <code>symbols</code> <code>list[str]</code> <p>List of instrument symbols to trade.</p> <code>rtype</code> <code>int</code> <p>Bar period rtype code (32=second, 33=minute, 34=hour, 35=day).</p> <code>publisher_id</code> <code>int</code> <p>Publisher ID for data source selection.</p> <code>start_date</code> <code>str | None</code> <p>Optional start date in YYYY-MM-DD format.</p> <code>end_date</code> <code>str | None</code> <p>Optional end date in YYYY-MM-DD format.</p> Source code in <code>src/onesecondtrader/dashboard/backtest.py</code> <pre><code>class BacktestRequest(BaseModel):\n    \"\"\"\n    Request model for backtest execution.\n\n    Attributes:\n        strategy:\n            Name of the strategy class to run.\n        strategy_params:\n            Dictionary of parameter overrides for the strategy.\n        symbols:\n            List of instrument symbols to trade.\n        rtype:\n            Bar period rtype code (32=second, 33=minute, 34=hour, 35=day).\n        publisher_id:\n            Publisher ID for data source selection.\n        start_date:\n            Optional start date in YYYY-MM-DD format.\n        end_date:\n            Optional end date in YYYY-MM-DD format.\n    \"\"\"\n\n    strategy: str\n    strategy_params: dict\n    symbols: list[str]\n    rtype: int\n    publisher_id: int\n    start_date: str | None = None\n    end_date: str | None = None\n</code></pre>"},{"location":"reference/dashboard/backtest/#onesecondtrader.dashboard.backtest.deserialize_params","title":"<code>deserialize_params(params, param_specs)</code>","text":"<p>Deserialize strategy parameters, converting enum strings to enum values.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>Dictionary of parameter names to values from the request.</p> required <code>param_specs</code> <code>dict</code> <p>Dictionary of parameter names to ParamSpec instances.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with enum strings converted to their enum values.</p> Source code in <code>src/onesecondtrader/dashboard/backtest.py</code> <pre><code>def deserialize_params(params: dict, param_specs: dict) -&gt; dict:\n    \"\"\"\n    Deserialize strategy parameters, converting enum strings to enum values.\n\n    Parameters:\n        params:\n            Dictionary of parameter names to values from the request.\n        param_specs:\n            Dictionary of parameter names to ParamSpec instances.\n\n    Returns:\n        Dictionary with enum strings converted to their enum values.\n    \"\"\"\n    result = {}\n    for name, value in params.items():\n        spec = param_specs.get(name)\n        if spec is None:\n            result[name] = value\n            continue\n        if isinstance(spec.default, enum.Enum):\n            enum_cls = type(spec.default)\n            result[name] = enum_cls[value]\n        else:\n            result[name] = value\n    return result\n</code></pre>"},{"location":"reference/dashboard/backtest/#onesecondtrader.dashboard.backtest.run_backtest","title":"<code>run_backtest(request, run_id)</code>","text":"<p>Execute a backtest in a background task.</p> <p>Configures and runs an Orchestrator with the specified strategy, symbols, and data source. Updates running_jobs with status during execution.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>BacktestRequest</code> <p>Backtest configuration from the API request.</p> required <code>run_id</code> <code>str</code> <p>Unique identifier for tracking this backtest job.</p> required Source code in <code>src/onesecondtrader/dashboard/backtest.py</code> <pre><code>def run_backtest(request: BacktestRequest, run_id: str) -&gt; None:\n    \"\"\"\n    Execute a backtest in a background task.\n\n    Configures and runs an Orchestrator with the specified strategy, symbols,\n    and data source. Updates running_jobs with status during execution.\n\n    Parameters:\n        request:\n            Backtest configuration from the API request.\n        run_id:\n            Unique identifier for tracking this backtest job.\n    \"\"\"\n    from onesecondtrader.brokers.simulated import SimulatedBroker\n    from onesecondtrader.datafeeds.simulated import SimulatedDatafeed\n    from onesecondtrader.models import BarPeriod\n    from onesecondtrader.orchestrator import Orchestrator\n    from onesecondtrader.strategies import examples  # noqa: F401\n    from onesecondtrader.strategies.base import ParamSpec\n\n    try:\n        running_jobs[run_id] = \"running\"\n\n        strategy_cls = registry.get_strategies().get(request.strategy)\n        if not strategy_cls:\n            running_jobs[run_id] = \"error: invalid strategy\"\n            return\n\n        bar_period = BarPeriod[RTYPE_TO_BAR_PERIOD[request.rtype]]\n\n        deserialized_params = deserialize_params(\n            request.strategy_params, getattr(strategy_cls, \"parameters\", {})\n        )\n\n        updated_parameters = {}\n        for name, spec in strategy_cls.parameters.items():\n            if name == \"bar_period\":\n                updated_parameters[name] = ParamSpec(default=bar_period)\n            elif name in deserialized_params:\n                updated_parameters[name] = type(spec)(\n                    default=deserialized_params[name],\n                    **{k: v for k, v in spec.__dict__.items() if k != \"default\"},\n                )\n            else:\n                updated_parameters[name] = spec\n\n        configured_strategy = type(\n            f\"Configured{request.strategy}\",\n            (strategy_cls,),\n            {\"symbols\": request.symbols, \"parameters\": updated_parameters},\n        )\n\n        db_path = get_secmaster_path()\n        conn = sqlite3.connect(db_path)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT name, dataset FROM publishers WHERE publisher_id = ?\",\n            (request.publisher_id,),\n        )\n        row = cursor.fetchone()\n        conn.close()\n        if not row:\n            running_jobs[run_id] = (\n                f\"error: publisher_id {request.publisher_id} not found\"\n            )\n            return\n        publisher_name, dataset = row\n\n        datafeed_attrs: dict[str, str | int] = {\n            \"publisher_name\": publisher_name,\n            \"dataset\": dataset,\n            \"symbol_type\": \"raw_symbol\",\n            \"db_path\": db_path,\n        }\n        if request.start_date:\n            datafeed_attrs[\"start_ts\"] = int(\n                pd.Timestamp(request.start_date, tz=\"UTC\").value\n            )\n        if request.end_date:\n            end_dt = (\n                pd.Timestamp(request.end_date, tz=\"UTC\")\n                + pd.Timedelta(days=1)\n                - pd.Timedelta(1, unit=\"ns\")\n            )\n            datafeed_attrs[\"end_ts\"] = int(end_dt.value)\n\n        configured_datafeed = type(\n            \"ConfiguredDatafeed\", (SimulatedDatafeed,), datafeed_attrs\n        )\n\n        class ConfiguredOrchestrator(Orchestrator):\n            db_path = get_runs_db_path()\n            mode = \"backtest\"\n            start_date = request.start_date\n            end_date = request.end_date\n\n        orchestrator = ConfiguredOrchestrator(\n            strategies=[configured_strategy],\n            broker=SimulatedBroker,\n            datafeed=configured_datafeed,\n        )\n        orchestrator.run()\n        running_jobs[run_id] = \"completed\"\n    except Exception as e:\n        running_jobs[run_id] = f\"error: {e}\"\n</code></pre>"},{"location":"reference/dashboard/charting/","title":"Charting","text":"<p>Chart image generation for round-trip trade visualization.</p> <p>Generates PNG images showing price action, fills, P&amp;L watermarks, and indicators for individual round-trip trades.</p>"},{"location":"reference/dashboard/charting/#onesecondtrader.dashboard.charting.generate_chart_image","title":"<code>generate_chart_image(run_id, symbol, start_ns, end_ns, direction, pnl)</code>","text":"<p>Generate a PNG chart image for a round-trip trade.</p> <p>Renders a multi-panel chart showing: - P&amp;L panel with unrealized P&amp;L range and high/low watermarks - Price panel with OHLC bars, overlay indicators, and fill markers - Additional panels for non-overlay indicators grouped by tag</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>str</code> <p>Unique identifier of the backtest run.</p> required <code>symbol</code> <code>str</code> <p>Instrument symbol for the trade.</p> required <code>start_ns</code> <code>int</code> <p>Entry timestamp in nanoseconds.</p> required <code>end_ns</code> <code>int</code> <p>Exit timestamp in nanoseconds.</p> required <code>direction</code> <code>str</code> <p>Trade direction, either \"LONG\" or \"SHORT\".</p> required <code>pnl</code> <code>float</code> <p>Net profit/loss for the trade.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>PNG image bytes, or empty bytes if no data is available.</p> Source code in <code>src/onesecondtrader/dashboard/charting.py</code> <pre><code>def generate_chart_image(\n    run_id: str,\n    symbol: str,\n    start_ns: int,\n    end_ns: int,\n    direction: str,\n    pnl: float,\n) -&gt; bytes:\n    \"\"\"\n    Generate a PNG chart image for a round-trip trade.\n\n    Renders a multi-panel chart showing:\n    - P&amp;L panel with unrealized P&amp;L range and high/low watermarks\n    - Price panel with OHLC bars, overlay indicators, and fill markers\n    - Additional panels for non-overlay indicators grouped by tag\n\n    Parameters:\n        run_id:\n            Unique identifier of the backtest run.\n        symbol:\n            Instrument symbol for the trade.\n        start_ns:\n            Entry timestamp in nanoseconds.\n        end_ns:\n            Exit timestamp in nanoseconds.\n        direction:\n            Trade direction, either \"LONG\" or \"SHORT\".\n        pnl:\n            Net profit/loss for the trade.\n\n    Returns:\n        PNG image bytes, or empty bytes if no data is available.\n    \"\"\"\n    db_path = get_runs_db_path()\n    if not os.path.exists(db_path):\n        return b\"\"\n\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n\n    padding_bars = 100\n\n    cursor.execute(\n        \"\"\"\n        SELECT ts_event_ns, open, high, low, close, bar_period, indicators\n        FROM bars_processed\n        WHERE run_id = ? AND symbol = ? AND ts_event_ns &lt; ?\n        ORDER BY ts_event_ns DESC\n        LIMIT ?\n        \"\"\",\n        (run_id, symbol, start_ns, padding_bars),\n    )\n    before_rows = cursor.fetchall()[::-1]\n\n    cursor.execute(\n        \"\"\"\n        SELECT ts_event_ns, open, high, low, close, bar_period, indicators\n        FROM bars_processed\n        WHERE run_id = ? AND symbol = ? AND ts_event_ns &gt;= ? AND ts_event_ns &lt;= ?\n        ORDER BY ts_event_ns\n        \"\"\",\n        (run_id, symbol, start_ns, end_ns),\n    )\n    trade_rows = cursor.fetchall()\n\n    cursor.execute(\n        \"\"\"\n        SELECT ts_event_ns, open, high, low, close, bar_period, indicators\n        FROM bars_processed\n        WHERE run_id = ? AND symbol = ? AND ts_event_ns &gt; ?\n        ORDER BY ts_event_ns\n        LIMIT ?\n        \"\"\",\n        (run_id, symbol, end_ns, padding_bars),\n    )\n    after_rows = cursor.fetchall()\n\n    bar_rows = before_rows + trade_rows + after_rows\n    bar_period = bar_rows[0][5] if bar_rows else \"DAY\"\n\n    cursor.execute(\n        \"\"\"\n        SELECT ts_broker_ns, side, quantity_filled, fill_price\n        FROM fills\n        WHERE run_id = ? AND symbol = ? AND ts_broker_ns &gt;= ? AND ts_broker_ns &lt;= ?\n        ORDER BY ts_broker_ns\n        \"\"\",\n        (run_id, symbol, start_ns, end_ns),\n    )\n    fill_rows = cursor.fetchall()\n    conn.close()\n\n    if not bar_rows:\n        return b\"\"\n\n    data = pd.DataFrame(\n        bar_rows,\n        columns=[\n            \"ts_event\",\n            \"open\",\n            \"high\",\n            \"low\",\n            \"close\",\n            \"bar_period\",\n            \"indicators\",\n        ],\n    )\n    data[\"ts_event\"] = pd.to_datetime(data[\"ts_event\"], unit=\"ns\")\n\n    indicator_series: dict[str, list[float]] = {}\n    indicator_tags: dict[str, int] = {}\n    indicator_styles: dict[str, str] = {}\n    for idx in range(len(data)):\n        row = data.iloc[idx]\n        indicators = json.loads(row[\"indicators\"]) if row[\"indicators\"] else {}\n        for name, value in indicators.items():\n            if name not in indicator_series:\n                indicator_series[name] = [math.nan] * len(data)\n                tag = int(name[:2]) if name[:2].isdigit() else 99\n                indicator_tags[name] = tag\n                style = name[2] if len(name) &gt; 2 and name[2] in \"LHD\" else \"L\"\n                indicator_styles[name] = style\n            indicator_series[name][idx] = value if value == value else math.nan\n\n    overlay_indicators = {\n        k: v for k, v in indicator_series.items() if indicator_tags.get(k, 99) == 0\n    }\n    subplot_tags = sorted(set(t for t in indicator_tags.values() if 1 &lt;= t &lt;= 98))\n    subplot_indicators = {\n        tag: {k: v for k, v in indicator_series.items() if indicator_tags.get(k) == tag}\n        for tag in subplot_tags\n    }\n\n    entry_time = pd.to_datetime(start_ns, unit=\"ns\")\n    exit_time = pd.to_datetime(end_ns, unit=\"ns\")\n\n    fills = []\n    for row in fill_rows:\n        fills.append(\n            {\n                \"ts_event\": pd.to_datetime(row[0], unit=\"ns\"),\n                \"side\": row[1],\n                \"quantity\": row[2],\n                \"price\": row[3],\n            }\n        )\n\n    highlight_start = (\n        data[data[\"ts_event\"] &gt;= entry_time].index[0]\n        if len(data[data[\"ts_event\"] &gt;= entry_time]) &gt; 0\n        else 0\n    )\n    highlight_end = (\n        data[data[\"ts_event\"] &lt;= exit_time].index[-1]\n        if len(data[data[\"ts_event\"] &lt;= exit_time]) &gt; 0\n        else len(data) - 1\n    )\n\n    num_subplots = 2 + len(subplot_tags)\n    height_ratios = [1, 3] + [1] * len(subplot_tags)\n    fig_height = 8 + 2 * len(subplot_tags)\n    fig, axes = plt.subplots(\n        num_subplots,\n        1,\n        figsize=(14, fig_height),\n        sharex=True,\n        gridspec_kw={\"height_ratios\": height_ratios},\n    )\n    if num_subplots == 2:\n        axes = [axes[0], axes[1]]\n    ax_pnl = axes[0]\n    ax_main = axes[1]\n    ax_indicators = list(axes[2:]) if len(axes) &gt; 2 else []\n\n    entry_price = fills[0][\"price\"] if fills else 0\n    fill_direction = fills[0][\"side\"] if fills else \"BUY\"\n\n    pos_indices = []\n    pnl_high_series = []\n    pnl_low_series = []\n    hwm_series = []\n    low_watermark_series = []\n    running_hwm = 0\n    running_lwm = 0\n\n    for i in range(len(data)):\n        ts = data[\"ts_event\"].iloc[i]\n        bar_high = data[\"high\"].iloc[i]\n        bar_low = data[\"low\"].iloc[i]\n        if ts &gt;= entry_time and ts &lt;= exit_time:\n            if fill_direction == \"BUY\":\n                pnl_at_high = bar_high - entry_price\n                pnl_at_low = bar_low - entry_price\n            else:\n                pnl_at_high = entry_price - bar_low\n                pnl_at_low = entry_price - bar_high\n            running_hwm = max(running_hwm, pnl_at_high)\n            running_lwm = min(running_lwm, pnl_at_low)\n            pos_indices.append(i)\n            pnl_high_series.append(pnl_at_high)\n            pnl_low_series.append(pnl_at_low)\n            hwm_series.append(running_hwm)\n            low_watermark_series.append(running_lwm)\n\n    if pos_indices:\n        ax_pnl.fill_between(\n            pos_indices,\n            pnl_low_series,\n            pnl_high_series,\n            color=\"blue\",\n            alpha=0.3,\n            label=\"Unrealized P&amp;L\",\n        )\n        ax_pnl.plot(\n            pos_indices,\n            hwm_series,\n            color=\"green\",\n            linewidth=1.5,\n            label=\"High Watermark\",\n            alpha=0.8,\n        )\n        ax_pnl.plot(\n            pos_indices,\n            low_watermark_series,\n            color=\"red\",\n            linewidth=1.5,\n            label=\"Low Watermark\",\n            alpha=0.8,\n        )\n    ax_pnl.axhline(y=0, color=\"black\", linestyle=\"-\", alpha=0.5, linewidth=0.8)\n    ax_pnl.set_ylabel(\"P&amp;L\", fontsize=10)\n    ax_pnl.grid(True, alpha=0.3)\n    ax_pnl.legend(loc=\"upper left\", fontsize=8)\n\n    for i in range(len(data)):\n        ax_main.plot(\n            [i, i],\n            [data[\"low\"].iloc[i], data[\"high\"].iloc[i]],\n            color=\"black\",\n            linewidth=0.8,\n            alpha=0.7,\n        )\n        ax_main.plot(\n            [i], [data[\"close\"].iloc[i]], marker=\"_\", color=\"blue\", markersize=3\n        )\n\n    colors = [\"orange\", \"purple\", \"cyan\", \"magenta\", \"brown\", \"pink\", \"olive\", \"teal\"]\n    for idx, (name, values) in enumerate(overlay_indicators.items()):\n        display_name = name[4:] if len(name) &gt; 4 else name\n        color = colors[idx % len(colors)]\n        style = indicator_styles.get(name, \"L\")\n        if style == \"H\":\n            ax_main.bar(\n                range(len(values)),\n                values,\n                label=display_name,\n                alpha=0.6,\n                color=color,\n                width=0.8,\n            )\n        elif style == \"D\":\n            ax_main.scatter(\n                range(len(values)),\n                values,\n                label=display_name,\n                alpha=0.8,\n                color=color,\n                s=10,\n            )\n        else:\n            ax_main.plot(\n                range(len(values)),\n                values,\n                label=display_name,\n                linewidth=1.2,\n                alpha=0.8,\n                color=color,\n            )\n    if overlay_indicators:\n        ax_main.legend(loc=\"upper left\", fontsize=8)\n\n    for ax_idx, tag in enumerate(subplot_tags):\n        ax = ax_indicators[ax_idx]\n        tag_indicators = subplot_indicators[tag]\n        for idx, (name, values) in enumerate(tag_indicators.items()):\n            display_name = name[4:] if len(name) &gt; 4 else name\n            color = colors[idx % len(colors)]\n            style = indicator_styles.get(name, \"L\")\n            if style == \"H\":\n                ax.bar(\n                    range(len(values)),\n                    values,\n                    label=display_name,\n                    alpha=0.6,\n                    color=color,\n                    width=0.8,\n                )\n            elif style == \"D\":\n                ax.scatter(\n                    range(len(values)),\n                    values,\n                    label=display_name,\n                    alpha=0.8,\n                    color=color,\n                    s=10,\n                )\n            else:\n                ax.plot(\n                    range(len(values)),\n                    values,\n                    label=display_name,\n                    linewidth=1.2,\n                    alpha=0.8,\n                    color=color,\n                )\n        ax.set_ylabel(f\"Tag {tag}\", fontsize=10)\n        ax.grid(True, alpha=0.3)\n        ax.legend(loc=\"upper left\", fontsize=8)\n\n    all_axes = [ax_pnl, ax_main] + ax_indicators\n    if 0 &lt;= highlight_start &lt; len(data) and 0 &lt;= highlight_end &lt; len(data):\n        for ax in all_axes:\n            y_min, y_max = ax.get_ylim()\n            rect = Rectangle(\n                (highlight_start, y_min),\n                highlight_end - highlight_start,\n                y_max - y_min,\n                facecolor=\"lightblue\",\n                alpha=0.2,\n            )\n            ax.add_patch(rect)\n\n    ax_main.set_ylabel(\"Price\", fontsize=10)\n    ax_main.grid(True, alpha=0.3)\n\n    ts_to_idx = {ts: i for i, ts in enumerate(data[\"ts_event\"])}\n    for fill in fills:\n        fill_idx = ts_to_idx.get(fill[\"ts_event\"])\n        if fill_idx is None:\n            closest_idx = (data[\"ts_event\"] - fill[\"ts_event\"]).abs().argmin()\n            fill_idx = closest_idx\n        marker = \"^\" if fill[\"side\"] == \"BUY\" else \"v\"\n        color = \"green\" if fill[\"side\"] == \"BUY\" else \"red\"\n        qty = fill.get(\"quantity\", 1)\n        size = 120 * min(3.0, max(0.5, qty))\n        ax_main.scatter(\n            fill_idx,\n            fill[\"price\"],\n            marker=marker,\n            color=color,\n            s=size,\n            edgecolors=\"black\",\n            linewidth=1,\n            zorder=5,\n            alpha=0.8,\n        )\n        y_lim = ax_main.get_ylim()\n        offset_y = (y_lim[1] - y_lim[0]) * 0.02\n        ax_main.annotate(\n            f\"{qty}\",\n            (fill_idx, fill[\"price\"] + offset_y),\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=8,\n            fontweight=\"bold\",\n            bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"white\", alpha=0.7),\n        )\n\n    label = \"WIN\" if pnl &gt; 0 else \"LOSS\" if pnl &lt; 0 else \"BREAK-EVEN\"\n    duration_secs = (exit_time - entry_time).total_seconds()\n    if bar_period == \"SECOND\":\n        duration_str = f\"{duration_secs:.0f}s\"\n    elif bar_period == \"MINUTE\":\n        duration_str = f\"{duration_secs / 60:.0f}min\"\n    elif bar_period == \"HOUR\":\n        duration_str = f\"{duration_secs / 3600:.0f}h\"\n    else:\n        duration_str = f\"{duration_secs / 86400:.0f}d\"\n    ax_pnl.set_title(\n        f\"{symbol} - {direction} - {label} - P&amp;L: ${pnl:.2f} - Duration: {duration_str}\",\n        fontsize=14,\n    )\n\n    num_bars = len(data)\n    tick_interval = max(1, num_bars // 10)\n    tick_positions = list(range(0, num_bars, tick_interval))\n    tick_labels = [data[\"ts_event\"].iloc[i].strftime(\"%m/%d\") for i in tick_positions]\n    for ax in all_axes:\n        ax.set_xticks(tick_positions)\n        ax.set_xticklabels(tick_labels)\n\n    plt.xticks(rotation=45, fontsize=9)\n    plt.tight_layout()\n\n    buf = io.BytesIO()\n    plt.savefig(buf, format=\"png\", dpi=500, bbox_inches=\"tight\")\n    plt.close(fig)\n    buf.seek(0)\n\n    return buf.read()\n</code></pre>"},{"location":"reference/dashboard/charting/#onesecondtrader.dashboard.charting._compute_trade_journey_data","title":"<code>_compute_trade_journey_data(run_id, roundtrips)</code>","text":"<p>Compute max positive/negative price movements for each round-trip trade.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>str</code> <p>Unique identifier of the backtest run.</p> required <code>roundtrips</code> <code>list[dict]</code> <p>List of round-trip trade dictionaries.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of dictionaries with max_positive_pts, max_negative_pts, exit_pts, is_winner, and duration_bars.</p> Source code in <code>src/onesecondtrader/dashboard/charting.py</code> <pre><code>def _compute_trade_journey_data(\n    run_id: str,\n    roundtrips: list[dict],\n) -&gt; list[dict]:\n    \"\"\"\n    Compute max positive/negative price movements for each round-trip trade.\n\n    Parameters:\n        run_id:\n            Unique identifier of the backtest run.\n        roundtrips:\n            List of round-trip trade dictionaries.\n\n    Returns:\n        List of dictionaries with max_positive_pts, max_negative_pts, exit_pts, is_winner, and duration_bars.\n    \"\"\"\n    db_path = get_runs_db_path()\n    if not os.path.exists(db_path):\n        return []\n\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n\n    journey_data = []\n    for rt in roundtrips:\n        symbol = rt[\"symbol\"]\n        direction = rt[\"direction\"]\n        entry_ts = rt[\"entry_ts\"]\n        exit_ts = rt[\"exit_ts\"]\n\n        cursor.execute(\n            \"\"\"\n            SELECT fill_price FROM fills\n            WHERE run_id = ? AND symbol = ? AND ts_broker_ns = ?\n            LIMIT 1\n            \"\"\",\n            (run_id, symbol, entry_ts),\n        )\n        entry_row = cursor.fetchone()\n        if not entry_row:\n            cursor.execute(\n                \"\"\"\n                SELECT fill_price FROM fills\n                WHERE run_id = ? AND symbol = ? AND ts_broker_ns &gt;= ?\n                ORDER BY ts_broker_ns LIMIT 1\n                \"\"\",\n                (run_id, symbol, entry_ts),\n            )\n            entry_row = cursor.fetchone()\n\n        cursor.execute(\n            \"\"\"\n            SELECT fill_price FROM fills\n            WHERE run_id = ? AND symbol = ? AND ts_broker_ns = ?\n            LIMIT 1\n            \"\"\",\n            (run_id, symbol, exit_ts),\n        )\n        exit_row = cursor.fetchone()\n        if not exit_row:\n            cursor.execute(\n                \"\"\"\n                SELECT fill_price FROM fills\n                WHERE run_id = ? AND symbol = ? AND ts_broker_ns &lt;= ?\n                ORDER BY ts_broker_ns DESC LIMIT 1\n                \"\"\",\n                (run_id, symbol, exit_ts),\n            )\n            exit_row = cursor.fetchone()\n\n        if not entry_row or not exit_row:\n            journey_data.append(\n                {\n                    \"max_positive_pts\": 0.0,\n                    \"max_negative_pts\": 0.0,\n                    \"exit_pts\": 0.0,\n                    \"is_winner\": rt[\"pnl_after_commission\"] &gt; 0,\n                    \"duration_bars\": rt.get(\"duration_bars\", 1),\n                }\n            )\n            continue\n\n        entry_price = entry_row[0]\n        exit_price = exit_row[0]\n\n        cursor.execute(\n            \"\"\"\n            SELECT high, low FROM bars\n            WHERE run_id = ? AND symbol = ? AND ts_event_ns &gt;= ? AND ts_event_ns &lt;= ?\n            ORDER BY ts_event_ns\n            \"\"\",\n            (run_id, symbol, entry_ts, exit_ts),\n        )\n        bars = cursor.fetchall()\n\n        max_positive_pts = 0.0\n        max_negative_pts = 0.0\n\n        for bar_high, bar_low in bars:\n            if direction == \"LONG\":\n                positive_move = bar_high - entry_price\n                negative_move = bar_low - entry_price\n            else:\n                positive_move = entry_price - bar_low\n                negative_move = entry_price - bar_high\n\n            max_positive_pts = max(max_positive_pts, positive_move)\n            max_negative_pts = min(max_negative_pts, negative_move)\n\n        if direction == \"LONG\":\n            exit_pts = exit_price - entry_price\n        else:\n            exit_pts = entry_price - exit_price\n\n        journey_data.append(\n            {\n                \"max_positive_pts\": max_positive_pts,\n                \"max_negative_pts\": max_negative_pts,\n                \"exit_pts\": exit_pts,\n                \"is_winner\": rt[\"pnl_after_commission\"] &gt; 0,\n                \"duration_bars\": rt.get(\"duration_bars\", 1),\n            }\n        )\n\n    conn.close()\n    return journey_data\n</code></pre>"},{"location":"reference/dashboard/charting/#onesecondtrader.dashboard.charting.generate_trade_journey_chart","title":"<code>generate_trade_journey_chart(run_id, roundtrips)</code>","text":"<p>Generate a Trade Journey chart showing max price movements and exit points.</p> <p>Renders a bar chart where each trade shows: - Vertical bar from 0 to max positive movement (green for wins, red for losses) - Vertical bar from 0 to max negative movement (same color) - Circle marker at exit point (dark green for wins, dark red for losses) - Horizontal lines for average winning and losing exit points</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>str</code> <p>Unique identifier of the backtest run.</p> required <code>roundtrips</code> <code>list[dict]</code> <p>List of round-trip trade dictionaries.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>PNG image bytes, or empty bytes if no data is available.</p> Source code in <code>src/onesecondtrader/dashboard/charting.py</code> <pre><code>def generate_trade_journey_chart(run_id: str, roundtrips: list[dict]) -&gt; bytes:\n    \"\"\"\n    Generate a Trade Journey chart showing max price movements and exit points.\n\n    Renders a bar chart where each trade shows:\n    - Vertical bar from 0 to max positive movement (green for wins, red for losses)\n    - Vertical bar from 0 to max negative movement (same color)\n    - Circle marker at exit point (dark green for wins, dark red for losses)\n    - Horizontal lines for average winning and losing exit points\n\n    Parameters:\n        run_id:\n            Unique identifier of the backtest run.\n        roundtrips:\n            List of round-trip trade dictionaries.\n\n    Returns:\n        PNG image bytes, or empty bytes if no data is available.\n    \"\"\"\n    if not roundtrips:\n        return b\"\"\n\n    journey_data = _compute_trade_journey_data(run_id, roundtrips)\n    if not journey_data:\n        return b\"\"\n\n    fig, ax = plt.subplots(figsize=(14, 7))\n\n    win_color = \"#3fb950\"\n    loss_color = \"#f85149\"\n    win_exit_color = \"#1a7f37\"\n    loss_exit_color = \"#a40e26\"\n\n    winning_exits = []\n    losing_exits = []\n    winning_bars = []\n    losing_bars = []\n\n    all_durations = [d[\"duration_bars\"] for d in journey_data]\n    max_duration = max(all_durations) if all_durations else 1\n    min_width = 0.2\n    max_width = 0.9\n\n    for i, data in enumerate(journey_data):\n        trade_num = i + 1\n        max_pos = data[\"max_positive_pts\"]\n        max_neg = data[\"max_negative_pts\"]\n        exit_pt = data[\"exit_pts\"]\n        is_winner = data[\"is_winner\"]\n        duration = data[\"duration_bars\"]\n\n        if max_duration &gt; 1:\n            bar_width = min_width + (duration / max_duration) * (max_width - min_width)\n        else:\n            bar_width = max_width\n\n        bar_color = win_color if is_winner else loss_color\n\n        if max_pos &gt; 0:\n            ax.bar(\n                trade_num,\n                max_pos,\n                bottom=0,\n                color=bar_color,\n                width=bar_width,\n                alpha=0.7,\n            )\n        if max_neg &lt; 0:\n            ax.bar(\n                trade_num,\n                abs(max_neg),\n                bottom=max_neg,\n                color=bar_color,\n                width=bar_width,\n                alpha=0.7,\n            )\n\n        half_width = bar_width / 2\n        ax.hlines(\n            exit_pt,\n            trade_num - half_width,\n            trade_num + half_width,\n            colors=\"black\",\n            linewidth=1.5,\n            zorder=5,\n        )\n\n        if is_winner:\n            winning_exits.append(exit_pt)\n            winning_bars.append(duration)\n        else:\n            losing_exits.append(exit_pt)\n            losing_bars.append(duration)\n\n    ax.axhline(y=0, color=\"black\", linestyle=\"-\", linewidth=0.8, alpha=0.5)\n\n    if winning_exits:\n        avg_win = sum(winning_exits) / len(winning_exits)\n        ax.axhline(\n            y=avg_win,\n            color=win_exit_color,\n            linestyle=\"--\",\n            linewidth=1.5,\n            alpha=0.8,\n            label=f\"Avg Win Exit: {avg_win:.1f} pts\",\n        )\n\n    if losing_exits:\n        avg_loss = sum(losing_exits) / len(losing_exits)\n        ax.axhline(\n            y=avg_loss,\n            color=loss_exit_color,\n            linestyle=\"--\",\n            linewidth=1.5,\n            alpha=0.8,\n            label=f\"Avg Loss Exit: {avg_loss:.1f} pts\",\n        )\n\n    total_trades = len(journey_data)\n    max_pos_values = [d[\"max_positive_pts\"] for d in journey_data]\n    max_neg_values = [d[\"max_negative_pts\"] for d in journey_data]\n    exit_values = [d[\"exit_pts\"] for d in journey_data]\n\n    avg_max_pos = sum(max_pos_values) / total_trades if total_trades &gt; 0 else 0\n    highest_pos = max(max_pos_values) if max_pos_values else 0\n    avg_max_neg = abs(sum(max_neg_values) / total_trades) if total_trades &gt; 0 else 0\n    worst_neg = abs(min(max_neg_values)) if max_neg_values else 0\n    avg_exit = sum(exit_values) / total_trades if total_trades &gt; 0 else 0\n    best_exit = max(exit_values) if exit_values else 0\n    worst_exit = min(exit_values) if exit_values else 0\n\n    max_win_bars = max(winning_bars) if winning_bars else 0\n    avg_win_bars = sum(winning_bars) / len(winning_bars) if winning_bars else 0\n    max_loss_bars = max(losing_bars) if losing_bars else 0\n    avg_loss_bars = sum(losing_bars) / len(losing_bars) if losing_bars else 0\n\n    summary_text = (\n        f\"Trade Journey Summary\\n\"\n        f\"Total Trades: {total_trades}\\n\\n\"\n        f\"Max Positive Movement:\\n\"\n        f\"  Average: {avg_max_pos:.1f} pts\\n\"\n        f\"  Highest: {highest_pos:.1f} pts\\n\\n\"\n        f\"Max Negative Movement:\\n\"\n        f\"  Average: {avg_max_neg:.1f} pts\\n\"\n        f\"  Worst: {worst_neg:.1f} pts\\n\\n\"\n        f\"Exit Points:\\n\"\n        f\"  Average: {avg_exit:.1f} pts\\n\"\n        f\"  Best: {best_exit:.1f} pts\\n\"\n        f\"  Worst: {worst_exit:.1f} pts\\n\\n\"\n        f\"Trade Duration (Bars):\\n\"\n        f\"  Wins:   Max {max_win_bars}, Avg {avg_win_bars:.1f}\\n\"\n        f\"  Losses: Max {max_loss_bars}, Avg {avg_loss_bars:.1f}\"\n    )\n\n    props = dict(\n        boxstyle=\"round,pad=0.5\", facecolor=\"#add8e6\", edgecolor=\"#4682b4\", alpha=0.9\n    )\n    ax.text(\n        0.02,\n        0.98,\n        summary_text,\n        transform=ax.transAxes,\n        fontsize=9,\n        verticalalignment=\"top\",\n        fontfamily=\"monospace\",\n        bbox=props,\n    )\n\n    from matplotlib.lines import Line2D\n\n    legend_elements = [\n        Line2D(\n            [0], [0], color=win_color, linewidth=8, alpha=0.7, label=\"Winning Trades\"\n        ),\n        Line2D(\n            [0], [0], color=loss_color, linewidth=8, alpha=0.7, label=\"Losing Trades\"\n        ),\n        Line2D([0], [0], color=\"black\", linewidth=2, label=\"Exit Point\"),\n    ]\n    ax.legend(handles=legend_elements, loc=\"upper right\", fontsize=9)\n\n    ax.set_title(\n        \"Trade Journey Analysis - Maximum Price Movements &amp; Exit Points\", fontsize=14\n    )\n    ax.set_xlabel(\"Trade Number\", fontsize=11)\n    ax.set_ylabel(\"Points from Entry Price\", fontsize=11)\n    ax.grid(True, alpha=0.3, axis=\"y\")\n\n    num_trades = len(journey_data)\n    if num_trades &gt; 20:\n        tick_interval = max(1, num_trades // 15)\n        tick_positions = list(range(1, num_trades + 1, tick_interval))\n        ax.set_xticks(tick_positions)\n\n    plt.tight_layout()\n\n    buf = io.BytesIO()\n    plt.savefig(buf, format=\"png\", dpi=500, bbox_inches=\"tight\")\n    plt.close(fig)\n    buf.seek(0)\n\n    return buf.read()\n</code></pre>"},{"location":"reference/dashboard/charting/#onesecondtrader.dashboard.charting.generate_pnl_summary_chart","title":"<code>generate_pnl_summary_chart(roundtrips)</code>","text":"<p>Generate a PnL Summary chart showing cumulative PnL and trade metrics.</p> <p>Renders a two-panel chart: - Top panel: Cumulative PnL (gross and net) with max drawdown bars - Bottom panel: Max position size per trade (positive for longs, negative for shorts)</p> <p>Parameters:</p> Name Type Description Default <code>roundtrips</code> <code>list[dict]</code> <p>List of round-trip trade dictionaries.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>PNG image bytes, or empty bytes if no data is available.</p> Source code in <code>src/onesecondtrader/dashboard/charting.py</code> <pre><code>def generate_pnl_summary_chart(roundtrips: list[dict]) -&gt; bytes:\n    \"\"\"\n    Generate a PnL Summary chart showing cumulative PnL and trade metrics.\n\n    Renders a two-panel chart:\n    - Top panel: Cumulative PnL (gross and net) with max drawdown bars\n    - Bottom panel: Max position size per trade (positive for longs, negative for shorts)\n\n    Parameters:\n        roundtrips:\n            List of round-trip trade dictionaries.\n\n    Returns:\n        PNG image bytes, or empty bytes if no data is available.\n    \"\"\"\n    if not roundtrips:\n        return b\"\"\n\n    fig, (ax_pnl, ax_pos) = plt.subplots(\n        2, 1, figsize=(14, 9), height_ratios=[2, 1], sharex=True\n    )\n\n    trade_nums = list(range(1, len(roundtrips) + 1))\n    cumulative_pnl_gross = []\n    cumulative_pnl_net = []\n    max_drawdowns = []\n    signed_positions = []\n\n    running_gross = 0.0\n    running_net = 0.0\n    for rt in roundtrips:\n        running_gross += rt[\"pnl_before_commission\"]\n        running_net += rt[\"pnl_after_commission\"]\n        cumulative_pnl_gross.append(running_gross)\n        cumulative_pnl_net.append(running_net)\n        max_drawdowns.append(rt[\"max_drawdown\"])\n        sign = 1 if rt[\"direction\"] == \"LONG\" else -1\n        signed_positions.append(sign * rt[\"max_position\"])\n\n    ax_pnl.plot(\n        trade_nums,\n        cumulative_pnl_gross,\n        color=\"#3fb950\",\n        linewidth=2,\n        label=\"Cumulative PnL (Gross)\",\n        marker=\"o\",\n        markersize=4,\n    )\n    ax_pnl.plot(\n        trade_nums,\n        cumulative_pnl_net,\n        color=\"#1f6feb\",\n        linewidth=2,\n        label=\"Cumulative PnL (Net)\",\n        marker=\"o\",\n        markersize=4,\n    )\n    ax_pnl.bar(\n        trade_nums,\n        [-d for d in max_drawdowns],\n        color=\"#f85149\",\n        alpha=0.5,\n        width=0.4,\n        label=\"Max Drawdown\",\n    )\n\n    total_trades = len(roundtrips)\n    total_pnl_gross = cumulative_pnl_gross[-1] if cumulative_pnl_gross else 0\n    total_pnl_net = cumulative_pnl_net[-1] if cumulative_pnl_net else 0\n\n    winning_trades = [rt for rt in roundtrips if rt[\"pnl_after_commission\"] &gt; 0]\n    losing_trades = [rt for rt in roundtrips if rt[\"pnl_after_commission\"] &lt;= 0]\n    num_winners = len(winning_trades)\n    num_losers = len(losing_trades)\n\n    avg_winner = (\n        sum(rt[\"pnl_after_commission\"] for rt in winning_trades) / num_winners\n        if num_winners &gt; 0\n        else 0\n    )\n    avg_loser = (\n        sum(rt[\"pnl_after_commission\"] for rt in losing_trades) / num_losers\n        if num_losers &gt; 0\n        else 0\n    )\n\n    summary_text = (\n        f\"PnL Summary\\n\"\n        f\"Total Trades: {total_trades}\\n\\n\"\n        f\"Overall PnL (Gross): {total_pnl_gross:+.2f}\\n\"\n        f\"Overall PnL (Net): {total_pnl_net:+.2f}\\n\\n\"\n        f\"Winning Trades: {num_winners}\\n\"\n        f\"Losing Trades: {num_losers}\\n\\n\"\n        f\"Avg Winning Trade: {avg_winner:+.2f}\\n\"\n        f\"Avg Losing Trade: {avg_loser:+.2f}\"\n    )\n\n    props = dict(\n        boxstyle=\"round,pad=0.5\", facecolor=\"#add8e6\", edgecolor=\"#4682b4\", alpha=0.9\n    )\n    ax_pnl.text(\n        0.02,\n        0.98,\n        summary_text,\n        transform=ax_pnl.transAxes,\n        fontsize=9,\n        verticalalignment=\"top\",\n        fontfamily=\"monospace\",\n        bbox=props,\n    )\n\n    ax_pnl.legend(loc=\"upper right\", fontsize=9)\n    ax_pnl.axhline(y=0, color=\"black\", linestyle=\"-\", alpha=0.5, linewidth=0.8)\n    ax_pnl.set_title(\n        \"PnL Summary - Cumulative Performance &amp; Trade Metrics\", fontsize=14\n    )\n    ax_pnl.set_ylabel(\"PnL\", fontsize=11)\n    ax_pnl.grid(True, alpha=0.3, axis=\"y\")\n\n    colors = [\"#3fb950\" if p &gt;= 0 else \"#f85149\" for p in signed_positions]\n    ax_pos.bar(trade_nums, signed_positions, color=colors, alpha=0.7, width=0.6)\n    ax_pos.axhline(y=0, color=\"black\", linestyle=\"-\", alpha=0.5, linewidth=0.8)\n    ax_pos.set_ylabel(\"Max Position\", fontsize=11)\n    ax_pos.set_xlabel(\"Trade Number\", fontsize=11)\n    ax_pos.grid(True, alpha=0.3, axis=\"y\")\n\n    if total_trades &gt; 20:\n        tick_interval = max(1, total_trades // 15)\n        tick_positions = list(range(1, total_trades + 1, tick_interval))\n        ax_pos.set_xticks(tick_positions)\n\n    plt.tight_layout()\n\n    buf = io.BytesIO()\n    plt.savefig(buf, format=\"png\", dpi=500, bbox_inches=\"tight\")\n    plt.close(fig)\n    buf.seek(0)\n\n    return buf.read()\n</code></pre>"},{"location":"reference/dashboard/cli/","title":"Cli","text":"<p>Command-line entry point for launching the dashboard server.</p> <p>Starts the FastAPI application using uvicorn on localhost port 8001.</p>"},{"location":"reference/dashboard/cli/#onesecondtrader.dashboard.cli.main","title":"<code>main()</code>","text":"<p>Launch the dashboard server.</p> <p>Runs the FastAPI application at http://127.0.0.1:8001 using uvicorn.</p> Source code in <code>src/onesecondtrader/dashboard/cli.py</code> <pre><code>def main():\n    \"\"\"\n    Launch the dashboard server.\n\n    Runs the FastAPI application at http://127.0.0.1:8001 using uvicorn.\n    \"\"\"\n    uvicorn.run(\n        \"onesecondtrader.dashboard.app:app\",\n        host=\"127.0.0.1\",\n        port=8001,\n        reload=False,\n    )\n</code></pre>"},{"location":"reference/dashboard/db/","title":"Db","text":"<p>Database access utilities for the dashboard.</p> <p>Provides functions for accessing the runs database and security master database, including path resolution from environment variables and common query operations.</p>"},{"location":"reference/dashboard/db/#onesecondtrader.dashboard.db.CHILD_TABLES","title":"<code>CHILD_TABLES = ['bars', 'bars_processed', 'order_submissions', 'order_cancellations', 'order_modifications', 'orders_accepted', 'orders_rejected', 'cancellations_accepted', 'cancellations_rejected', 'modifications_accepted', 'modifications_rejected', 'fills', 'expirations']</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/db/#onesecondtrader.dashboard.db.get_runs_db_path","title":"<code>get_runs_db_path()</code>","text":"<p>Return the path to the runs database from environment or default.</p> <p>Returns:</p> Type Description <code>str</code> <p>Path to the runs SQLite database file.</p> Source code in <code>src/onesecondtrader/dashboard/db.py</code> <pre><code>def get_runs_db_path() -&gt; str:\n    \"\"\"\n    Return the path to the runs database from environment or default.\n\n    Returns:\n        Path to the runs SQLite database file.\n    \"\"\"\n    return os.environ.get(\"RUNS_DB_PATH\", \"runs.db\")\n</code></pre>"},{"location":"reference/dashboard/db/#onesecondtrader.dashboard.db.get_secmaster_path","title":"<code>get_secmaster_path()</code>","text":"<p>Return the path to the security master database from environment or default.</p> <p>Returns:</p> Type Description <code>str</code> <p>Path to the security master SQLite database file.</p> Source code in <code>src/onesecondtrader/dashboard/db.py</code> <pre><code>def get_secmaster_path() -&gt; str:\n    \"\"\"\n    Return the path to the security master database from environment or default.\n\n    Returns:\n        Path to the security master SQLite database file.\n    \"\"\"\n    return os.environ.get(\"SECMASTER_DB_PATH\", \"secmaster.db\")\n</code></pre>"},{"location":"reference/dashboard/db/#onesecondtrader.dashboard.db.get_runs","title":"<code>get_runs(limit=50)</code>","text":"<p>Fetch recent runs from the runs database.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of runs to return.</p> <code>50</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of run dictionaries with run_id, name, timestamps, status, config, and metadata.</p> Source code in <code>src/onesecondtrader/dashboard/db.py</code> <pre><code>def get_runs(limit: int = 50) -&gt; list[dict]:\n    \"\"\"\n    Fetch recent runs from the runs database.\n\n    Parameters:\n        limit:\n            Maximum number of runs to return.\n\n    Returns:\n        List of run dictionaries with run_id, name, timestamps, status, config, and metadata.\n    \"\"\"\n    db_path = get_runs_db_path()\n    if not os.path.exists(db_path):\n        return []\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"\n        SELECT run_id, name, ts_start, ts_end, status, config, metadata\n        FROM runs\n        ORDER BY ts_start DESC\n        LIMIT ?\n        \"\"\",\n        (limit,),\n    )\n    rows = cursor.fetchall()\n    conn.close()\n    runs = []\n    for row in rows:\n        config = json.loads(row[5]) if row[5] else None\n        metadata = json.loads(row[6]) if row[6] else None\n        runs.append(\n            {\n                \"run_id\": row[0],\n                \"name\": row[1],\n                \"ts_start\": row[2],\n                \"ts_end\": row[3],\n                \"status\": row[4],\n                \"config\": config,\n                \"metadata\": metadata,\n            }\n        )\n    return runs\n</code></pre>"},{"location":"reference/dashboard/layout/","title":"Layout","text":"<p>HTML layout templates and page rendering utilities.</p> <p>Provides the base page structure including sidebar navigation and main content area. All dashboard pages are rendered through <code>render_page</code> which wraps content in the standard layout with navigation and base styles.</p>"},{"location":"reference/dashboard/layout/#onesecondtrader.dashboard.layout.SIDEBAR_HTML","title":"<code>SIDEBAR_HTML = '\\n&lt;aside class=\"sidebar\"&gt;\\n    &lt;div class=\"sidebar-header\"&gt;\\n        &lt;h1&gt;OneSecondTrader&lt;/h1&gt;\\n    &lt;/div&gt;\\n    &lt;nav class=\"sidebar-nav\"&gt;\\n        &lt;a href=\"/backtest\" class=\"{backtest_active}\"&gt;\\n            &lt;svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"&gt;&lt;path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 10V3L4 14h7v7l9-11h-7z\"&gt;&lt;/path&gt;&lt;/svg&gt;\\n            Backtest\\n        &lt;/a&gt;\\n        &lt;a href=\"/performance\" class=\"{performance_active}\"&gt;\\n            &lt;svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"&gt;&lt;path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z\"&gt;&lt;/path&gt;&lt;/svg&gt;\\n            Performance\\n        &lt;/a&gt;\\n    &lt;/nav&gt;\\n&lt;/aside&gt;\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/layout/#onesecondtrader.dashboard.layout.render_sidebar","title":"<code>render_sidebar(active='')</code>","text":"<p>Render the sidebar navigation HTML.</p> <p>Parameters:</p> Name Type Description Default <code>active</code> <code>str</code> <p>Name of the currently active page for highlighting.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML string for the sidebar.</p> Source code in <code>src/onesecondtrader/dashboard/layout.py</code> <pre><code>def render_sidebar(active: str = \"\") -&gt; str:\n    \"\"\"\n    Render the sidebar navigation HTML.\n\n    Parameters:\n        active:\n            Name of the currently active page for highlighting.\n\n    Returns:\n        HTML string for the sidebar.\n    \"\"\"\n    return SIDEBAR_HTML.format(\n        backtest_active=\"active\" if active == \"backtest\" else \"\",\n        performance_active=\"active\" if active == \"performance\" else \"\",\n    )\n</code></pre>"},{"location":"reference/dashboard/layout/#onesecondtrader.dashboard.layout.render_page","title":"<code>render_page(title, content, active='')</code>","text":"<p>Render a complete HTML page with layout.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Page title displayed in the browser tab.</p> required <code>content</code> <code>str</code> <p>HTML content to render in the main content area.</p> required <code>active</code> <code>str</code> <p>Name of the currently active page for sidebar highlighting.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>Complete HTML document string.</p> Source code in <code>src/onesecondtrader/dashboard/layout.py</code> <pre><code>def render_page(title: str, content: str, active: str = \"\") -&gt; str:\n    \"\"\"\n    Render a complete HTML page with layout.\n\n    Parameters:\n        title:\n            Page title displayed in the browser tab.\n        content:\n            HTML content to render in the main content area.\n        active:\n            Name of the currently active page for sidebar highlighting.\n\n    Returns:\n        Complete HTML document string.\n    \"\"\"\n    sidebar = render_sidebar(active)\n    return f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{title} - OneSecondTrader&lt;/title&gt;\n    &lt;style&gt;{BASE_CSS}&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    {sidebar}\n    &lt;main class=\"main-content\"&gt;\n        &lt;div class=\"container\"&gt;\n            {content}\n        &lt;/div&gt;\n    &lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"reference/dashboard/pages/","title":"Pages","text":"<p>Page-specific HTML content generators.</p> <p>Each function generates the HTML content for a specific dashboard page, which is then wrapped in the standard layout by <code>render_page</code>.</p>"},{"location":"reference/dashboard/pages/#onesecondtrader.dashboard.pages.backtest_page","title":"<code>backtest_page()</code>","text":"<p>Generate the backtest configuration page.</p> <p>The page provides a form for configuring and running backtests with:</p> <ul> <li>Strategy selection and parameter configuration</li> <li>Bar period selection (Second, Minute, Hour, Day)</li> <li>Publisher and dataset selection for data source filtering</li> <li>Symbol search and selection with preset management</li> <li>Date range selection constrained by available data</li> <li>Run history display with selection and deletion</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>HTML string for the backtest page content.</p> Source code in <code>src/onesecondtrader/dashboard/pages.py</code> <pre><code>def backtest_page() -&gt; str:\n    \"\"\"\n    Generate the backtest configuration page.\n\n    The page provides a form for configuring and running backtests with:\n\n    - Strategy selection and parameter configuration\n    - Bar period selection (Second, Minute, Hour, Day)\n    - Publisher and dataset selection for data source filtering\n    - Symbol search and selection with preset management\n    - Date range selection constrained by available data\n    - Run history display with selection and deletion\n\n    Returns:\n        HTML string for the backtest page content.\n    \"\"\"\n    content = f\"\"\"\n    &lt;style&gt;{BACKTEST_CSS}&lt;/style&gt;\n    &lt;div class=\"backtest-layout\"&gt;\n        &lt;div class=\"backtest-left\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Settings&lt;/h2&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;Strategy&lt;/label&gt;\n                    &lt;select id=\"strategy\" onchange=\"loadStrategyParams()\"&gt;&lt;/select&gt;\n                    &lt;div class=\"section-header\"&gt;Parameters&lt;/div&gt;\n                    &lt;div id=\"strategy-params\" class=\"params-container\"&gt;&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\"&gt;\n                    &lt;label&gt;Bar Period&lt;/label&gt;\n                    &lt;select id=\"bar-period\" onchange=\"onBarPeriodChange()\"&gt;\n                        &lt;option value=\"\"&gt;-- Select bar period --&lt;/option&gt;\n                    &lt;/select&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\" id=\"symbols-section\" style=\"display: none;\"&gt;\n                    &lt;label&gt;Symbols&lt;/label&gt;\n                    &lt;div class=\"symbol-section\"&gt;\n                        &lt;div class=\"publisher-row\"&gt;\n                            &lt;select id=\"publisher-name\" onchange=\"onPublisherChange()\"&gt;\n                                &lt;option value=\"\"&gt;-- Select Publisher --&lt;/option&gt;\n                            &lt;/select&gt;\n                            &lt;select id=\"publisher-dataset\" onchange=\"onDatasetChange()\"&gt;\n                                &lt;option value=\"\"&gt;-- Select Dataset --&lt;/option&gt;\n                            &lt;/select&gt;\n                        &lt;/div&gt;\n                        &lt;div id=\"symbol-selection\" style=\"display: none;\"&gt;\n                            &lt;div class=\"preset-row\"&gt;\n                                &lt;select id=\"preset-select\" onchange=\"loadPreset()\"&gt;&lt;/select&gt;\n                                &lt;input type=\"text\" id=\"preset-name\" placeholder=\"New preset name...\" oninput=\"updateButtonStates()\"&gt;\n                                &lt;button id=\"preset-save-btn\" class=\"btn btn-sm btn-secondary\" onclick=\"savePreset()\"&gt;Save&lt;/button&gt;\n                                &lt;button id=\"preset-delete-btn\" class=\"btn btn-sm btn-danger\" onclick=\"deletePreset()\"&gt;Delete&lt;/button&gt;\n                            &lt;/div&gt;\n                            &lt;div class=\"search-row\"&gt;\n                                &lt;input type=\"text\" id=\"symbol-search\" placeholder=\"Search symbols...\" oninput=\"searchSymbols()\"&gt;\n                            &lt;/div&gt;\n                            &lt;div id=\"search-results\" class=\"search-results\"&gt;&lt;/div&gt;\n                            &lt;div id=\"selected-label\" class=\"selected-label\"&gt;Selected (0):&lt;/div&gt;\n                            &lt;div id=\"selected-symbols\" class=\"selected-symbols\"&gt;&lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"date-row\"&gt;\n                    &lt;div class=\"form-group\"&gt;\n                        &lt;label&gt;Start Date&lt;/label&gt;\n                        &lt;input type=\"date\" id=\"start-date\" onchange=\"clampDate('start-date')\"&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"form-group\"&gt;\n                        &lt;label&gt;End Date&lt;/label&gt;\n                        &lt;input type=\"date\" id=\"end-date\" onchange=\"clampDate('end-date')\"&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"form-group\" style=\"margin-top: 16px;\"&gt;\n                    &lt;button id=\"run-btn\" class=\"btn\" onclick=\"runBacktest()\" disabled&gt;Run Backtest&lt;/button&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"backtest-right\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Runs&lt;/h2&gt;\n                &lt;div id=\"runs-list\" class=\"runs-list\"&gt;&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;{BACKTEST_JS}&lt;/script&gt;\n    \"\"\"\n    return render_page(\"Backtest\", content, \"backtest\")\n</code></pre>"},{"location":"reference/dashboard/pages/#onesecondtrader.dashboard.pages.performance_page","title":"<code>performance_page()</code>","text":"<p>Generate the performance analysis page.</p> <p>Returns:</p> Type Description <code>str</code> <p>HTML string for the performance page content.</p> Source code in <code>src/onesecondtrader/dashboard/pages.py</code> <pre><code>def performance_page() -&gt; str:\n    \"\"\"\n    Generate the performance analysis page.\n\n    Returns:\n        HTML string for the performance page content.\n    \"\"\"\n    content = f\"\"\"\n    &lt;style&gt;{PERFORMANCE_CSS}&lt;/style&gt;\n    &lt;div class=\"performance-layout\"&gt;\n        &lt;div class=\"performance-left\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Runs&lt;/h2&gt;\n                &lt;div id=\"runs-list\" class=\"runs-list\"&gt;&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"performance-right\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Round-Trip Trades&lt;/h2&gt;\n                &lt;div class=\"search-bar\"&gt;\n                    &lt;input type=\"text\" id=\"symbol-filter\" placeholder=\"Filter by symbol(s)...\" oninput=\"filterRoundtrips()\"&gt;\n                &lt;/div&gt;\n                &lt;div id=\"pnl-summary-container\" class=\"pnl-summary-container\"&gt;&lt;/div&gt;\n                &lt;div id=\"trade-journey-container\" class=\"trade-journey-container\"&gt;&lt;/div&gt;\n                &lt;div id=\"performance-content\"&gt;\n                    &lt;div class=\"empty-content\"&gt;&lt;p&gt;Select a run to view performance&lt;/p&gt;&lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;{PERFORMANCE_JS}&lt;/script&gt;\n    \"\"\"\n    return render_page(\"Performance\", content, \"performance\")\n</code></pre>"},{"location":"reference/dashboard/registry/","title":"Registry","text":"<p>Strategy discovery and parameter schema extraction.</p> <p>Provides utilities for discovering registered strategy classes and extracting their parameter specifications into JSON-serializable schemas for the dashboard UI.</p>"},{"location":"reference/dashboard/registry/#onesecondtrader.dashboard.registry.get_strategies","title":"<code>get_strategies()</code>","text":"<p>Get all registered strategy classes.</p> <p>Returns:</p> Type Description <code>dict[str, type[StrategyBase]]</code> <p>Dictionary mapping strategy class names to their class objects.</p> Source code in <code>src/onesecondtrader/dashboard/registry.py</code> <pre><code>def get_strategies() -&gt; dict[str, type[StrategyBase]]:\n    \"\"\"\n    Get all registered strategy classes.\n\n    Returns:\n        Dictionary mapping strategy class names to their class objects.\n    \"\"\"\n    return get_registered_strategies()\n</code></pre>"},{"location":"reference/dashboard/registry/#onesecondtrader.dashboard.registry.get_param_schema","title":"<code>get_param_schema(params)</code>","text":"<p>Convert strategy parameter specifications to a JSON-serializable schema.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict[str, ParamSpec]</code> <p>Dictionary mapping parameter names to their specifications.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of parameter schema dictionaries with keys: name, default, type,</p> <code>list[dict]</code> <p>and optionally min, max, step, choices.</p> Source code in <code>src/onesecondtrader/dashboard/registry.py</code> <pre><code>def get_param_schema(params: dict[str, ParamSpec]) -&gt; list[dict]:\n    \"\"\"\n    Convert strategy parameter specifications to a JSON-serializable schema.\n\n    Parameters:\n        params:\n            Dictionary mapping parameter names to their specifications.\n\n    Returns:\n        List of parameter schema dictionaries with keys: name, default, type,\n        and optionally min, max, step, choices.\n    \"\"\"\n    schema: list[dict] = []\n    for name, spec in params.items():\n        param_info: dict = {\n            \"name\": name,\n            \"default\": _serialize_value(spec.default),\n            \"type\": _get_type_name(spec.default),\n        }\n        if spec.min is not None:\n            param_info[\"min\"] = spec.min\n        if spec.max is not None:\n            param_info[\"max\"] = spec.max\n        if spec.step is not None:\n            param_info[\"step\"] = spec.step\n        choices = spec.resolved_choices\n        if choices is not None:\n            param_info[\"choices\"] = [_serialize_value(c) for c in choices]\n        schema.append(param_info)\n    return schema\n</code></pre>"},{"location":"reference/dashboard/registry/#onesecondtrader.dashboard.registry._serialize_value","title":"<code>_serialize_value(value)</code>","text":"<p>Serialize a parameter value for JSON output.</p> <p>Enum values are converted to their name strings.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>Value to serialize.</p> required <p>Returns:</p> Type Description <code>str | int | float | bool</code> <p>JSON-serializable representation of the value.</p> Source code in <code>src/onesecondtrader/dashboard/registry.py</code> <pre><code>def _serialize_value(value: object) -&gt; str | int | float | bool:\n    \"\"\"\n    Serialize a parameter value for JSON output.\n\n    Enum values are converted to their name strings.\n\n    Parameters:\n        value:\n            Value to serialize.\n\n    Returns:\n        JSON-serializable representation of the value.\n    \"\"\"\n    if isinstance(value, enum.Enum):\n        return value.name\n    if isinstance(value, bool):\n        return value\n    if isinstance(value, int):\n        return value\n    if isinstance(value, float):\n        return value\n    if isinstance(value, str):\n        return value\n    return str(value)\n</code></pre>"},{"location":"reference/dashboard/registry/#onesecondtrader.dashboard.registry._get_type_name","title":"<code>_get_type_name(value)</code>","text":"<p>Determine the type name for a parameter value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>Value to determine type of.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Type name string: enum, bool, int, float, str, or unknown.</p> Source code in <code>src/onesecondtrader/dashboard/registry.py</code> <pre><code>def _get_type_name(value: object) -&gt; str:\n    \"\"\"\n    Determine the type name for a parameter value.\n\n    Parameters:\n        value:\n            Value to determine type of.\n\n    Returns:\n        Type name string: enum, bool, int, float, str, or unknown.\n    \"\"\"\n    if isinstance(value, enum.Enum):\n        return \"enum\"\n    if isinstance(value, bool):\n        return \"bool\"\n    if isinstance(value, int):\n        return \"int\"\n    if isinstance(value, float):\n        return \"float\"\n    if isinstance(value, str):\n        return \"str\"\n    return \"unknown\"\n</code></pre>"},{"location":"reference/dashboard/registry/#onesecondtrader.dashboard.registry.get_strategy_schema","title":"<code>get_strategy_schema(name)</code>","text":"<p>Get the full schema for a strategy by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Class name of the strategy.</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>Dictionary with strategy name and parameter schema, or None if not found.</p> Source code in <code>src/onesecondtrader/dashboard/registry.py</code> <pre><code>def get_strategy_schema(name: str) -&gt; dict | None:\n    \"\"\"\n    Get the full schema for a strategy by name.\n\n    Parameters:\n        name:\n            Class name of the strategy.\n\n    Returns:\n        Dictionary with strategy name and parameter schema, or None if not found.\n    \"\"\"\n    cls = get_strategies().get(name)\n    if cls is None:\n        return None\n    return {\n        \"name\": name,\n        \"parameters\": get_param_schema(getattr(cls, \"parameters\", {})),\n    }\n</code></pre>"},{"location":"reference/dashboard/roundtrips/","title":"Roundtrips","text":"<p>Round-trip trade computation from fill records.</p> <p>Aggregates fill events into complete round-trip trades with P&amp;L, duration, high watermark, and maximum drawdown metrics.</p>"},{"location":"reference/dashboard/roundtrips/#onesecondtrader.dashboard.roundtrips.compute_watermarks_and_drawdown","title":"<code>compute_watermarks_and_drawdown(conn, run_id, symbol, direction, avg_entry, quantity, entry_ts, exit_ts)</code>","text":"<p>Compute high watermark, low watermark, maximum drawdown, and bar count for a round-trip trade.</p> <p>Iterates through bars during the trade period to track: - High watermark: the best unrealized P&amp;L reached - Low watermark: the worst unrealized P&amp;L reached - Max drawdown: the largest decline from any peak to any subsequent trough - Duration bars: number of bars from entry to exit (inclusive)</p> <p>Note: Within each bar, we assume the high occurred before the low (worst-case assumption for drawdown calculation), since intra-bar sequence is unknown.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Connection</code> <p>SQLite database connection.</p> required <code>run_id</code> <code>str</code> <p>Unique identifier of the backtest run.</p> required <code>symbol</code> <code>str</code> <p>Instrument symbol for the trade.</p> required <code>direction</code> <code>str</code> <p>Trade direction, either \"LONG\" or \"SHORT\".</p> required <code>avg_entry</code> <code>float</code> <p>Average entry price.</p> required <code>quantity</code> <code>float</code> <p>Total position quantity.</p> required <code>entry_ts</code> <code>int</code> <p>Entry timestamp in nanoseconds.</p> required <code>exit_ts</code> <code>int</code> <p>Exit timestamp in nanoseconds.</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, int]</code> <p>Tuple of (high_watermark, low_watermark, max_drawdown, duration_bars) in currency units.</p> Source code in <code>src/onesecondtrader/dashboard/roundtrips.py</code> <pre><code>def compute_watermarks_and_drawdown(\n    conn: sqlite3.Connection,\n    run_id: str,\n    symbol: str,\n    direction: str,\n    avg_entry: float,\n    quantity: float,\n    entry_ts: int,\n    exit_ts: int,\n) -&gt; tuple[float, float, float, int]:\n    \"\"\"\n    Compute high watermark, low watermark, maximum drawdown, and bar count for a round-trip trade.\n\n    Iterates through bars during the trade period to track:\n    - High watermark: the best unrealized P&amp;L reached\n    - Low watermark: the worst unrealized P&amp;L reached\n    - Max drawdown: the largest decline from any peak to any subsequent trough\n    - Duration bars: number of bars from entry to exit (inclusive)\n\n    Note: Within each bar, we assume the high occurred before the low (worst-case\n    assumption for drawdown calculation), since intra-bar sequence is unknown.\n\n    Parameters:\n        conn:\n            SQLite database connection.\n        run_id:\n            Unique identifier of the backtest run.\n        symbol:\n            Instrument symbol for the trade.\n        direction:\n            Trade direction, either \"LONG\" or \"SHORT\".\n        avg_entry:\n            Average entry price.\n        quantity:\n            Total position quantity.\n        entry_ts:\n            Entry timestamp in nanoseconds.\n        exit_ts:\n            Exit timestamp in nanoseconds.\n\n    Returns:\n        Tuple of (high_watermark, low_watermark, max_drawdown, duration_bars) in currency units.\n    \"\"\"\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"\n        SELECT high, low FROM bars\n        WHERE run_id = ? AND symbol = ? AND ts_event_ns &gt;= ? AND ts_event_ns &lt;= ?\n        ORDER BY ts_event_ns\n        \"\"\",\n        (run_id, symbol, entry_ts, exit_ts),\n    )\n    bars = cursor.fetchall()\n\n    if not bars:\n        return 0.0, 0.0, 0.0, 0\n\n    high_watermark = 0.0\n    low_watermark = 0.0\n    max_drawdown = 0.0\n    running_peak = 0.0\n    duration_bars = len(bars)\n\n    for bar_high, bar_low in bars:\n        if direction == \"LONG\":\n            best_pnl = (bar_high - avg_entry) * quantity\n            worst_pnl = (bar_low - avg_entry) * quantity\n        else:\n            best_pnl = (avg_entry - bar_low) * quantity\n            worst_pnl = (avg_entry - bar_high) * quantity\n\n        if best_pnl &gt; high_watermark:\n            high_watermark = best_pnl\n\n        if worst_pnl &lt; low_watermark:\n            low_watermark = worst_pnl\n\n        if best_pnl &gt; running_peak:\n            running_peak = best_pnl\n\n        drawdown = running_peak - worst_pnl\n        if drawdown &gt; max_drawdown:\n            max_drawdown = drawdown\n\n    return high_watermark, low_watermark, max_drawdown, duration_bars\n</code></pre>"},{"location":"reference/dashboard/roundtrips/#onesecondtrader.dashboard.roundtrips.get_roundtrips","title":"<code>get_roundtrips(run_id)</code>","text":"<p>Compute round-trip trades from fill records for a run.</p> <p>Aggregates fills by symbol into complete round-trips, calculating entry/exit prices, P&amp;L, duration, high watermark, and maximum drawdown for each.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>str</code> <p>Unique identifier of the backtest run.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of round-trip dictionaries with symbol, direction, duration, max_position,</p> <code>list[dict]</code> <p>high_watermark, max_drawdown, pnl_before_commission, pnl_after_commission,</p> <code>list[dict]</code> <p>entry_ts, and exit_ts.</p> Source code in <code>src/onesecondtrader/dashboard/roundtrips.py</code> <pre><code>def get_roundtrips(run_id: str) -&gt; list[dict]:\n    \"\"\"\n    Compute round-trip trades from fill records for a run.\n\n    Aggregates fills by symbol into complete round-trips, calculating entry/exit\n    prices, P&amp;L, duration, high watermark, and maximum drawdown for each.\n\n    Parameters:\n        run_id:\n            Unique identifier of the backtest run.\n\n    Returns:\n        List of round-trip dictionaries with symbol, direction, duration, max_position,\n        high_watermark, max_drawdown, pnl_before_commission, pnl_after_commission,\n        entry_ts, and exit_ts.\n    \"\"\"\n    db_path = get_runs_db_path()\n    if not os.path.exists(db_path):\n        return []\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"\n        SELECT symbol, side, quantity_filled, fill_price, commission, ts_broker_ns\n        FROM fills\n        WHERE run_id = ?\n        ORDER BY symbol, ts_broker_ns\n        \"\"\",\n        (run_id,),\n    )\n    rows = cursor.fetchall()\n\n    fills_by_symbol: dict[str, list] = {}\n    for row in rows:\n        symbol = row[0]\n        fills_by_symbol.setdefault(symbol, []).append(\n            {\n                \"side\": row[1],\n                \"quantity\": row[2],\n                \"price\": row[3],\n                \"commission\": row[4],\n                \"ts_ns\": row[5],\n            }\n        )\n\n    roundtrips = []\n    for symbol, fills in fills_by_symbol.items():\n        position = 0.0\n        entry_fills: list[dict] = []\n        entry_value = 0.0\n        entry_commission = 0.0\n        max_pos = 0.0\n        start_ts: int = 0\n\n        for fill in fills:\n            signed_qty = (\n                fill[\"quantity\"] if fill[\"side\"] == \"BUY\" else -fill[\"quantity\"]\n            )\n            if position == 0.0:\n                start_ts = fill[\"ts_ns\"]\n                entry_fills = []\n                entry_value = 0.0\n                entry_commission = 0.0\n                max_pos = 0.0\n\n            position += signed_qty\n            max_pos = max(max_pos, abs(position))\n\n            if (signed_qty &gt; 0 and position &gt; 0) or (signed_qty &lt; 0 and position &lt; 0):\n                entry_value += fill[\"price\"] * fill[\"quantity\"]\n                entry_commission += fill[\"commission\"]\n                entry_fills.append(fill)\n            else:\n                exit_commission = fill[\"commission\"]\n\n                if abs(position) &lt; 1e-9:\n                    direction = (\n                        \"LONG\"\n                        if entry_fills and entry_fills[0][\"side\"] == \"BUY\"\n                        else \"SHORT\"\n                    )\n                    total_entry_qty = sum(f[\"quantity\"] for f in entry_fills)\n                    avg_entry = (\n                        entry_value / total_entry_qty if total_entry_qty &gt; 0 else 0\n                    )\n                    avg_exit = fill[\"price\"]\n                    total_commission = entry_commission + exit_commission\n\n                    if direction == \"LONG\":\n                        pnl_before_commission = (avg_exit - avg_entry) * total_entry_qty\n                    else:\n                        pnl_before_commission = (avg_entry - avg_exit) * total_entry_qty\n\n                    pnl_after_commission = pnl_before_commission - total_commission\n\n                    hwm, lwm, mdd, duration_bars = compute_watermarks_and_drawdown(\n                        conn,\n                        run_id,\n                        symbol,\n                        direction,\n                        avg_entry,\n                        total_entry_qty,\n                        start_ts,\n                        fill[\"ts_ns\"],\n                    )\n\n                    roundtrips.append(\n                        {\n                            \"symbol\": symbol,\n                            \"direction\": direction,\n                            \"duration_bars\": duration_bars,\n                            \"max_position\": round(max_pos, 4),\n                            \"high_watermark\": round(hwm, 2),\n                            \"low_watermark\": round(lwm, 2),\n                            \"max_drawdown\": round(mdd, 2),\n                            \"pnl_before_commission\": round(pnl_before_commission, 2),\n                            \"pnl_after_commission\": round(pnl_after_commission, 2),\n                            \"entry_ts\": start_ts,\n                            \"exit_ts\": fill[\"ts_ns\"],\n                        }\n                    )\n                    position = 0.0\n\n    conn.close()\n    return roundtrips\n</code></pre>"},{"location":"reference/dashboard/styles/","title":"Styles","text":"<p>CSS stylesheets and JavaScript for the dashboard UI.</p> <p>This module contains embedded CSS and JavaScript as Python string constants. The styles implement a dark-themed interface with a fixed sidebar navigation and responsive content areas.</p> Constants <p>BASE_CSS: Global styles for layout, sidebar, cards, forms, and common elements. BACKTEST_CSS: Styles specific to the backtest configuration page. BACKTEST_JS: JavaScript for backtest page interactivity including:     - Strategy and parameter loading     - Publisher/dataset/symbol cascading selection     - Symbol preset management     - Date range validation     - Backtest execution and run history display</p> Source code in <code>styles.py</code> <pre><code>\"\"\"\nCSS stylesheets and JavaScript for the dashboard UI.\n\nThis module contains embedded CSS and JavaScript as Python string constants. The styles\nimplement a dark-themed interface with a fixed sidebar navigation and responsive content\nareas.\n\nConstants:\n    BASE_CSS: Global styles for layout, sidebar, cards, forms, and common elements.\n    BACKTEST_CSS: Styles specific to the backtest configuration page.\n    BACKTEST_JS: JavaScript for backtest page interactivity including:\n        - Strategy and parameter loading\n        - Publisher/dataset/symbol cascading selection\n        - Symbol preset management\n        - Date range validation\n        - Backtest execution and run history display\n\"\"\"\n\nBASE_CSS = \"\"\"\n* { margin: 0; padding: 0; box-sizing: border-box; }\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n    background: #0d1117;\n    color: #e6edf3;\n    min-height: 100vh;\n    display: flex;\n}\n.sidebar {\n    width: 220px;\n    background: #161b22;\n    border-right: 1px solid #30363d;\n    min-height: 100vh;\n    position: fixed;\n    left: 0;\n    top: 0;\n    display: flex;\n    flex-direction: column;\n}\n.sidebar-header {\n    padding: 20px 16px;\n    border-bottom: 1px solid #30363d;\n}\n.sidebar-header h1 {\n    font-size: 16px;\n    font-weight: 600;\n    color: #e6edf3;\n}\n.sidebar-nav {\n    padding: 12px 8px;\n    flex: 1;\n}\n.sidebar-nav a {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 10px 12px;\n    color: #8b949e;\n    text-decoration: none;\n    font-size: 14px;\n    border-radius: 6px;\n    margin-bottom: 2px;\n}\n.sidebar-nav a:hover {\n    background: #21262d;\n    color: #e6edf3;\n}\n.sidebar-nav a.active {\n    background: #21262d;\n    color: #e6edf3;\n}\n.sidebar-nav svg {\n    width: 16px;\n    height: 16px;\n    flex-shrink: 0;\n}\n.main-content {\n    margin-left: 220px;\n    flex: 1;\n    min-height: 100vh;\n}\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 32px 24px;\n}\n.card {\n    background: #161b22;\n    border: 1px solid #30363d;\n    border-radius: 8px;\n    padding: 24px;\n    margin-bottom: 16px;\n}\n.card h2 {\n    font-size: 16px;\n    font-weight: 600;\n    margin-bottom: 16px;\n    color: #e6edf3;\n}\n.empty-state {\n    text-align: center;\n    padding: 48px;\n    color: #8b949e;\n}\n.empty-state p {\n    margin-top: 8px;\n    font-size: 14px;\n}\n\"\"\"\n\nBACKTEST_CSS = \"\"\"\n.container { max-width: none; height: 100vh; padding: 24px; display: flex; flex-direction: column; box-sizing: border-box; }\n.backtest-layout { display: flex; gap: 24px; flex: 1; min-height: 0; }\n.backtest-left { flex: 1; min-width: 0; display: flex; flex-direction: column; }\n.backtest-right { flex: 1; min-width: 0; display: flex; flex-direction: column; }\n.backtest-left .card, .backtest-right .card { flex: 1; display: flex; flex-direction: column; margin-bottom: 0; overflow: hidden; }\n.backtest-right .runs-list { flex: 1; overflow-y: auto; }\n.form-group { margin-bottom: 16px; }\n.form-group label { display: block; margin-bottom: 6px; font-size: 14px; color: #8b949e; }\n.form-group select, .form-group input {\n    width: 100%; padding: 8px 12px; background: #0d1117; border: 1px solid #30363d;\n    border-radius: 6px; color: #e6edf3; font-size: 14px;\n}\n.form-group select:focus, .form-group input:focus { outline: none; border-color: #58a6ff; }\n.params-container { margin-top: 12px; padding: 12px; background: #0d1117; border-radius: 6px; }\n.param-row { display: flex; gap: 12px; margin-bottom: 8px; align-items: center; }\n.param-row label { min-width: 120px; font-size: 13px; }\n.param-row input, .param-row select { flex: 1; }\n.btn { padding: 10px 20px; background: #238636; border: none; border-radius: 6px;\n    color: #fff; font-size: 14px; cursor: pointer; width: 100%; }\n.btn:hover { background: #2ea043; }\n.btn:disabled { background: #30363d; cursor: not-allowed; }\n.date-row { display: flex; gap: 12px; }\n.date-row .form-group { flex: 1; margin-bottom: 0; }\n.symbol-section { background: #0d1117; border-radius: 6px; padding: 12px; }\n.publisher-row { display: flex; gap: 8px; margin-bottom: 12px; }\n.publisher-row select { flex: 1; }\n.preset-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: center; }\n.preset-row select { flex: 1; }\n.preset-row input { flex: 1; }\n.preset-row .btn-sm { padding: 6px 12px; font-size: 12px; width: auto; cursor: not-allowed; }\n.preset-row .btn-secondary { background: #30363d; }\n.preset-row .btn-secondary.active { background: #238636; cursor: pointer; }\n.preset-row .btn-secondary.active:hover { background: #2ea043; }\n.preset-row .btn-danger { background: #30363d; }\n.preset-row .btn-danger.active { background: #da3633; cursor: pointer; }\n.preset-row .btn-danger.active:hover { background: #f85149; }\n.search-row { display: flex; gap: 8px; margin-bottom: 8px; }\n.search-row input { flex: 1; }\n.search-results { max-height: 150px; overflow-y: auto; border: 1px solid #30363d; border-radius: 4px; margin-bottom: 12px; }\n.search-results:empty { display: none; }\n.search-result { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; border-bottom: 1px solid #21262d; cursor: pointer; }\n.search-result:last-child { border-bottom: none; }\n.search-result:hover { background: #161b22; }\n.search-result .symbol { font-family: monospace; }\n.selected-symbols { display: flex; flex-wrap: wrap; gap: 6px; min-height: 32px; max-height: 150px; overflow-y: auto; }\n.selected-tag { display: inline-flex; align-items: center; gap: 4px; background: #238636; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-family: monospace; }\n.selected-tag .remove { cursor: pointer; opacity: 0.7; }\n.selected-tag .remove:hover { opacity: 1; }\n.selected-label { font-size: 13px; color: #8b949e; margin-bottom: 6px; }\n.section-header { font-size: 14px; color: #8b949e; margin-bottom: 6px; margin-top: 8px; }\n.runs-list { display: flex; flex-direction: column; gap: 12px; }\n.run-item { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; display: flex; gap: 12px; align-items: flex-start; }\n.run-item.selected { border-color: #58a6ff; }\n.run-checkbox { flex-shrink: 0; margin-top: 2px; width: 16px; height: 16px; accent-color: #58a6ff; cursor: pointer; }\n.run-content { flex: 1; min-width: 0; }\n.run-content.clickable { cursor: pointer; }\n.run-content.clickable:hover { opacity: 0.8; }\n.run-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }\n.run-name { font-family: monospace; font-size: 13px; color: #e6edf3; }\n.run-id { color: #8b949e; font-size: 11px; margin-left: 6px; }\n.run-status { font-size: 12px; font-weight: 500; padding: 2px 8px; border-radius: 10px; }\n.run-status.running { background: #9e6a03; color: #fff; }\n.run-status.completed { background: #238636; color: #fff; }\n.run-status.failed { background: #da3633; color: #fff; }\n.run-status.cancelled { background: #30363d; color: #8b949e; }\n.run-status.error { background: #da3633; color: #fff; }\n.run-meta { font-size: 12px; color: #8b949e; }\n.run-meta.with-progress { margin-bottom: 8px; }\n.progress-bar { height: 6px; background: #30363d; border-radius: 3px; overflow: hidden; }\n.progress-fill { height: 100%; background: #58a6ff; transition: width 0.3s ease; }\n.progress-fill.completed { background: #238636; }\n.progress-fill.error { background: #da3633; }\n.empty-runs { text-align: center; padding: 48px 24px; color: #8b949e; }\n.empty-runs p { font-size: 14px; }\n.runs-toolbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #30363d; }\n.runs-toolbar .select-all-label { display: flex; align-items: center; gap: 8px; font-size: 13px; color: #8b949e; cursor: pointer; }\n.runs-toolbar .select-all-label input { width: 16px; height: 16px; accent-color: #58a6ff; cursor: pointer; }\n.btn-delete { padding: 6px 12px; background: #da3633; border: none; border-radius: 6px; color: #fff; font-size: 13px; cursor: pointer; }\n.btn-delete:hover { background: #f85149; }\n.btn-delete:disabled { background: #30363d; cursor: not-allowed; color: #8b949e; }\n\"\"\"\n\nBACKTEST_JS = \"\"\"\nlet strategyParams = [];\nlet coverageData = [];\nlet availableRtypes = [];\nlet symbolsForRtype = {};\nlet symbolCoverageForRtype = {};\nlet selectedSymbols = [];\nlet presets = [];\nlet globalMinDate = null;\nlet globalMaxDate = null;\nlet dbRuns = [];\nlet activeRuns = {};\nlet selectedRunIds = new Set();\nlet publishers = [];\nlet datasets = [];\nlet selectedPublisherId = null;\n\nconst RTYPE_LABELS = {32: 'Second', 33: 'Minute', 34: 'Hour', 35: 'Day'};\n\nfunction capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nasync function loadPublishers() {\n    const rtype = getSelectedRtype();\n    const url = rtype ? `/api/secmaster/publishers?rtype=${rtype}` : '/api/secmaster/publishers';\n    const res = await fetch(url);\n    const data = await res.json();\n    publishers = data.publishers || [];\n    const sel = document.getElementById('publisher-name');\n    sel.innerHTML = '&lt;option value=\"\"&gt;-- Select Publisher --&lt;/option&gt;';\n    publishers.forEach(p =&gt; sel.innerHTML += `&lt;option value=\"${p}\"&gt;${capitalize(p)}&lt;/option&gt;`);\n}\n\nasync function onPublisherChange() {\n    const name = document.getElementById('publisher-name').value;\n    const rtype = getSelectedRtype();\n    const datasetSel = document.getElementById('publisher-dataset');\n    datasetSel.innerHTML = '&lt;option value=\"\"&gt;-- Select Dataset --&lt;/option&gt;';\n    datasets = [];\n    selectedPublisherId = null;\n    document.getElementById('symbol-selection').style.display = 'none';\n    selectedSymbols = [];\n    renderSelectedSymbols();\n    updateDateRange();\n    if (!name) return;\n    const url = rtype\n        ? `/api/secmaster/publishers/${encodeURIComponent(name)}/datasets?rtype=${rtype}`\n        : `/api/secmaster/publishers/${encodeURIComponent(name)}/datasets`;\n    const res = await fetch(url);\n    const data = await res.json();\n    datasets = data.datasets || [];\n    datasets.forEach(d =&gt; datasetSel.innerHTML += `&lt;option value=\"${d.publisher_id}\"&gt;${d.dataset}&lt;/option&gt;`);\n}\n\nasync function onDatasetChange() {\n    const pubId = document.getElementById('publisher-dataset').value;\n    selectedPublisherId = pubId ? parseInt(pubId) : null;\n    selectedSymbols = [];\n    renderSelectedSymbols();\n    updateDateRange();\n    document.getElementById('symbol-search').value = '';\n    document.getElementById('search-results').innerHTML = '';\n    if (selectedPublisherId) {\n        await loadCoverageForPublisher(selectedPublisherId);\n        document.getElementById('symbol-selection').style.display = 'block';\n        await loadPresets();\n    } else {\n        document.getElementById('symbol-selection').style.display = 'none';\n    }\n}\n\nasync function loadCoverageForPublisher(publisherId) {\n    const rtype = getSelectedRtype();\n    const url = `/api/secmaster/symbols_coverage?publisher_id=${publisherId}&amp;rtype=${rtype}`;\n    const res = await fetch(url);\n    const data = await res.json();\n    coverageData = data.symbols || [];\n    symbolsForRtype = {};\n    symbolCoverageForRtype = {};\n    coverageData.forEach(row =&gt; {\n        if (!symbolsForRtype[row.rtype]) {\n            symbolsForRtype[row.rtype] = [];\n            symbolCoverageForRtype[row.rtype] = {};\n        }\n        symbolsForRtype[row.rtype].push(row.symbol);\n        symbolCoverageForRtype[row.rtype][row.symbol] = {min_ts: row.min_ts, max_ts: row.max_ts};\n    });\n}\n\nasync function loadPresets() {\n    const res = await fetch('/api/presets');\n    const data = await res.json();\n    presets = data.presets || [];\n    await filterAndRenderPresets();\n}\n\nasync function filterAndRenderPresets() {\n    const sel = document.getElementById('preset-select');\n    sel.innerHTML = '&lt;option value=\"\"&gt;-- Select Preset --&lt;/option&gt;';\n    const rtype = getSelectedRtype();\n    const availableSymbols = symbolsForRtype[rtype] || [];\n    for (const p of presets) {\n        const res = await fetch(`/api/presets/${encodeURIComponent(p)}`);\n        const data = await res.json();\n        const hasAvailable = (data.symbols || []).some(s =&gt; availableSymbols.includes(s));\n        if (hasAvailable) {\n            sel.innerHTML += `&lt;option value=\"${p}\"&gt;${p}&lt;/option&gt;`;\n        }\n    }\n    updateButtonStates();\n}\n\nasync function loadPreset() {\n    const name = document.getElementById('preset-select').value;\n    updateButtonStates();\n    if (!name) {\n        selectedSymbols = [];\n        renderSelectedSymbols();\n        updateDateRange();\n        return;\n    }\n    const rtype = getSelectedRtype();\n    const symbols = symbolsForRtype[rtype] || [];\n    const res = await fetch(`/api/presets/${encodeURIComponent(name)}`);\n    const data = await res.json();\n    if (data.symbols) {\n        selectedSymbols = data.symbols.filter(s =&gt; symbols.includes(s));\n        renderSelectedSymbolsKeepPreset();\n        updateDateRange();\n    }\n}\n\nasync function savePreset() {\n    const nameInput = document.getElementById('preset-name');\n    const name = nameInput.value.trim();\n    if (!name) { alert('Enter a preset name'); return; }\n    if (selectedSymbols.length === 0) { alert('Select at least one symbol'); return; }\n    const exists = presets.includes(name);\n    const method = exists ? 'PUT' : 'POST';\n    const url = exists ? `/api/presets/${encodeURIComponent(name)}` : '/api/presets';\n    await fetch(url, {\n        method, headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({name, symbols: selectedSymbols})\n    });\n    nameInput.value = '';\n    await loadPresets();\n    document.getElementById('preset-select').value = name;\n}\n\nasync function deletePreset() {\n    const name = document.getElementById('preset-select').value;\n    if (!name) { alert('Select a preset to delete'); return; }\n    if (!confirm(`Delete preset \"${name}\"?`)) return;\n    await fetch(`/api/presets/${encodeURIComponent(name)}`, {method: 'DELETE'});\n    await loadPresets();\n    selectedSymbols = [];\n    renderSelectedSymbols();\n    updateDateRange();\n}\n\nfunction updateButtonStates() {\n    const runBtn = document.getElementById('run-btn');\n    const saveBtn = document.getElementById('preset-save-btn');\n    const deleteBtn = document.getElementById('preset-delete-btn');\n    const presetSelect = document.getElementById('preset-select');\n    const presetNameInput = document.getElementById('preset-name');\n    const strategyEl = document.getElementById('strategy');\n    const barPeriodEl = document.getElementById('bar-period');\n    if (!runBtn) return;\n    const rtype = barPeriodEl ? parseInt(barPeriodEl.value) || null : null;\n    const strategy = strategyEl ? strategyEl.value : '';\n    const canRun = strategy &amp;&amp; rtype &amp;&amp; selectedPublisherId &amp;&amp; selectedSymbols.length &gt; 0;\n    runBtn.disabled = !canRun;\n    const hasPresetSelected = !!(presetSelect &amp;&amp; presetSelect.value);\n    const hasPresetName = !!(presetNameInput &amp;&amp; presetNameInput.value.trim().length &gt; 0);\n    const canSave = hasPresetName &amp;&amp; selectedSymbols.length &gt; 0;\n    if (saveBtn) {\n        saveBtn.classList.toggle('active', canSave);\n    }\n    if (deleteBtn) {\n        deleteBtn.classList.toggle('active', hasPresetSelected);\n    }\n}\n\nasync function loadStrategies() {\n    const res = await fetch('/api/strategies');\n    const data = await res.json();\n    const sel = document.getElementById('strategy');\n    data.strategies.forEach(s =&gt; sel.innerHTML += `&lt;option value=\"${s.id}\"&gt;${s.name}&lt;/option&gt;`);\n    if (data.strategies.length &gt; 0) {\n        sel.value = data.strategies[0].id;\n        loadStrategyParams();\n    }\n}\n\nasync function loadStrategyParams() {\n    const name = document.getElementById('strategy').value;\n    if (!name) return;\n    const res = await fetch(`/api/strategies/${name}`);\n    const data = await res.json();\n    strategyParams = data.parameters || [];\n    renderParams();\n}\n\nfunction formatParamName(name) {\n    let result = name.replace(/_/g, ' ');\n    result = result.replace(/([A-Z]+)([A-Z][a-z])/g, '$1 $2');\n    result = result.replace(/([a-z])([A-Z])/g, '$1 $2');\n    return result.split(' ').map(word =&gt; {\n        if (word === word.toUpperCase() &amp;&amp; word.length &gt; 1) return word;\n        return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(' ');\n}\n\nfunction renderParams() {\n    const container = document.getElementById('strategy-params');\n    const filtered = strategyParams.filter(p =&gt; p.name !== 'bar_period');\n    if (filtered.length === 0) {\n        container.innerHTML = '&lt;div style=\"color: #8b949e; font-size: 13px;\"&gt;No parameters&lt;/div&gt;';\n        return;\n    }\n    container.innerHTML = filtered.map(p =&gt; {\n        const label = formatParamName(p.name);\n        if (p.choices &amp;&amp; p.choices.length &gt; 0) {\n            const opts = p.choices.map(c =&gt; `&lt;option value=\"${c}\" ${c === p.default ? 'selected' : ''}&gt;${c}&lt;/option&gt;`).join('');\n            return `&lt;div class=\"param-row\"&gt;&lt;label&gt;${label}&lt;/label&gt;&lt;select id=\"sp_${p.name}\"&gt;${opts}&lt;/select&gt;&lt;/div&gt;`;\n        }\n        const inputType = p.type === 'bool' ? 'checkbox' : (p.type === 'float' || p.type === 'int' ? 'number' : 'text');\n        const step = p.step || (p.type === 'float' ? '0.01' : '1');\n        const checked = p.type === 'bool' &amp;&amp; p.default ? 'checked' : '';\n        return `&lt;div class=\"param-row\"&gt;&lt;label&gt;${label}&lt;/label&gt;&lt;input type=\"${inputType}\" id=\"sp_${p.name}\" value=\"${p.default}\" step=\"${step}\" ${p.min !== undefined ? `min=\"${p.min}\"` : ''} ${p.max !== undefined ? `max=\"${p.max}\"` : ''} ${checked}&gt;&lt;/div&gt;`;\n    }).join('');\n}\n\nfunction tsToDate(ts) {\n    const ms = Math.floor(ts / 1000000);\n    const d = new Date(ms);\n    return d.toISOString().split('T')[0];\n}\n\nasync function loadCoverage() {\n    const res = await fetch('/api/secmaster/symbols_coverage');\n    const data = await res.json();\n    coverageData = data.symbols || [];\n    const rtypeSet = new Set();\n    coverageData.forEach(row =&gt; rtypeSet.add(row.rtype));\n    availableRtypes = Array.from(rtypeSet).sort((a, b) =&gt; a - b);\n    populateBarPeriodDropdown();\n}\n\nfunction populateBarPeriodDropdown() {\n    const sel = document.getElementById('bar-period');\n    sel.innerHTML = '&lt;option value=\"\"&gt;-- Select bar period --&lt;/option&gt;';\n    availableRtypes.forEach(rt =&gt; {\n        const label = RTYPE_LABELS[rt] || `rtype ${rt}`;\n        sel.innerHTML += `&lt;option value=\"${rt}\"&gt;${label}&lt;/option&gt;`;\n    });\n}\n\nfunction onBarPeriodChange() {\n    selectedSymbols = [];\n    selectedPublisherId = null;\n    symbolsForRtype = {};\n    symbolCoverageForRtype = {};\n    renderSelectedSymbols();\n    updateDateRange();\n    const rtype = document.getElementById('bar-period').value;\n    const section = document.getElementById('symbols-section');\n    const symbolSelection = document.getElementById('symbol-selection');\n    document.getElementById('publisher-name').value = '';\n    document.getElementById('publisher-dataset').innerHTML = '&lt;option value=\"\"&gt;-- Select Dataset --&lt;/option&gt;';\n    if (rtype) {\n        section.style.display = 'block';\n        loadPublishers();\n    } else {\n        section.style.display = 'none';\n    }\n    symbolSelection.style.display = 'none';\n    document.getElementById('symbol-search').value = '';\n    document.getElementById('search-results').innerHTML = '';\n}\n\nfunction getSelectedRtype() {\n    return parseInt(document.getElementById('bar-period').value) || null;\n}\n\nfunction searchSymbols() {\n    const query = document.getElementById('symbol-search').value.toLowerCase();\n    const container = document.getElementById('search-results');\n    const rtype = getSelectedRtype();\n    if (!query || !rtype) {\n        container.innerHTML = '';\n        return;\n    }\n    const symbols = symbolsForRtype[rtype] || [];\n    const matches = symbols.filter(s =&gt; s.toLowerCase().includes(query) &amp;&amp; !selectedSymbols.includes(s)).slice(0, 20);\n    container.innerHTML = matches.map(s =&gt;\n        `&lt;div class=\"search-result\" onclick=\"addSymbol('${s}')\"&gt;&lt;span class=\"symbol\"&gt;${s}&lt;/span&gt;&lt;/div&gt;`\n    ).join('');\n}\n\nfunction addSymbol(symbol) {\n    if (!selectedSymbols.includes(symbol)) {\n        selectedSymbols.push(symbol);\n        document.getElementById('preset-select').value = '';\n        renderSelectedSymbols();\n        updateDateRange();\n    }\n    document.getElementById('symbol-search').value = '';\n    document.getElementById('search-results').innerHTML = '';\n}\n\nfunction removeSymbol(symbol) {\n    selectedSymbols = selectedSymbols.filter(s =&gt; s !== symbol);\n    document.getElementById('preset-select').value = '';\n    renderSelectedSymbols();\n    updateDateRange();\n}\n\nfunction renderSelectedSymbols() {\n    const container = document.getElementById('selected-symbols');\n    document.getElementById('selected-label').textContent = `Selected (${selectedSymbols.length}):`;\n    container.innerHTML = selectedSymbols.map(s =&gt;\n        `&lt;span class=\"selected-tag\"&gt;${s}&lt;span class=\"remove\" onclick=\"removeSymbol('${s}')\"&gt;&amp;times;&lt;/span&gt;&lt;/span&gt;`\n    ).join('');\n    updateButtonStates();\n}\n\nfunction renderSelectedSymbolsKeepPreset() {\n    const container = document.getElementById('selected-symbols');\n    document.getElementById('selected-label').textContent = `Selected (${selectedSymbols.length}):`;\n    container.innerHTML = selectedSymbols.map(s =&gt;\n        `&lt;span class=\"selected-tag\"&gt;${s}&lt;span class=\"remove\" onclick=\"removeSymbol('${s}')\"&gt;&amp;times;&lt;/span&gt;&lt;/span&gt;`\n    ).join('');\n    updateButtonStates();\n}\n\nfunction updateDateRange() {\n    const startInput = document.getElementById('start-date');\n    const endInput = document.getElementById('end-date');\n    const rtype = getSelectedRtype();\n    if (selectedSymbols.length === 0 || !rtype) {\n        globalMinDate = null;\n        globalMaxDate = null;\n        startInput.value = '';\n        endInput.value = '';\n        startInput.removeAttribute('min');\n        startInput.removeAttribute('max');\n        endInput.removeAttribute('min');\n        endInput.removeAttribute('max');\n        return;\n    }\n    const coverage = symbolCoverageForRtype[rtype] || {};\n    let minTs = null, maxTs = null;\n    selectedSymbols.forEach(s =&gt; {\n        const cov = coverage[s];\n        if (cov) {\n            if (minTs === null || cov.min_ts &lt; minTs) minTs = cov.min_ts;\n            if (maxTs === null || cov.max_ts &gt; maxTs) maxTs = cov.max_ts;\n        }\n    });\n    if (minTs === null) return;\n    globalMinDate = tsToDate(minTs);\n    globalMaxDate = tsToDate(maxTs);\n    startInput.min = globalMinDate;\n    startInput.max = globalMaxDate;\n    startInput.value = globalMinDate;\n    endInput.min = globalMinDate;\n    endInput.max = globalMaxDate;\n    endInput.value = globalMaxDate;\n}\n\nfunction clampDate(inputId) {\n    if (!globalMinDate || !globalMaxDate) return;\n    const input = document.getElementById(inputId);\n    if (input.value &lt; globalMinDate) input.value = globalMinDate;\n    if (input.value &gt; globalMaxDate) input.value = globalMaxDate;\n}\n\nfunction collectParams() {\n    const result = {};\n    strategyParams.forEach(p =&gt; {\n        const el = document.getElementById(`sp_${p.name}`);\n        if (!el) return;\n        if (p.type === 'bool') result[p.name] = el.checked;\n        else if (p.type === 'int') result[p.name] = parseInt(el.value);\n        else if (p.type === 'float') result[p.name] = parseFloat(el.value);\n        else result[p.name] = el.value;\n    });\n    return result;\n}\n\nasync function loadDbRuns() {\n    const res = await fetch('/api/runs');\n    const data = await res.json();\n    dbRuns = data.runs || [];\n    renderRuns();\n}\n\nfunction toggleRunSelection(runId) {\n    if (selectedRunIds.has(runId)) {\n        selectedRunIds.delete(runId);\n    } else {\n        selectedRunIds.add(runId);\n    }\n    renderRuns();\n}\n\nfunction toggleSelectAll() {\n    const allDbRunIds = dbRuns.map(r =&gt; r.run_id);\n    if (selectedRunIds.size === allDbRunIds.length &amp;&amp; allDbRunIds.length &gt; 0) {\n        selectedRunIds.clear();\n    } else {\n        allDbRunIds.forEach(id =&gt; selectedRunIds.add(id));\n    }\n    renderRuns();\n}\n\nasync function deleteSelectedRuns() {\n    if (selectedRunIds.size === 0) return;\n    if (!confirm(`Delete ${selectedRunIds.size} run(s)? This cannot be undone.`)) return;\n    const res = await fetch('/api/runs', {\n        method: 'DELETE',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({run_ids: Array.from(selectedRunIds)})\n    });\n    if (res.ok) {\n        selectedRunIds.clear();\n        await loadDbRuns();\n    } else {\n        alert('Failed to delete runs');\n    }\n}\n\nfunction renderRuns() {\n    const container = document.getElementById('runs-list');\n    const activeRunIds = Object.keys(activeRuns).filter(id =&gt; activeRuns[id].status === 'running');\n    const allDbRunIds = dbRuns.map(r =&gt; r.run_id);\n    const allSelected = allDbRunIds.length &gt; 0 &amp;&amp; selectedRunIds.size === allDbRunIds.length;\n\n    let html = '';\n    if (dbRuns.length &gt; 0 || activeRunIds.length &gt; 0) {\n        html += `&lt;div class=\"runs-toolbar\"&gt;\n            &lt;label class=\"select-all-label\"&gt;\n                &lt;input type=\"checkbox\" ${allSelected ? 'checked' : ''} onchange=\"toggleSelectAll()\"&gt;\n                Select all\n            &lt;/label&gt;\n            &lt;button class=\"btn-delete\" ${selectedRunIds.size === 0 ? 'disabled' : ''} onclick=\"deleteSelectedRuns()\"&gt;\n                Delete (${selectedRunIds.size})\n            &lt;/button&gt;\n        &lt;/div&gt;`;\n    }\n\n    activeRunIds.forEach(id =&gt; {\n        const run = activeRuns[id];\n        const progress = run.progress;\n        html += `&lt;div class=\"run-item\"&gt;\n            &lt;div class=\"run-content\"&gt;\n                &lt;div class=\"run-header\"&gt;\n                    &lt;span class=\"run-name\"&gt;${run.strategy}&lt;/span&gt;\n                    &lt;span class=\"run-status running\"&gt;running&lt;/span&gt;\n                &lt;/div&gt;\n                &lt;div class=\"run-meta with-progress\"&gt;${run.symbols.length} symbol${run.symbols.length !== 1 ? 's' : ''} \u00b7 ${run.startDate || 'all'} to ${run.endDate || 'all'}&lt;/div&gt;\n                &lt;div class=\"progress-bar\"&gt;&lt;div class=\"progress-fill\" style=\"width: ${progress}%\"&gt;&lt;/div&gt;&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;`;\n    });\n\n    dbRuns.forEach(r =&gt; {\n        const config = r.config || {};\n        const strategies = config.strategies ? config.strategies.join(', ') : r.name;\n        const symbols = config.symbols || [];\n        const symbolCount = symbols.length;\n        const startDate = config.start_date || '-';\n        const endDate = config.end_date || '-';\n        const timePart = r.run_id.slice(11, 19).replace(/-/g, ':');\n        const isSelected = selectedRunIds.has(r.run_id);\n        const statusClass = r.status;\n        const clickable = r.status === 'completed' ? `onclick=\"goToPerformance('${r.run_id}')\"` : '';\n        const clickableClass = r.status === 'completed' ? 'clickable' : '';\n        html += `&lt;div class=\"run-item ${isSelected ? 'selected' : ''}\"&gt;\n            &lt;input type=\"checkbox\" class=\"run-checkbox\" ${isSelected ? 'checked' : ''} onchange=\"toggleRunSelection('${r.run_id}')\"&gt;\n            &lt;div class=\"run-content ${clickableClass}\" ${clickable}&gt;\n                &lt;div class=\"run-header\"&gt;\n                    &lt;span class=\"run-name\"&gt;${strategies} &lt;span class=\"run-id\"&gt;${timePart}&lt;/span&gt;&lt;/span&gt;\n                    &lt;span class=\"run-status ${statusClass}\"&gt;${r.status}&lt;/span&gt;\n                &lt;/div&gt;\n                &lt;div class=\"run-meta\"&gt;${symbolCount} symbol${symbolCount !== 1 ? 's' : ''} \u00b7 ${startDate} to ${endDate}&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;`;\n    });\n\n    if (html === '') {\n        html = '&lt;div class=\"empty-runs\"&gt;&lt;p&gt;No runs yet&lt;/p&gt;&lt;p&gt;Configure settings and click Run Backtest&lt;/p&gt;&lt;/div&gt;';\n    }\n    container.innerHTML = html;\n}\n\nasync function runBacktest() {\n    const btn = document.getElementById('run-btn');\n    const rtype = getSelectedRtype();\n    if (!rtype) {\n        alert('Please select a bar period');\n        return;\n    }\n    if (!selectedPublisherId) {\n        alert('Please select a publisher and dataset');\n        return;\n    }\n    if (selectedSymbols.length === 0) {\n        alert('Please select at least one symbol');\n        return;\n    }\n    btn.disabled = true;\n\n    const strategy = document.getElementById('strategy').value;\n    const startDate = document.getElementById('start-date').value || null;\n    const endDate = document.getElementById('end-date').value || null;\n    const barPeriod = RTYPE_LABELS[rtype] || 'Unknown';\n\n    const payload = {\n        strategy: strategy,\n        strategy_params: collectParams(),\n        symbols: selectedSymbols,\n        rtype: rtype,\n        publisher_id: selectedPublisherId,\n        start_date: startDate,\n        end_date: endDate\n    };\n\n    try {\n        const res = await fetch('/api/backtest/run', {\n            method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload)\n        });\n        const data = await res.json();\n        if (!res.ok) throw new Error(data.detail || 'Failed to start backtest');\n        const runId = data.run_id;\n\n        activeRuns[runId] = {\n            strategy: strategy,\n            symbols: [...selectedSymbols],\n            barPeriod: barPeriod,\n            startDate: startDate,\n            endDate: endDate,\n            status: 'running',\n            progress: 10\n        };\n        renderRuns();\n        btn.disabled = false;\n\n        let progress = 10;\n        const poll = setInterval(async () =&gt; {\n            const r = await fetch(`/api/backtest/status/${runId}`);\n            const d = await r.json();\n            if (d.status === 'completed') {\n                clearInterval(poll);\n                delete activeRuns[runId];\n                await loadDbRuns();\n            } else if (d.status.startsWith('error')) {\n                clearInterval(poll);\n                delete activeRuns[runId];\n                await loadDbRuns();\n            } else {\n                progress = Math.min(progress + 5, 90);\n                activeRuns[runId].progress = progress;\n                renderRuns();\n            }\n        }, 1000);\n    } catch (e) {\n        alert(`Error: ${e.message}`);\n        btn.disabled = false;\n    }\n}\n\nfunction goToPerformance(runId) {\n    window.location.href = `/performance?run_id=${runId}`;\n}\n\ndocument.addEventListener('DOMContentLoaded', () =&gt; {\n    loadStrategies();\n    loadCoverage();\n    loadDbRuns();\n});\n\"\"\"\n\nPERFORMANCE_CSS = \"\"\"\n.container { max-width: none; height: 100vh; padding: 24px; display: flex; flex-direction: column; box-sizing: border-box; }\n.performance-layout { display: flex; gap: 24px; flex: 1; min-height: 0; }\n.performance-left { flex: 1; min-width: 0; display: flex; flex-direction: column; }\n.performance-right { flex: 3; min-width: 0; display: flex; flex-direction: column; overflow-y: auto; }\n.performance-left .card { flex: 1; display: flex; flex-direction: column; margin-bottom: 0; min-height: 0; }\n.performance-right .card { display: flex; flex-direction: column; margin-bottom: 0; }\n.performance-left .runs-list { flex: 1; overflow-y: auto; }\n.runs-list { display: flex; flex-direction: column; gap: 8px; }\n.run-item { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; cursor: pointer; }\n.run-item:hover { border-color: #58a6ff; }\n.run-item.selected { border-color: #58a6ff; background: #161b22; }\n.run-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }\n.run-name { font-family: monospace; font-size: 13px; color: #e6edf3; }\n.run-id { color: #8b949e; font-size: 11px; margin-left: 6px; }\n.run-status { font-size: 12px; font-weight: 500; padding: 2px 8px; border-radius: 10px; }\n.run-status.completed { background: #238636; color: #fff; }\n.run-status.failed { background: #da3633; color: #fff; }\n.run-status.error { background: #da3633; color: #fff; }\n.run-meta { font-size: 12px; color: #8b949e; }\n.empty-runs { text-align: center; padding: 48px 24px; color: #8b949e; }\n.empty-runs p { font-size: 14px; }\n.empty-content { text-align: center; padding: 48px 24px; color: #8b949e; }\n.empty-content p { font-size: 14px; }\n.search-bar { margin-bottom: 16px; }\n.search-bar input { width: 100%; padding: 8px 12px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #e6edf3; font-size: 14px; }\n.search-bar input:focus { outline: none; border-color: #58a6ff; }\n.search-bar input::placeholder { color: #8b949e; }\n.roundtrips-table-container { }\n.roundtrips-table { width: 100%; border-collapse: collapse; font-size: 13px; }\n.roundtrips-table th { position: sticky; top: 0; background: #161b22; padding: 10px 12px; text-align: left; color: #8b949e; font-weight: 500; border-bottom: 1px solid #30363d; cursor: pointer; user-select: none; white-space: nowrap; }\n.roundtrips-table th:hover { color: #e6edf3; }\n.roundtrips-table th .sort-icon { margin-left: 4px; opacity: 0.5; }\n.roundtrips-table th.sorted .sort-icon { opacity: 1; }\n.roundtrips-table td { padding: 10px 12px; border-bottom: 1px solid #21262d; color: #e6edf3; white-space: nowrap; }\n.roundtrips-table tr:hover td { background: #21262d; }\n.roundtrips-table .symbol { font-family: monospace; }\n.roundtrips-table .direction { font-weight: 500; }\n.roundtrips-table .direction.long { color: #3fb950; }\n.roundtrips-table .direction.short { color: #f85149; }\n.roundtrips-table .pnl { font-weight: 500; font-family: monospace; }\n.roundtrips-table .pnl.positive { color: #3fb950; }\n.roundtrips-table .pnl.negative { color: #f85149; }\n.roundtrips-table .number { font-family: monospace; text-align: right; }\n.empty-table { text-align: center; padding: 48px 24px; color: #8b949e; }\n.roundtrips-table tr.data-row { cursor: pointer; }\n.roundtrips-table tr.chart-row { display: none; }\n.roundtrips-table tr.chart-row.expanded { display: table-row; }\n.roundtrips-table tr.chart-row td { padding: 16px; background: #0d1117; }\n.chart-container { position: relative; text-align: center; }\n.chart-container img { max-width: 100%; height: auto; border-radius: 4px; }\n.chart-loading { color: #8b949e; padding: 48px; }\n.pnl-summary-container { margin-bottom: 16px; text-align: center; }\n.pnl-summary-container img { max-width: 100%; height: auto; border-radius: 4px; background: #fff; }\n.pnl-summary-loading { color: #8b949e; padding: 24px; }\n.trade-journey-container { margin-bottom: 16px; text-align: center; }\n.trade-journey-container img { max-width: 100%; height: auto; border-radius: 4px; background: #fff; }\n.trade-journey-loading { color: #8b949e; padding: 24px; }\n.trade-journey-message { color: #8b949e; padding: 24px; font-style: italic; }\n\"\"\"\n\nPERFORMANCE_JS = \"\"\"\nlet runs = [];\nlet selectedRunId = null;\nlet roundtrips = [];\nlet filteredRoundtrips = [];\nlet sortColumn = 'symbol';\nlet sortAsc = true;\n\nfunction getUrlRunId() {\n    const params = new URLSearchParams(window.location.search);\n    return params.get('run_id');\n}\n\nasync function loadRuns() {\n    const res = await fetch('/api/runs');\n    const data = await res.json();\n    runs = (data.runs || []).filter(r =&gt; r.status === 'completed');\n    renderRuns();\n    const urlRunId = getUrlRunId();\n    if (urlRunId &amp;&amp; runs.some(r =&gt; r.run_id === urlRunId)) {\n        selectRun(urlRunId);\n    }\n}\n\nfunction selectRun(runId) {\n    selectedRunId = runId;\n    const url = new URL(window.location);\n    url.searchParams.set('run_id', runId);\n    window.history.replaceState({}, '', url);\n    renderRuns();\n    loadPerformance(runId);\n}\n\nfunction renderRuns() {\n    const container = document.getElementById('runs-list');\n    if (runs.length === 0) {\n        container.innerHTML = '&lt;div class=\"empty-runs\"&gt;&lt;p&gt;No completed runs&lt;/p&gt;&lt;/div&gt;';\n        return;\n    }\n    container.innerHTML = runs.map(r =&gt; {\n        const config = r.config || {};\n        const strategies = config.strategies ? config.strategies.join(', ') : r.name;\n        const symbols = config.symbols || [];\n        const symbolCount = symbols.length;\n        const startDate = config.start_date || '-';\n        const endDate = config.end_date || '-';\n        const timePart = r.run_id.slice(11, 19).replace(/-/g, ':');\n        const isSelected = r.run_id === selectedRunId;\n        return `&lt;div class=\"run-item ${isSelected ? 'selected' : ''}\" onclick=\"selectRun('${r.run_id}')\"&gt;\n            &lt;div class=\"run-header\"&gt;\n                &lt;span class=\"run-name\"&gt;${strategies} &lt;span class=\"run-id\"&gt;${timePart}&lt;/span&gt;&lt;/span&gt;\n                &lt;span class=\"run-status ${r.status}\"&gt;${r.status}&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"run-meta\"&gt;${symbolCount} symbol${symbolCount !== 1 ? 's' : ''} \u00b7 ${startDate} to ${endDate}&lt;/div&gt;\n        &lt;/div&gt;`;\n    }).join('');\n}\n\nasync function loadPerformance(runId) {\n    const container = document.getElementById('performance-content');\n    container.innerHTML = '&lt;div class=\"empty-content\"&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;/div&gt;';\n    const res = await fetch(`/api/runs/${runId}/roundtrips`);\n    const data = await res.json();\n    roundtrips = data.roundtrips || [];\n    const tradeNums = {};\n    roundtrips.forEach(rt =&gt; {\n        tradeNums[rt.symbol] = (tradeNums[rt.symbol] || 0) + 1;\n        rt.trade_num = tradeNums[rt.symbol];\n    });\n    filteredRoundtrips = [...roundtrips];\n    sortColumn = 'symbol';\n    sortAsc = true;\n    document.getElementById('symbol-filter').value = '';\n    updatePerformanceCharts();\n    sortAndRender();\n}\n\nfunction updatePerformanceCharts() {\n    const pnlContainer = document.getElementById('pnl-summary-container');\n    const journeyContainer = document.getElementById('trade-journey-container');\n    if (!selectedRunId) {\n        pnlContainer.innerHTML = '';\n        journeyContainer.innerHTML = '';\n        return;\n    }\n    const allSymbols = [...new Set(roundtrips.map(rt =&gt; rt.symbol))];\n    const symbols = [...new Set(filteredRoundtrips.map(rt =&gt; rt.symbol))];\n    if (symbols.length !== 1 &amp;&amp; allSymbols.length !== 1) {\n        pnlContainer.innerHTML = '';\n        journeyContainer.innerHTML = '&lt;div class=\"trade-journey-message\"&gt;Filter by symbol to see per-symbol Performance Statistics&lt;/div&gt;';\n        return;\n    }\n    const symbol = symbols.length === 1 ? symbols[0] : allSymbols[0];\n\n    pnlContainer.innerHTML = '&lt;div class=\"pnl-summary-loading\"&gt;Loading PnL Summary chart...&lt;/div&gt;';\n    const pnlUrl = `/api/runs/${selectedRunId}/pnl-summary.png?symbol=${encodeURIComponent(symbol)}`;\n    const pnlImg = new Image();\n    pnlImg.onload = () =&gt; {\n        pnlContainer.innerHTML = '';\n        pnlContainer.appendChild(pnlImg);\n    };\n    pnlImg.onerror = () =&gt; {\n        pnlContainer.innerHTML = '&lt;div class=\"pnl-summary-loading\"&gt;Failed to load PnL Summary chart&lt;/div&gt;';\n    };\n    pnlImg.src = pnlUrl;\n    pnlImg.alt = 'PnL Summary Chart';\n\n    journeyContainer.innerHTML = '&lt;div class=\"trade-journey-loading\"&gt;Loading Trade Journey chart...&lt;/div&gt;';\n    const journeyUrl = `/api/runs/${selectedRunId}/trade-journey.png?symbol=${encodeURIComponent(symbol)}`;\n    const journeyImg = new Image();\n    journeyImg.onload = () =&gt; {\n        journeyContainer.innerHTML = '';\n        journeyContainer.appendChild(journeyImg);\n    };\n    journeyImg.onerror = () =&gt; {\n        journeyContainer.innerHTML = '&lt;div class=\"trade-journey-loading\"&gt;Failed to load Trade Journey chart&lt;/div&gt;';\n    };\n    journeyImg.src = journeyUrl;\n    journeyImg.alt = 'Trade Journey Chart';\n}\n\nfunction filterRoundtrips() {\n    const query = document.getElementById('symbol-filter').value.toLowerCase().trim();\n    if (!query) {\n        filteredRoundtrips = [...roundtrips];\n    } else {\n        const terms = query.split(/[,\\\\s]+/).filter(t =&gt; t.length &gt; 0);\n        filteredRoundtrips = roundtrips.filter(rt =&gt;\n            terms.some(term =&gt; rt.symbol.toLowerCase().includes(term))\n        );\n    }\n    updatePerformanceCharts();\n    sortAndRender();\n}\n\nfunction sortBy(column) {\n    if (sortColumn === column) {\n        sortAsc = !sortAsc;\n    } else {\n        sortColumn = column;\n        sortAsc = true;\n    }\n    sortAndRender();\n}\n\nfunction sortAndRender() {\n    filteredRoundtrips.sort((a, b) =&gt; {\n        let valA = a[sortColumn];\n        let valB = b[sortColumn];\n        if (typeof valA === 'string') {\n            valA = valA.toLowerCase();\n            valB = valB.toLowerCase();\n        }\n        if (valA &lt; valB) return sortAsc ? -1 : 1;\n        if (valA &gt; valB) return sortAsc ? 1 : -1;\n        return 0;\n    });\n    renderTable();\n}\n\nfunction renderTable() {\n    const container = document.getElementById('performance-content');\n    if (roundtrips.length === 0) {\n        container.innerHTML = '&lt;div class=\"empty-table\"&gt;&lt;p&gt;No round-trip trades found&lt;/p&gt;&lt;/div&gt;';\n        return;\n    }\n    const columns = [\n        {key: 'symbol', label: 'Symbol'},\n        {key: 'trade_num', label: '#'},\n        {key: 'direction', label: 'Direction'},\n        {key: 'duration_bars', label: 'Bars'},\n        {key: 'max_position', label: 'Max Position'},\n        {key: 'high_watermark', label: 'High Watermark'},\n        {key: 'low_watermark', label: 'Low Watermark'},\n        {key: 'max_drawdown', label: 'Max Drawdown'},\n        {key: 'pnl_before_commission', label: 'PnL (Gross)'},\n        {key: 'pnl_after_commission', label: 'PnL (Net)'},\n    ];\n    const headerHtml = columns.map(c =&gt; {\n        const isSorted = sortColumn === c.key;\n        const arrow = isSorted ? (sortAsc ? '\u25b2' : '\u25bc') : '\u25b2';\n        return `&lt;th class=\"${isSorted ? 'sorted' : ''}\" onclick=\"sortBy('${c.key}')\"&gt;${c.label}&lt;span class=\"sort-icon\"&gt;${arrow}&lt;/span&gt;&lt;/th&gt;`;\n    }).join('');\n    const rowsHtml = filteredRoundtrips.map((rt, idx) =&gt; {\n        const dirClass = rt.direction.toLowerCase();\n        const pnlGrossClass = rt.pnl_before_commission &gt;= 0 ? 'positive' : 'negative';\n        const pnlNetClass = rt.pnl_after_commission &gt;= 0 ? 'positive' : 'negative';\n        const pnlGrossSign = rt.pnl_before_commission &gt;= 0 ? '+' : '';\n        const pnlNetSign = rt.pnl_after_commission &gt;= 0 ? '+' : '';\n        const hwmClass = rt.high_watermark &gt;= 0 ? 'positive' : 'negative';\n        const hwmSign = rt.high_watermark &gt;= 0 ? '+' : '';\n        const lwmClass = rt.low_watermark &gt;= 0 ? 'positive' : 'negative';\n        const lwmSign = rt.low_watermark &gt;= 0 ? '+' : '';\n        const mddClass = rt.max_drawdown &gt; 0 ? 'negative' : '';\n        return `&lt;tr class=\"data-row\" onclick=\"toggleChart(${idx})\"&gt;\n            &lt;td class=\"symbol\"&gt;${rt.symbol}&lt;/td&gt;\n            &lt;td&gt;${rt.trade_num}&lt;/td&gt;\n            &lt;td class=\"direction ${dirClass}\"&gt;${rt.direction}&lt;/td&gt;\n            &lt;td&gt;${rt.duration_bars}&lt;/td&gt;\n            &lt;td&gt;${rt.max_position}&lt;/td&gt;\n            &lt;td class=\"pnl ${hwmClass}\"&gt;${hwmSign}${rt.high_watermark.toFixed(2)}&lt;/td&gt;\n            &lt;td class=\"pnl ${lwmClass}\"&gt;${lwmSign}${rt.low_watermark.toFixed(2)}&lt;/td&gt;\n            &lt;td class=\"pnl ${mddClass}\"&gt;${rt.max_drawdown &gt; 0 ? '-' : ''}${rt.max_drawdown.toFixed(2)}&lt;/td&gt;\n            &lt;td class=\"pnl ${pnlGrossClass}\"&gt;${pnlGrossSign}${rt.pnl_before_commission.toFixed(2)}&lt;/td&gt;\n            &lt;td class=\"pnl ${pnlNetClass}\"&gt;${pnlNetSign}${rt.pnl_after_commission.toFixed(2)}&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr class=\"chart-row\" id=\"chart-row-${idx}\"&gt;\n            &lt;td colspan=\"10\"&gt;\n                &lt;div class=\"chart-container\" id=\"chart-container-${idx}\"&gt;\n                    &lt;div class=\"chart-loading\"&gt;Loading chart...&lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/td&gt;\n        &lt;/tr&gt;`;\n    }).join('');\n    container.innerHTML = `\n        &lt;div class=\"roundtrips-table-container\"&gt;\n            &lt;table class=\"roundtrips-table\"&gt;\n                &lt;thead&gt;&lt;tr&gt;${headerHtml}&lt;/tr&gt;&lt;/thead&gt;\n                &lt;tbody&gt;${rowsHtml}&lt;/tbody&gt;\n            &lt;/table&gt;\n        &lt;/div&gt;\n    `;\n}\n\nconst chartCache = {};\n\nfunction toggleChart(idx) {\n    const chartRow = document.getElementById(`chart-row-${idx}`);\n    if (chartRow.classList.contains('expanded')) {\n        chartRow.classList.remove('expanded');\n        return;\n    }\n    chartRow.classList.add('expanded');\n    const rt = filteredRoundtrips[idx];\n    const container = document.getElementById(`chart-container-${idx}`);\n    const cacheKey = `${selectedRunId}_${rt.symbol}_${rt.entry_ts}_${rt.exit_ts}`;\n    if (chartCache[cacheKey]) {\n        container.innerHTML = `&lt;img src=\"${chartCache[cacheKey]}\" alt=\"Chart\"&gt;`;\n        return;\n    }\n    container.innerHTML = '&lt;div class=\"chart-loading\"&gt;Loading chart...&lt;/div&gt;';\n    const url = `/api/runs/${selectedRunId}/chart.png?symbol=${encodeURIComponent(rt.symbol)}&amp;start_ns=${rt.entry_ts}&amp;end_ns=${rt.exit_ts}&amp;direction=${rt.direction}&amp;pnl=${rt.pnl_after_commission}`;\n    const img = new Image();\n    img.onload = () =&gt; {\n        chartCache[cacheKey] = url;\n        container.innerHTML = '';\n        container.appendChild(img);\n    };\n    img.onerror = () =&gt; {\n        container.innerHTML = '&lt;div class=\"chart-loading\"&gt;Failed to load chart&lt;/div&gt;';\n    };\n    img.src = url;\n    img.alt = 'Chart';\n}\n\ndocument.addEventListener('DOMContentLoaded', () =&gt; {\n    loadRuns();\n});\n\"\"\"\n</code></pre>"},{"location":"reference/dashboard/styles/#onesecondtrader.dashboard.styles.BASE_CSS","title":"<code>BASE_CSS = '\\n* { margin: 0; padding: 0; box-sizing: border-box; }\\nbody {\\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\\n    background: #0d1117;\\n    color: #e6edf3;\\n    min-height: 100vh;\\n    display: flex;\\n}\\n.sidebar {\\n    width: 220px;\\n    background: #161b22;\\n    border-right: 1px solid #30363d;\\n    min-height: 100vh;\\n    position: fixed;\\n    left: 0;\\n    top: 0;\\n    display: flex;\\n    flex-direction: column;\\n}\\n.sidebar-header {\\n    padding: 20px 16px;\\n    border-bottom: 1px solid #30363d;\\n}\\n.sidebar-header h1 {\\n    font-size: 16px;\\n    font-weight: 600;\\n    color: #e6edf3;\\n}\\n.sidebar-nav {\\n    padding: 12px 8px;\\n    flex: 1;\\n}\\n.sidebar-nav a {\\n    display: flex;\\n    align-items: center;\\n    gap: 10px;\\n    padding: 10px 12px;\\n    color: #8b949e;\\n    text-decoration: none;\\n    font-size: 14px;\\n    border-radius: 6px;\\n    margin-bottom: 2px;\\n}\\n.sidebar-nav a:hover {\\n    background: #21262d;\\n    color: #e6edf3;\\n}\\n.sidebar-nav a.active {\\n    background: #21262d;\\n    color: #e6edf3;\\n}\\n.sidebar-nav svg {\\n    width: 16px;\\n    height: 16px;\\n    flex-shrink: 0;\\n}\\n.main-content {\\n    margin-left: 220px;\\n    flex: 1;\\n    min-height: 100vh;\\n}\\n.container {\\n    max-width: 1200px;\\n    margin: 0 auto;\\n    padding: 32px 24px;\\n}\\n.card {\\n    background: #161b22;\\n    border: 1px solid #30363d;\\n    border-radius: 8px;\\n    padding: 24px;\\n    margin-bottom: 16px;\\n}\\n.card h2 {\\n    font-size: 16px;\\n    font-weight: 600;\\n    margin-bottom: 16px;\\n    color: #e6edf3;\\n}\\n.empty-state {\\n    text-align: center;\\n    padding: 48px;\\n    color: #8b949e;\\n}\\n.empty-state p {\\n    margin-top: 8px;\\n    font-size: 14px;\\n}\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/styles/#onesecondtrader.dashboard.styles.BACKTEST_CSS","title":"<code>BACKTEST_CSS = '\\n.container { max-width: none; height: 100vh; padding: 24px; display: flex; flex-direction: column; box-sizing: border-box; }\\n.backtest-layout { display: flex; gap: 24px; flex: 1; min-height: 0; }\\n.backtest-left { flex: 1; min-width: 0; display: flex; flex-direction: column; }\\n.backtest-right { flex: 1; min-width: 0; display: flex; flex-direction: column; }\\n.backtest-left .card, .backtest-right .card { flex: 1; display: flex; flex-direction: column; margin-bottom: 0; overflow: hidden; }\\n.backtest-right .runs-list { flex: 1; overflow-y: auto; }\\n.form-group { margin-bottom: 16px; }\\n.form-group label { display: block; margin-bottom: 6px; font-size: 14px; color: #8b949e; }\\n.form-group select, .form-group input {\\n    width: 100%; padding: 8px 12px; background: #0d1117; border: 1px solid #30363d;\\n    border-radius: 6px; color: #e6edf3; font-size: 14px;\\n}\\n.form-group select:focus, .form-group input:focus { outline: none; border-color: #58a6ff; }\\n.params-container { margin-top: 12px; padding: 12px; background: #0d1117; border-radius: 6px; }\\n.param-row { display: flex; gap: 12px; margin-bottom: 8px; align-items: center; }\\n.param-row label { min-width: 120px; font-size: 13px; }\\n.param-row input, .param-row select { flex: 1; }\\n.btn { padding: 10px 20px; background: #238636; border: none; border-radius: 6px;\\n    color: #fff; font-size: 14px; cursor: pointer; width: 100%; }\\n.btn:hover { background: #2ea043; }\\n.btn:disabled { background: #30363d; cursor: not-allowed; }\\n.date-row { display: flex; gap: 12px; }\\n.date-row .form-group { flex: 1; margin-bottom: 0; }\\n.symbol-section { background: #0d1117; border-radius: 6px; padding: 12px; }\\n.publisher-row { display: flex; gap: 8px; margin-bottom: 12px; }\\n.publisher-row select { flex: 1; }\\n.preset-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: center; }\\n.preset-row select { flex: 1; }\\n.preset-row input { flex: 1; }\\n.preset-row .btn-sm { padding: 6px 12px; font-size: 12px; width: auto; cursor: not-allowed; }\\n.preset-row .btn-secondary { background: #30363d; }\\n.preset-row .btn-secondary.active { background: #238636; cursor: pointer; }\\n.preset-row .btn-secondary.active:hover { background: #2ea043; }\\n.preset-row .btn-danger { background: #30363d; }\\n.preset-row .btn-danger.active { background: #da3633; cursor: pointer; }\\n.preset-row .btn-danger.active:hover { background: #f85149; }\\n.search-row { display: flex; gap: 8px; margin-bottom: 8px; }\\n.search-row input { flex: 1; }\\n.search-results { max-height: 150px; overflow-y: auto; border: 1px solid #30363d; border-radius: 4px; margin-bottom: 12px; }\\n.search-results:empty { display: none; }\\n.search-result { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; border-bottom: 1px solid #21262d; cursor: pointer; }\\n.search-result:last-child { border-bottom: none; }\\n.search-result:hover { background: #161b22; }\\n.search-result .symbol { font-family: monospace; }\\n.selected-symbols { display: flex; flex-wrap: wrap; gap: 6px; min-height: 32px; max-height: 150px; overflow-y: auto; }\\n.selected-tag { display: inline-flex; align-items: center; gap: 4px; background: #238636; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-family: monospace; }\\n.selected-tag .remove { cursor: pointer; opacity: 0.7; }\\n.selected-tag .remove:hover { opacity: 1; }\\n.selected-label { font-size: 13px; color: #8b949e; margin-bottom: 6px; }\\n.section-header { font-size: 14px; color: #8b949e; margin-bottom: 6px; margin-top: 8px; }\\n.runs-list { display: flex; flex-direction: column; gap: 12px; }\\n.run-item { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; display: flex; gap: 12px; align-items: flex-start; }\\n.run-item.selected { border-color: #58a6ff; }\\n.run-checkbox { flex-shrink: 0; margin-top: 2px; width: 16px; height: 16px; accent-color: #58a6ff; cursor: pointer; }\\n.run-content { flex: 1; min-width: 0; }\\n.run-content.clickable { cursor: pointer; }\\n.run-content.clickable:hover { opacity: 0.8; }\\n.run-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }\\n.run-name { font-family: monospace; font-size: 13px; color: #e6edf3; }\\n.run-id { color: #8b949e; font-size: 11px; margin-left: 6px; }\\n.run-status { font-size: 12px; font-weight: 500; padding: 2px 8px; border-radius: 10px; }\\n.run-status.running { background: #9e6a03; color: #fff; }\\n.run-status.completed { background: #238636; color: #fff; }\\n.run-status.failed { background: #da3633; color: #fff; }\\n.run-status.cancelled { background: #30363d; color: #8b949e; }\\n.run-status.error { background: #da3633; color: #fff; }\\n.run-meta { font-size: 12px; color: #8b949e; }\\n.run-meta.with-progress { margin-bottom: 8px; }\\n.progress-bar { height: 6px; background: #30363d; border-radius: 3px; overflow: hidden; }\\n.progress-fill { height: 100%; background: #58a6ff; transition: width 0.3s ease; }\\n.progress-fill.completed { background: #238636; }\\n.progress-fill.error { background: #da3633; }\\n.empty-runs { text-align: center; padding: 48px 24px; color: #8b949e; }\\n.empty-runs p { font-size: 14px; }\\n.runs-toolbar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #30363d; }\\n.runs-toolbar .select-all-label { display: flex; align-items: center; gap: 8px; font-size: 13px; color: #8b949e; cursor: pointer; }\\n.runs-toolbar .select-all-label input { width: 16px; height: 16px; accent-color: #58a6ff; cursor: pointer; }\\n.btn-delete { padding: 6px 12px; background: #da3633; border: none; border-radius: 6px; color: #fff; font-size: 13px; cursor: pointer; }\\n.btn-delete:hover { background: #f85149; }\\n.btn-delete:disabled { background: #30363d; cursor: not-allowed; color: #8b949e; }\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/styles/#onesecondtrader.dashboard.styles.BACKTEST_JS","title":"<code>BACKTEST_JS = '\\nlet strategyParams = [];\\nlet coverageData = [];\\nlet availableRtypes = [];\\nlet symbolsForRtype = {};\\nlet symbolCoverageForRtype = {};\\nlet selectedSymbols = [];\\nlet presets = [];\\nlet globalMinDate = null;\\nlet globalMaxDate = null;\\nlet dbRuns = [];\\nlet activeRuns = {};\\nlet selectedRunIds = new Set();\\nlet publishers = [];\\nlet datasets = [];\\nlet selectedPublisherId = null;\\n\\nconst RTYPE_LABELS = {32: \\'Second\\', 33: \\'Minute\\', 34: \\'Hour\\', 35: \\'Day\\'};\\n\\nfunction capitalize(str) {\\n    return str.charAt(0).toUpperCase() + str.slice(1);\\n}\\n\\nasync function loadPublishers() {\\n    const rtype = getSelectedRtype();\\n    const url = rtype ? `/api/secmaster/publishers?rtype=${rtype}` : \\'/api/secmaster/publishers\\';\\n    const res = await fetch(url);\\n    const data = await res.json();\\n    publishers = data.publishers || [];\\n    const sel = document.getElementById(\\'publisher-name\\');\\n    sel.innerHTML = \\'&lt;option value=\"\"&gt;-- Select Publisher --&lt;/option&gt;\\';\\n    publishers.forEach(p =&gt; sel.innerHTML += `&lt;option value=\"${p}\"&gt;${capitalize(p)}&lt;/option&gt;`);\\n}\\n\\nasync function onPublisherChange() {\\n    const name = document.getElementById(\\'publisher-name\\').value;\\n    const rtype = getSelectedRtype();\\n    const datasetSel = document.getElementById(\\'publisher-dataset\\');\\n    datasetSel.innerHTML = \\'&lt;option value=\"\"&gt;-- Select Dataset --&lt;/option&gt;\\';\\n    datasets = [];\\n    selectedPublisherId = null;\\n    document.getElementById(\\'symbol-selection\\').style.display = \\'none\\';\\n    selectedSymbols = [];\\n    renderSelectedSymbols();\\n    updateDateRange();\\n    if (!name) return;\\n    const url = rtype\\n        ? `/api/secmaster/publishers/${encodeURIComponent(name)}/datasets?rtype=${rtype}`\\n        : `/api/secmaster/publishers/${encodeURIComponent(name)}/datasets`;\\n    const res = await fetch(url);\\n    const data = await res.json();\\n    datasets = data.datasets || [];\\n    datasets.forEach(d =&gt; datasetSel.innerHTML += `&lt;option value=\"${d.publisher_id}\"&gt;${d.dataset}&lt;/option&gt;`);\\n}\\n\\nasync function onDatasetChange() {\\n    const pubId = document.getElementById(\\'publisher-dataset\\').value;\\n    selectedPublisherId = pubId ? parseInt(pubId) : null;\\n    selectedSymbols = [];\\n    renderSelectedSymbols();\\n    updateDateRange();\\n    document.getElementById(\\'symbol-search\\').value = \\'\\';\\n    document.getElementById(\\'search-results\\').innerHTML = \\'\\';\\n    if (selectedPublisherId) {\\n        await loadCoverageForPublisher(selectedPublisherId);\\n        document.getElementById(\\'symbol-selection\\').style.display = \\'block\\';\\n        await loadPresets();\\n    } else {\\n        document.getElementById(\\'symbol-selection\\').style.display = \\'none\\';\\n    }\\n}\\n\\nasync function loadCoverageForPublisher(publisherId) {\\n    const rtype = getSelectedRtype();\\n    const url = `/api/secmaster/symbols_coverage?publisher_id=${publisherId}&amp;rtype=${rtype}`;\\n    const res = await fetch(url);\\n    const data = await res.json();\\n    coverageData = data.symbols || [];\\n    symbolsForRtype = {};\\n    symbolCoverageForRtype = {};\\n    coverageData.forEach(row =&gt; {\\n        if (!symbolsForRtype[row.rtype]) {\\n            symbolsForRtype[row.rtype] = [];\\n            symbolCoverageForRtype[row.rtype] = {};\\n        }\\n        symbolsForRtype[row.rtype].push(row.symbol);\\n        symbolCoverageForRtype[row.rtype][row.symbol] = {min_ts: row.min_ts, max_ts: row.max_ts};\\n    });\\n}\\n\\nasync function loadPresets() {\\n    const res = await fetch(\\'/api/presets\\');\\n    const data = await res.json();\\n    presets = data.presets || [];\\n    await filterAndRenderPresets();\\n}\\n\\nasync function filterAndRenderPresets() {\\n    const sel = document.getElementById(\\'preset-select\\');\\n    sel.innerHTML = \\'&lt;option value=\"\"&gt;-- Select Preset --&lt;/option&gt;\\';\\n    const rtype = getSelectedRtype();\\n    const availableSymbols = symbolsForRtype[rtype] || [];\\n    for (const p of presets) {\\n        const res = await fetch(`/api/presets/${encodeURIComponent(p)}`);\\n        const data = await res.json();\\n        const hasAvailable = (data.symbols || []).some(s =&gt; availableSymbols.includes(s));\\n        if (hasAvailable) {\\n            sel.innerHTML += `&lt;option value=\"${p}\"&gt;${p}&lt;/option&gt;`;\\n        }\\n    }\\n    updateButtonStates();\\n}\\n\\nasync function loadPreset() {\\n    const name = document.getElementById(\\'preset-select\\').value;\\n    updateButtonStates();\\n    if (!name) {\\n        selectedSymbols = [];\\n        renderSelectedSymbols();\\n        updateDateRange();\\n        return;\\n    }\\n    const rtype = getSelectedRtype();\\n    const symbols = symbolsForRtype[rtype] || [];\\n    const res = await fetch(`/api/presets/${encodeURIComponent(name)}`);\\n    const data = await res.json();\\n    if (data.symbols) {\\n        selectedSymbols = data.symbols.filter(s =&gt; symbols.includes(s));\\n        renderSelectedSymbolsKeepPreset();\\n        updateDateRange();\\n    }\\n}\\n\\nasync function savePreset() {\\n    const nameInput = document.getElementById(\\'preset-name\\');\\n    const name = nameInput.value.trim();\\n    if (!name) { alert(\\'Enter a preset name\\'); return; }\\n    if (selectedSymbols.length === 0) { alert(\\'Select at least one symbol\\'); return; }\\n    const exists = presets.includes(name);\\n    const method = exists ? \\'PUT\\' : \\'POST\\';\\n    const url = exists ? `/api/presets/${encodeURIComponent(name)}` : \\'/api/presets\\';\\n    await fetch(url, {\\n        method, headers: {\\'Content-Type\\': \\'application/json\\'},\\n        body: JSON.stringify({name, symbols: selectedSymbols})\\n    });\\n    nameInput.value = \\'\\';\\n    await loadPresets();\\n    document.getElementById(\\'preset-select\\').value = name;\\n}\\n\\nasync function deletePreset() {\\n    const name = document.getElementById(\\'preset-select\\').value;\\n    if (!name) { alert(\\'Select a preset to delete\\'); return; }\\n    if (!confirm(`Delete preset \"${name}\"?`)) return;\\n    await fetch(`/api/presets/${encodeURIComponent(name)}`, {method: \\'DELETE\\'});\\n    await loadPresets();\\n    selectedSymbols = [];\\n    renderSelectedSymbols();\\n    updateDateRange();\\n}\\n\\nfunction updateButtonStates() {\\n    const runBtn = document.getElementById(\\'run-btn\\');\\n    const saveBtn = document.getElementById(\\'preset-save-btn\\');\\n    const deleteBtn = document.getElementById(\\'preset-delete-btn\\');\\n    const presetSelect = document.getElementById(\\'preset-select\\');\\n    const presetNameInput = document.getElementById(\\'preset-name\\');\\n    const strategyEl = document.getElementById(\\'strategy\\');\\n    const barPeriodEl = document.getElementById(\\'bar-period\\');\\n    if (!runBtn) return;\\n    const rtype = barPeriodEl ? parseInt(barPeriodEl.value) || null : null;\\n    const strategy = strategyEl ? strategyEl.value : \\'\\';\\n    const canRun = strategy &amp;&amp; rtype &amp;&amp; selectedPublisherId &amp;&amp; selectedSymbols.length &gt; 0;\\n    runBtn.disabled = !canRun;\\n    const hasPresetSelected = !!(presetSelect &amp;&amp; presetSelect.value);\\n    const hasPresetName = !!(presetNameInput &amp;&amp; presetNameInput.value.trim().length &gt; 0);\\n    const canSave = hasPresetName &amp;&amp; selectedSymbols.length &gt; 0;\\n    if (saveBtn) {\\n        saveBtn.classList.toggle(\\'active\\', canSave);\\n    }\\n    if (deleteBtn) {\\n        deleteBtn.classList.toggle(\\'active\\', hasPresetSelected);\\n    }\\n}\\n\\nasync function loadStrategies() {\\n    const res = await fetch(\\'/api/strategies\\');\\n    const data = await res.json();\\n    const sel = document.getElementById(\\'strategy\\');\\n    data.strategies.forEach(s =&gt; sel.innerHTML += `&lt;option value=\"${s.id}\"&gt;${s.name}&lt;/option&gt;`);\\n    if (data.strategies.length &gt; 0) {\\n        sel.value = data.strategies[0].id;\\n        loadStrategyParams();\\n    }\\n}\\n\\nasync function loadStrategyParams() {\\n    const name = document.getElementById(\\'strategy\\').value;\\n    if (!name) return;\\n    const res = await fetch(`/api/strategies/${name}`);\\n    const data = await res.json();\\n    strategyParams = data.parameters || [];\\n    renderParams();\\n}\\n\\nfunction formatParamName(name) {\\n    let result = name.replace(/_/g, \\' \\');\\n    result = result.replace(/([A-Z]+)([A-Z][a-z])/g, \\'$1 $2\\');\\n    result = result.replace(/([a-z])([A-Z])/g, \\'$1 $2\\');\\n    return result.split(\\' \\').map(word =&gt; {\\n        if (word === word.toUpperCase() &amp;&amp; word.length &gt; 1) return word;\\n        return word.charAt(0).toUpperCase() + word.slice(1);\\n    }).join(\\' \\');\\n}\\n\\nfunction renderParams() {\\n    const container = document.getElementById(\\'strategy-params\\');\\n    const filtered = strategyParams.filter(p =&gt; p.name !== \\'bar_period\\');\\n    if (filtered.length === 0) {\\n        container.innerHTML = \\'&lt;div style=\"color: #8b949e; font-size: 13px;\"&gt;No parameters&lt;/div&gt;\\';\\n        return;\\n    }\\n    container.innerHTML = filtered.map(p =&gt; {\\n        const label = formatParamName(p.name);\\n        if (p.choices &amp;&amp; p.choices.length &gt; 0) {\\n            const opts = p.choices.map(c =&gt; `&lt;option value=\"${c}\" ${c === p.default ? \\'selected\\' : \\'\\'}&gt;${c}&lt;/option&gt;`).join(\\'\\');\\n            return `&lt;div class=\"param-row\"&gt;&lt;label&gt;${label}&lt;/label&gt;&lt;select id=\"sp_${p.name}\"&gt;${opts}&lt;/select&gt;&lt;/div&gt;`;\\n        }\\n        const inputType = p.type === \\'bool\\' ? \\'checkbox\\' : (p.type === \\'float\\' || p.type === \\'int\\' ? \\'number\\' : \\'text\\');\\n        const step = p.step || (p.type === \\'float\\' ? \\'0.01\\' : \\'1\\');\\n        const checked = p.type === \\'bool\\' &amp;&amp; p.default ? \\'checked\\' : \\'\\';\\n        return `&lt;div class=\"param-row\"&gt;&lt;label&gt;${label}&lt;/label&gt;&lt;input type=\"${inputType}\" id=\"sp_${p.name}\" value=\"${p.default}\" step=\"${step}\" ${p.min !== undefined ? `min=\"${p.min}\"` : \\'\\'} ${p.max !== undefined ? `max=\"${p.max}\"` : \\'\\'} ${checked}&gt;&lt;/div&gt;`;\\n    }).join(\\'\\');\\n}\\n\\nfunction tsToDate(ts) {\\n    const ms = Math.floor(ts / 1000000);\\n    const d = new Date(ms);\\n    return d.toISOString().split(\\'T\\')[0];\\n}\\n\\nasync function loadCoverage() {\\n    const res = await fetch(\\'/api/secmaster/symbols_coverage\\');\\n    const data = await res.json();\\n    coverageData = data.symbols || [];\\n    const rtypeSet = new Set();\\n    coverageData.forEach(row =&gt; rtypeSet.add(row.rtype));\\n    availableRtypes = Array.from(rtypeSet).sort((a, b) =&gt; a - b);\\n    populateBarPeriodDropdown();\\n}\\n\\nfunction populateBarPeriodDropdown() {\\n    const sel = document.getElementById(\\'bar-period\\');\\n    sel.innerHTML = \\'&lt;option value=\"\"&gt;-- Select bar period --&lt;/option&gt;\\';\\n    availableRtypes.forEach(rt =&gt; {\\n        const label = RTYPE_LABELS[rt] || `rtype ${rt}`;\\n        sel.innerHTML += `&lt;option value=\"${rt}\"&gt;${label}&lt;/option&gt;`;\\n    });\\n}\\n\\nfunction onBarPeriodChange() {\\n    selectedSymbols = [];\\n    selectedPublisherId = null;\\n    symbolsForRtype = {};\\n    symbolCoverageForRtype = {};\\n    renderSelectedSymbols();\\n    updateDateRange();\\n    const rtype = document.getElementById(\\'bar-period\\').value;\\n    const section = document.getElementById(\\'symbols-section\\');\\n    const symbolSelection = document.getElementById(\\'symbol-selection\\');\\n    document.getElementById(\\'publisher-name\\').value = \\'\\';\\n    document.getElementById(\\'publisher-dataset\\').innerHTML = \\'&lt;option value=\"\"&gt;-- Select Dataset --&lt;/option&gt;\\';\\n    if (rtype) {\\n        section.style.display = \\'block\\';\\n        loadPublishers();\\n    } else {\\n        section.style.display = \\'none\\';\\n    }\\n    symbolSelection.style.display = \\'none\\';\\n    document.getElementById(\\'symbol-search\\').value = \\'\\';\\n    document.getElementById(\\'search-results\\').innerHTML = \\'\\';\\n}\\n\\nfunction getSelectedRtype() {\\n    return parseInt(document.getElementById(\\'bar-period\\').value) || null;\\n}\\n\\nfunction searchSymbols() {\\n    const query = document.getElementById(\\'symbol-search\\').value.toLowerCase();\\n    const container = document.getElementById(\\'search-results\\');\\n    const rtype = getSelectedRtype();\\n    if (!query || !rtype) {\\n        container.innerHTML = \\'\\';\\n        return;\\n    }\\n    const symbols = symbolsForRtype[rtype] || [];\\n    const matches = symbols.filter(s =&gt; s.toLowerCase().includes(query) &amp;&amp; !selectedSymbols.includes(s)).slice(0, 20);\\n    container.innerHTML = matches.map(s =&gt;\\n        `&lt;div class=\"search-result\" onclick=\"addSymbol(\\'${s}\\')\"&gt;&lt;span class=\"symbol\"&gt;${s}&lt;/span&gt;&lt;/div&gt;`\\n    ).join(\\'\\');\\n}\\n\\nfunction addSymbol(symbol) {\\n    if (!selectedSymbols.includes(symbol)) {\\n        selectedSymbols.push(symbol);\\n        document.getElementById(\\'preset-select\\').value = \\'\\';\\n        renderSelectedSymbols();\\n        updateDateRange();\\n    }\\n    document.getElementById(\\'symbol-search\\').value = \\'\\';\\n    document.getElementById(\\'search-results\\').innerHTML = \\'\\';\\n}\\n\\nfunction removeSymbol(symbol) {\\n    selectedSymbols = selectedSymbols.filter(s =&gt; s !== symbol);\\n    document.getElementById(\\'preset-select\\').value = \\'\\';\\n    renderSelectedSymbols();\\n    updateDateRange();\\n}\\n\\nfunction renderSelectedSymbols() {\\n    const container = document.getElementById(\\'selected-symbols\\');\\n    document.getElementById(\\'selected-label\\').textContent = `Selected (${selectedSymbols.length}):`;\\n    container.innerHTML = selectedSymbols.map(s =&gt;\\n        `&lt;span class=\"selected-tag\"&gt;${s}&lt;span class=\"remove\" onclick=\"removeSymbol(\\'${s}\\')\"&gt;&amp;times;&lt;/span&gt;&lt;/span&gt;`\\n    ).join(\\'\\');\\n    updateButtonStates();\\n}\\n\\nfunction renderSelectedSymbolsKeepPreset() {\\n    const container = document.getElementById(\\'selected-symbols\\');\\n    document.getElementById(\\'selected-label\\').textContent = `Selected (${selectedSymbols.length}):`;\\n    container.innerHTML = selectedSymbols.map(s =&gt;\\n        `&lt;span class=\"selected-tag\"&gt;${s}&lt;span class=\"remove\" onclick=\"removeSymbol(\\'${s}\\')\"&gt;&amp;times;&lt;/span&gt;&lt;/span&gt;`\\n    ).join(\\'\\');\\n    updateButtonStates();\\n}\\n\\nfunction updateDateRange() {\\n    const startInput = document.getElementById(\\'start-date\\');\\n    const endInput = document.getElementById(\\'end-date\\');\\n    const rtype = getSelectedRtype();\\n    if (selectedSymbols.length === 0 || !rtype) {\\n        globalMinDate = null;\\n        globalMaxDate = null;\\n        startInput.value = \\'\\';\\n        endInput.value = \\'\\';\\n        startInput.removeAttribute(\\'min\\');\\n        startInput.removeAttribute(\\'max\\');\\n        endInput.removeAttribute(\\'min\\');\\n        endInput.removeAttribute(\\'max\\');\\n        return;\\n    }\\n    const coverage = symbolCoverageForRtype[rtype] || {};\\n    let minTs = null, maxTs = null;\\n    selectedSymbols.forEach(s =&gt; {\\n        const cov = coverage[s];\\n        if (cov) {\\n            if (minTs === null || cov.min_ts &lt; minTs) minTs = cov.min_ts;\\n            if (maxTs === null || cov.max_ts &gt; maxTs) maxTs = cov.max_ts;\\n        }\\n    });\\n    if (minTs === null) return;\\n    globalMinDate = tsToDate(minTs);\\n    globalMaxDate = tsToDate(maxTs);\\n    startInput.min = globalMinDate;\\n    startInput.max = globalMaxDate;\\n    startInput.value = globalMinDate;\\n    endInput.min = globalMinDate;\\n    endInput.max = globalMaxDate;\\n    endInput.value = globalMaxDate;\\n}\\n\\nfunction clampDate(inputId) {\\n    if (!globalMinDate || !globalMaxDate) return;\\n    const input = document.getElementById(inputId);\\n    if (input.value &lt; globalMinDate) input.value = globalMinDate;\\n    if (input.value &gt; globalMaxDate) input.value = globalMaxDate;\\n}\\n\\nfunction collectParams() {\\n    const result = {};\\n    strategyParams.forEach(p =&gt; {\\n        const el = document.getElementById(`sp_${p.name}`);\\n        if (!el) return;\\n        if (p.type === \\'bool\\') result[p.name] = el.checked;\\n        else if (p.type === \\'int\\') result[p.name] = parseInt(el.value);\\n        else if (p.type === \\'float\\') result[p.name] = parseFloat(el.value);\\n        else result[p.name] = el.value;\\n    });\\n    return result;\\n}\\n\\nasync function loadDbRuns() {\\n    const res = await fetch(\\'/api/runs\\');\\n    const data = await res.json();\\n    dbRuns = data.runs || [];\\n    renderRuns();\\n}\\n\\nfunction toggleRunSelection(runId) {\\n    if (selectedRunIds.has(runId)) {\\n        selectedRunIds.delete(runId);\\n    } else {\\n        selectedRunIds.add(runId);\\n    }\\n    renderRuns();\\n}\\n\\nfunction toggleSelectAll() {\\n    const allDbRunIds = dbRuns.map(r =&gt; r.run_id);\\n    if (selectedRunIds.size === allDbRunIds.length &amp;&amp; allDbRunIds.length &gt; 0) {\\n        selectedRunIds.clear();\\n    } else {\\n        allDbRunIds.forEach(id =&gt; selectedRunIds.add(id));\\n    }\\n    renderRuns();\\n}\\n\\nasync function deleteSelectedRuns() {\\n    if (selectedRunIds.size === 0) return;\\n    if (!confirm(`Delete ${selectedRunIds.size} run(s)? This cannot be undone.`)) return;\\n    const res = await fetch(\\'/api/runs\\', {\\n        method: \\'DELETE\\',\\n        headers: {\\'Content-Type\\': \\'application/json\\'},\\n        body: JSON.stringify({run_ids: Array.from(selectedRunIds)})\\n    });\\n    if (res.ok) {\\n        selectedRunIds.clear();\\n        await loadDbRuns();\\n    } else {\\n        alert(\\'Failed to delete runs\\');\\n    }\\n}\\n\\nfunction renderRuns() {\\n    const container = document.getElementById(\\'runs-list\\');\\n    const activeRunIds = Object.keys(activeRuns).filter(id =&gt; activeRuns[id].status === \\'running\\');\\n    const allDbRunIds = dbRuns.map(r =&gt; r.run_id);\\n    const allSelected = allDbRunIds.length &gt; 0 &amp;&amp; selectedRunIds.size === allDbRunIds.length;\\n\\n    let html = \\'\\';\\n    if (dbRuns.length &gt; 0 || activeRunIds.length &gt; 0) {\\n        html += `&lt;div class=\"runs-toolbar\"&gt;\\n            &lt;label class=\"select-all-label\"&gt;\\n                &lt;input type=\"checkbox\" ${allSelected ? \\'checked\\' : \\'\\'} onchange=\"toggleSelectAll()\"&gt;\\n                Select all\\n            &lt;/label&gt;\\n            &lt;button class=\"btn-delete\" ${selectedRunIds.size === 0 ? \\'disabled\\' : \\'\\'} onclick=\"deleteSelectedRuns()\"&gt;\\n                Delete (${selectedRunIds.size})\\n            &lt;/button&gt;\\n        &lt;/div&gt;`;\\n    }\\n\\n    activeRunIds.forEach(id =&gt; {\\n        const run = activeRuns[id];\\n        const progress = run.progress;\\n        html += `&lt;div class=\"run-item\"&gt;\\n            &lt;div class=\"run-content\"&gt;\\n                &lt;div class=\"run-header\"&gt;\\n                    &lt;span class=\"run-name\"&gt;${run.strategy}&lt;/span&gt;\\n                    &lt;span class=\"run-status running\"&gt;running&lt;/span&gt;\\n                &lt;/div&gt;\\n                &lt;div class=\"run-meta with-progress\"&gt;${run.symbols.length} symbol${run.symbols.length !== 1 ? \\'s\\' : \\'\\'} \u00b7 ${run.startDate || \\'all\\'} to ${run.endDate || \\'all\\'}&lt;/div&gt;\\n                &lt;div class=\"progress-bar\"&gt;&lt;div class=\"progress-fill\" style=\"width: ${progress}%\"&gt;&lt;/div&gt;&lt;/div&gt;\\n            &lt;/div&gt;\\n        &lt;/div&gt;`;\\n    });\\n\\n    dbRuns.forEach(r =&gt; {\\n        const config = r.config || {};\\n        const strategies = config.strategies ? config.strategies.join(\\', \\') : r.name;\\n        const symbols = config.symbols || [];\\n        const symbolCount = symbols.length;\\n        const startDate = config.start_date || \\'-\\';\\n        const endDate = config.end_date || \\'-\\';\\n        const timePart = r.run_id.slice(11, 19).replace(/-/g, \\':\\');\\n        const isSelected = selectedRunIds.has(r.run_id);\\n        const statusClass = r.status;\\n        const clickable = r.status === \\'completed\\' ? `onclick=\"goToPerformance(\\'${r.run_id}\\')\"` : \\'\\';\\n        const clickableClass = r.status === \\'completed\\' ? \\'clickable\\' : \\'\\';\\n        html += `&lt;div class=\"run-item ${isSelected ? \\'selected\\' : \\'\\'}\"&gt;\\n            &lt;input type=\"checkbox\" class=\"run-checkbox\" ${isSelected ? \\'checked\\' : \\'\\'} onchange=\"toggleRunSelection(\\'${r.run_id}\\')\"&gt;\\n            &lt;div class=\"run-content ${clickableClass}\" ${clickable}&gt;\\n                &lt;div class=\"run-header\"&gt;\\n                    &lt;span class=\"run-name\"&gt;${strategies} &lt;span class=\"run-id\"&gt;${timePart}&lt;/span&gt;&lt;/span&gt;\\n                    &lt;span class=\"run-status ${statusClass}\"&gt;${r.status}&lt;/span&gt;\\n                &lt;/div&gt;\\n                &lt;div class=\"run-meta\"&gt;${symbolCount} symbol${symbolCount !== 1 ? \\'s\\' : \\'\\'} \u00b7 ${startDate} to ${endDate}&lt;/div&gt;\\n            &lt;/div&gt;\\n        &lt;/div&gt;`;\\n    });\\n\\n    if (html === \\'\\') {\\n        html = \\'&lt;div class=\"empty-runs\"&gt;&lt;p&gt;No runs yet&lt;/p&gt;&lt;p&gt;Configure settings and click Run Backtest&lt;/p&gt;&lt;/div&gt;\\';\\n    }\\n    container.innerHTML = html;\\n}\\n\\nasync function runBacktest() {\\n    const btn = document.getElementById(\\'run-btn\\');\\n    const rtype = getSelectedRtype();\\n    if (!rtype) {\\n        alert(\\'Please select a bar period\\');\\n        return;\\n    }\\n    if (!selectedPublisherId) {\\n        alert(\\'Please select a publisher and dataset\\');\\n        return;\\n    }\\n    if (selectedSymbols.length === 0) {\\n        alert(\\'Please select at least one symbol\\');\\n        return;\\n    }\\n    btn.disabled = true;\\n\\n    const strategy = document.getElementById(\\'strategy\\').value;\\n    const startDate = document.getElementById(\\'start-date\\').value || null;\\n    const endDate = document.getElementById(\\'end-date\\').value || null;\\n    const barPeriod = RTYPE_LABELS[rtype] || \\'Unknown\\';\\n\\n    const payload = {\\n        strategy: strategy,\\n        strategy_params: collectParams(),\\n        symbols: selectedSymbols,\\n        rtype: rtype,\\n        publisher_id: selectedPublisherId,\\n        start_date: startDate,\\n        end_date: endDate\\n    };\\n\\n    try {\\n        const res = await fetch(\\'/api/backtest/run\\', {\\n            method: \\'POST\\', headers: {\\'Content-Type\\': \\'application/json\\'}, body: JSON.stringify(payload)\\n        });\\n        const data = await res.json();\\n        if (!res.ok) throw new Error(data.detail || \\'Failed to start backtest\\');\\n        const runId = data.run_id;\\n\\n        activeRuns[runId] = {\\n            strategy: strategy,\\n            symbols: [...selectedSymbols],\\n            barPeriod: barPeriod,\\n            startDate: startDate,\\n            endDate: endDate,\\n            status: \\'running\\',\\n            progress: 10\\n        };\\n        renderRuns();\\n        btn.disabled = false;\\n\\n        let progress = 10;\\n        const poll = setInterval(async () =&gt; {\\n            const r = await fetch(`/api/backtest/status/${runId}`);\\n            const d = await r.json();\\n            if (d.status === \\'completed\\') {\\n                clearInterval(poll);\\n                delete activeRuns[runId];\\n                await loadDbRuns();\\n            } else if (d.status.startsWith(\\'error\\')) {\\n                clearInterval(poll);\\n                delete activeRuns[runId];\\n                await loadDbRuns();\\n            } else {\\n                progress = Math.min(progress + 5, 90);\\n                activeRuns[runId].progress = progress;\\n                renderRuns();\\n            }\\n        }, 1000);\\n    } catch (e) {\\n        alert(`Error: ${e.message}`);\\n        btn.disabled = false;\\n    }\\n}\\n\\nfunction goToPerformance(runId) {\\n    window.location.href = `/performance?run_id=${runId}`;\\n}\\n\\ndocument.addEventListener(\\'DOMContentLoaded\\', () =&gt; {\\n    loadStrategies();\\n    loadCoverage();\\n    loadDbRuns();\\n});\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/styles/#onesecondtrader.dashboard.styles.PERFORMANCE_CSS","title":"<code>PERFORMANCE_CSS = '\\n.container { max-width: none; height: 100vh; padding: 24px; display: flex; flex-direction: column; box-sizing: border-box; }\\n.performance-layout { display: flex; gap: 24px; flex: 1; min-height: 0; }\\n.performance-left { flex: 1; min-width: 0; display: flex; flex-direction: column; }\\n.performance-right { flex: 3; min-width: 0; display: flex; flex-direction: column; overflow-y: auto; }\\n.performance-left .card { flex: 1; display: flex; flex-direction: column; margin-bottom: 0; min-height: 0; }\\n.performance-right .card { display: flex; flex-direction: column; margin-bottom: 0; }\\n.performance-left .runs-list { flex: 1; overflow-y: auto; }\\n.runs-list { display: flex; flex-direction: column; gap: 8px; }\\n.run-item { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; cursor: pointer; }\\n.run-item:hover { border-color: #58a6ff; }\\n.run-item.selected { border-color: #58a6ff; background: #161b22; }\\n.run-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }\\n.run-name { font-family: monospace; font-size: 13px; color: #e6edf3; }\\n.run-id { color: #8b949e; font-size: 11px; margin-left: 6px; }\\n.run-status { font-size: 12px; font-weight: 500; padding: 2px 8px; border-radius: 10px; }\\n.run-status.completed { background: #238636; color: #fff; }\\n.run-status.failed { background: #da3633; color: #fff; }\\n.run-status.error { background: #da3633; color: #fff; }\\n.run-meta { font-size: 12px; color: #8b949e; }\\n.empty-runs { text-align: center; padding: 48px 24px; color: #8b949e; }\\n.empty-runs p { font-size: 14px; }\\n.empty-content { text-align: center; padding: 48px 24px; color: #8b949e; }\\n.empty-content p { font-size: 14px; }\\n.search-bar { margin-bottom: 16px; }\\n.search-bar input { width: 100%; padding: 8px 12px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: #e6edf3; font-size: 14px; }\\n.search-bar input:focus { outline: none; border-color: #58a6ff; }\\n.search-bar input::placeholder { color: #8b949e; }\\n.roundtrips-table-container { }\\n.roundtrips-table { width: 100%; border-collapse: collapse; font-size: 13px; }\\n.roundtrips-table th { position: sticky; top: 0; background: #161b22; padding: 10px 12px; text-align: left; color: #8b949e; font-weight: 500; border-bottom: 1px solid #30363d; cursor: pointer; user-select: none; white-space: nowrap; }\\n.roundtrips-table th:hover { color: #e6edf3; }\\n.roundtrips-table th .sort-icon { margin-left: 4px; opacity: 0.5; }\\n.roundtrips-table th.sorted .sort-icon { opacity: 1; }\\n.roundtrips-table td { padding: 10px 12px; border-bottom: 1px solid #21262d; color: #e6edf3; white-space: nowrap; }\\n.roundtrips-table tr:hover td { background: #21262d; }\\n.roundtrips-table .symbol { font-family: monospace; }\\n.roundtrips-table .direction { font-weight: 500; }\\n.roundtrips-table .direction.long { color: #3fb950; }\\n.roundtrips-table .direction.short { color: #f85149; }\\n.roundtrips-table .pnl { font-weight: 500; font-family: monospace; }\\n.roundtrips-table .pnl.positive { color: #3fb950; }\\n.roundtrips-table .pnl.negative { color: #f85149; }\\n.roundtrips-table .number { font-family: monospace; text-align: right; }\\n.empty-table { text-align: center; padding: 48px 24px; color: #8b949e; }\\n.roundtrips-table tr.data-row { cursor: pointer; }\\n.roundtrips-table tr.chart-row { display: none; }\\n.roundtrips-table tr.chart-row.expanded { display: table-row; }\\n.roundtrips-table tr.chart-row td { padding: 16px; background: #0d1117; }\\n.chart-container { position: relative; text-align: center; }\\n.chart-container img { max-width: 100%; height: auto; border-radius: 4px; }\\n.chart-loading { color: #8b949e; padding: 48px; }\\n.pnl-summary-container { margin-bottom: 16px; text-align: center; }\\n.pnl-summary-container img { max-width: 100%; height: auto; border-radius: 4px; background: #fff; }\\n.pnl-summary-loading { color: #8b949e; padding: 24px; }\\n.trade-journey-container { margin-bottom: 16px; text-align: center; }\\n.trade-journey-container img { max-width: 100%; height: auto; border-radius: 4px; background: #fff; }\\n.trade-journey-loading { color: #8b949e; padding: 24px; }\\n.trade-journey-message { color: #8b949e; padding: 24px; font-style: italic; }\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/styles/#onesecondtrader.dashboard.styles.PERFORMANCE_JS","title":"<code>PERFORMANCE_JS = '\\nlet runs = [];\\nlet selectedRunId = null;\\nlet roundtrips = [];\\nlet filteredRoundtrips = [];\\nlet sortColumn = \\'symbol\\';\\nlet sortAsc = true;\\n\\nfunction getUrlRunId() {\\n    const params = new URLSearchParams(window.location.search);\\n    return params.get(\\'run_id\\');\\n}\\n\\nasync function loadRuns() {\\n    const res = await fetch(\\'/api/runs\\');\\n    const data = await res.json();\\n    runs = (data.runs || []).filter(r =&gt; r.status === \\'completed\\');\\n    renderRuns();\\n    const urlRunId = getUrlRunId();\\n    if (urlRunId &amp;&amp; runs.some(r =&gt; r.run_id === urlRunId)) {\\n        selectRun(urlRunId);\\n    }\\n}\\n\\nfunction selectRun(runId) {\\n    selectedRunId = runId;\\n    const url = new URL(window.location);\\n    url.searchParams.set(\\'run_id\\', runId);\\n    window.history.replaceState({}, \\'\\', url);\\n    renderRuns();\\n    loadPerformance(runId);\\n}\\n\\nfunction renderRuns() {\\n    const container = document.getElementById(\\'runs-list\\');\\n    if (runs.length === 0) {\\n        container.innerHTML = \\'&lt;div class=\"empty-runs\"&gt;&lt;p&gt;No completed runs&lt;/p&gt;&lt;/div&gt;\\';\\n        return;\\n    }\\n    container.innerHTML = runs.map(r =&gt; {\\n        const config = r.config || {};\\n        const strategies = config.strategies ? config.strategies.join(\\', \\') : r.name;\\n        const symbols = config.symbols || [];\\n        const symbolCount = symbols.length;\\n        const startDate = config.start_date || \\'-\\';\\n        const endDate = config.end_date || \\'-\\';\\n        const timePart = r.run_id.slice(11, 19).replace(/-/g, \\':\\');\\n        const isSelected = r.run_id === selectedRunId;\\n        return `&lt;div class=\"run-item ${isSelected ? \\'selected\\' : \\'\\'}\" onclick=\"selectRun(\\'${r.run_id}\\')\"&gt;\\n            &lt;div class=\"run-header\"&gt;\\n                &lt;span class=\"run-name\"&gt;${strategies} &lt;span class=\"run-id\"&gt;${timePart}&lt;/span&gt;&lt;/span&gt;\\n                &lt;span class=\"run-status ${r.status}\"&gt;${r.status}&lt;/span&gt;\\n            &lt;/div&gt;\\n            &lt;div class=\"run-meta\"&gt;${symbolCount} symbol${symbolCount !== 1 ? \\'s\\' : \\'\\'} \u00b7 ${startDate} to ${endDate}&lt;/div&gt;\\n        &lt;/div&gt;`;\\n    }).join(\\'\\');\\n}\\n\\nasync function loadPerformance(runId) {\\n    const container = document.getElementById(\\'performance-content\\');\\n    container.innerHTML = \\'&lt;div class=\"empty-content\"&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;/div&gt;\\';\\n    const res = await fetch(`/api/runs/${runId}/roundtrips`);\\n    const data = await res.json();\\n    roundtrips = data.roundtrips || [];\\n    const tradeNums = {};\\n    roundtrips.forEach(rt =&gt; {\\n        tradeNums[rt.symbol] = (tradeNums[rt.symbol] || 0) + 1;\\n        rt.trade_num = tradeNums[rt.symbol];\\n    });\\n    filteredRoundtrips = [...roundtrips];\\n    sortColumn = \\'symbol\\';\\n    sortAsc = true;\\n    document.getElementById(\\'symbol-filter\\').value = \\'\\';\\n    updatePerformanceCharts();\\n    sortAndRender();\\n}\\n\\nfunction updatePerformanceCharts() {\\n    const pnlContainer = document.getElementById(\\'pnl-summary-container\\');\\n    const journeyContainer = document.getElementById(\\'trade-journey-container\\');\\n    if (!selectedRunId) {\\n        pnlContainer.innerHTML = \\'\\';\\n        journeyContainer.innerHTML = \\'\\';\\n        return;\\n    }\\n    const allSymbols = [...new Set(roundtrips.map(rt =&gt; rt.symbol))];\\n    const symbols = [...new Set(filteredRoundtrips.map(rt =&gt; rt.symbol))];\\n    if (symbols.length !== 1 &amp;&amp; allSymbols.length !== 1) {\\n        pnlContainer.innerHTML = \\'\\';\\n        journeyContainer.innerHTML = \\'&lt;div class=\"trade-journey-message\"&gt;Filter by symbol to see per-symbol Performance Statistics&lt;/div&gt;\\';\\n        return;\\n    }\\n    const symbol = symbols.length === 1 ? symbols[0] : allSymbols[0];\\n\\n    pnlContainer.innerHTML = \\'&lt;div class=\"pnl-summary-loading\"&gt;Loading PnL Summary chart...&lt;/div&gt;\\';\\n    const pnlUrl = `/api/runs/${selectedRunId}/pnl-summary.png?symbol=${encodeURIComponent(symbol)}`;\\n    const pnlImg = new Image();\\n    pnlImg.onload = () =&gt; {\\n        pnlContainer.innerHTML = \\'\\';\\n        pnlContainer.appendChild(pnlImg);\\n    };\\n    pnlImg.onerror = () =&gt; {\\n        pnlContainer.innerHTML = \\'&lt;div class=\"pnl-summary-loading\"&gt;Failed to load PnL Summary chart&lt;/div&gt;\\';\\n    };\\n    pnlImg.src = pnlUrl;\\n    pnlImg.alt = \\'PnL Summary Chart\\';\\n\\n    journeyContainer.innerHTML = \\'&lt;div class=\"trade-journey-loading\"&gt;Loading Trade Journey chart...&lt;/div&gt;\\';\\n    const journeyUrl = `/api/runs/${selectedRunId}/trade-journey.png?symbol=${encodeURIComponent(symbol)}`;\\n    const journeyImg = new Image();\\n    journeyImg.onload = () =&gt; {\\n        journeyContainer.innerHTML = \\'\\';\\n        journeyContainer.appendChild(journeyImg);\\n    };\\n    journeyImg.onerror = () =&gt; {\\n        journeyContainer.innerHTML = \\'&lt;div class=\"trade-journey-loading\"&gt;Failed to load Trade Journey chart&lt;/div&gt;\\';\\n    };\\n    journeyImg.src = journeyUrl;\\n    journeyImg.alt = \\'Trade Journey Chart\\';\\n}\\n\\nfunction filterRoundtrips() {\\n    const query = document.getElementById(\\'symbol-filter\\').value.toLowerCase().trim();\\n    if (!query) {\\n        filteredRoundtrips = [...roundtrips];\\n    } else {\\n        const terms = query.split(/[,\\\\s]+/).filter(t =&gt; t.length &gt; 0);\\n        filteredRoundtrips = roundtrips.filter(rt =&gt;\\n            terms.some(term =&gt; rt.symbol.toLowerCase().includes(term))\\n        );\\n    }\\n    updatePerformanceCharts();\\n    sortAndRender();\\n}\\n\\nfunction sortBy(column) {\\n    if (sortColumn === column) {\\n        sortAsc = !sortAsc;\\n    } else {\\n        sortColumn = column;\\n        sortAsc = true;\\n    }\\n    sortAndRender();\\n}\\n\\nfunction sortAndRender() {\\n    filteredRoundtrips.sort((a, b) =&gt; {\\n        let valA = a[sortColumn];\\n        let valB = b[sortColumn];\\n        if (typeof valA === \\'string\\') {\\n            valA = valA.toLowerCase();\\n            valB = valB.toLowerCase();\\n        }\\n        if (valA &lt; valB) return sortAsc ? -1 : 1;\\n        if (valA &gt; valB) return sortAsc ? 1 : -1;\\n        return 0;\\n    });\\n    renderTable();\\n}\\n\\nfunction renderTable() {\\n    const container = document.getElementById(\\'performance-content\\');\\n    if (roundtrips.length === 0) {\\n        container.innerHTML = \\'&lt;div class=\"empty-table\"&gt;&lt;p&gt;No round-trip trades found&lt;/p&gt;&lt;/div&gt;\\';\\n        return;\\n    }\\n    const columns = [\\n        {key: \\'symbol\\', label: \\'Symbol\\'},\\n        {key: \\'trade_num\\', label: \\'#\\'},\\n        {key: \\'direction\\', label: \\'Direction\\'},\\n        {key: \\'duration_bars\\', label: \\'Bars\\'},\\n        {key: \\'max_position\\', label: \\'Max Position\\'},\\n        {key: \\'high_watermark\\', label: \\'High Watermark\\'},\\n        {key: \\'low_watermark\\', label: \\'Low Watermark\\'},\\n        {key: \\'max_drawdown\\', label: \\'Max Drawdown\\'},\\n        {key: \\'pnl_before_commission\\', label: \\'PnL (Gross)\\'},\\n        {key: \\'pnl_after_commission\\', label: \\'PnL (Net)\\'},\\n    ];\\n    const headerHtml = columns.map(c =&gt; {\\n        const isSorted = sortColumn === c.key;\\n        const arrow = isSorted ? (sortAsc ? \\'\u25b2\\' : \\'\u25bc\\') : \\'\u25b2\\';\\n        return `&lt;th class=\"${isSorted ? \\'sorted\\' : \\'\\'}\" onclick=\"sortBy(\\'${c.key}\\')\"&gt;${c.label}&lt;span class=\"sort-icon\"&gt;${arrow}&lt;/span&gt;&lt;/th&gt;`;\\n    }).join(\\'\\');\\n    const rowsHtml = filteredRoundtrips.map((rt, idx) =&gt; {\\n        const dirClass = rt.direction.toLowerCase();\\n        const pnlGrossClass = rt.pnl_before_commission &gt;= 0 ? \\'positive\\' : \\'negative\\';\\n        const pnlNetClass = rt.pnl_after_commission &gt;= 0 ? \\'positive\\' : \\'negative\\';\\n        const pnlGrossSign = rt.pnl_before_commission &gt;= 0 ? \\'+\\' : \\'\\';\\n        const pnlNetSign = rt.pnl_after_commission &gt;= 0 ? \\'+\\' : \\'\\';\\n        const hwmClass = rt.high_watermark &gt;= 0 ? \\'positive\\' : \\'negative\\';\\n        const hwmSign = rt.high_watermark &gt;= 0 ? \\'+\\' : \\'\\';\\n        const lwmClass = rt.low_watermark &gt;= 0 ? \\'positive\\' : \\'negative\\';\\n        const lwmSign = rt.low_watermark &gt;= 0 ? \\'+\\' : \\'\\';\\n        const mddClass = rt.max_drawdown &gt; 0 ? \\'negative\\' : \\'\\';\\n        return `&lt;tr class=\"data-row\" onclick=\"toggleChart(${idx})\"&gt;\\n            &lt;td class=\"symbol\"&gt;${rt.symbol}&lt;/td&gt;\\n            &lt;td&gt;${rt.trade_num}&lt;/td&gt;\\n            &lt;td class=\"direction ${dirClass}\"&gt;${rt.direction}&lt;/td&gt;\\n            &lt;td&gt;${rt.duration_bars}&lt;/td&gt;\\n            &lt;td&gt;${rt.max_position}&lt;/td&gt;\\n            &lt;td class=\"pnl ${hwmClass}\"&gt;${hwmSign}${rt.high_watermark.toFixed(2)}&lt;/td&gt;\\n            &lt;td class=\"pnl ${lwmClass}\"&gt;${lwmSign}${rt.low_watermark.toFixed(2)}&lt;/td&gt;\\n            &lt;td class=\"pnl ${mddClass}\"&gt;${rt.max_drawdown &gt; 0 ? \\'-\\' : \\'\\'}${rt.max_drawdown.toFixed(2)}&lt;/td&gt;\\n            &lt;td class=\"pnl ${pnlGrossClass}\"&gt;${pnlGrossSign}${rt.pnl_before_commission.toFixed(2)}&lt;/td&gt;\\n            &lt;td class=\"pnl ${pnlNetClass}\"&gt;${pnlNetSign}${rt.pnl_after_commission.toFixed(2)}&lt;/td&gt;\\n        &lt;/tr&gt;\\n        &lt;tr class=\"chart-row\" id=\"chart-row-${idx}\"&gt;\\n            &lt;td colspan=\"10\"&gt;\\n                &lt;div class=\"chart-container\" id=\"chart-container-${idx}\"&gt;\\n                    &lt;div class=\"chart-loading\"&gt;Loading chart...&lt;/div&gt;\\n                &lt;/div&gt;\\n            &lt;/td&gt;\\n        &lt;/tr&gt;`;\\n    }).join(\\'\\');\\n    container.innerHTML = `\\n        &lt;div class=\"roundtrips-table-container\"&gt;\\n            &lt;table class=\"roundtrips-table\"&gt;\\n                &lt;thead&gt;&lt;tr&gt;${headerHtml}&lt;/tr&gt;&lt;/thead&gt;\\n                &lt;tbody&gt;${rowsHtml}&lt;/tbody&gt;\\n            &lt;/table&gt;\\n        &lt;/div&gt;\\n    `;\\n}\\n\\nconst chartCache = {};\\n\\nfunction toggleChart(idx) {\\n    const chartRow = document.getElementById(`chart-row-${idx}`);\\n    if (chartRow.classList.contains(\\'expanded\\')) {\\n        chartRow.classList.remove(\\'expanded\\');\\n        return;\\n    }\\n    chartRow.classList.add(\\'expanded\\');\\n    const rt = filteredRoundtrips[idx];\\n    const container = document.getElementById(`chart-container-${idx}`);\\n    const cacheKey = `${selectedRunId}_${rt.symbol}_${rt.entry_ts}_${rt.exit_ts}`;\\n    if (chartCache[cacheKey]) {\\n        container.innerHTML = `&lt;img src=\"${chartCache[cacheKey]}\" alt=\"Chart\"&gt;`;\\n        return;\\n    }\\n    container.innerHTML = \\'&lt;div class=\"chart-loading\"&gt;Loading chart...&lt;/div&gt;\\';\\n    const url = `/api/runs/${selectedRunId}/chart.png?symbol=${encodeURIComponent(rt.symbol)}&amp;start_ns=${rt.entry_ts}&amp;end_ns=${rt.exit_ts}&amp;direction=${rt.direction}&amp;pnl=${rt.pnl_after_commission}`;\\n    const img = new Image();\\n    img.onload = () =&gt; {\\n        chartCache[cacheKey] = url;\\n        container.innerHTML = \\'\\';\\n        container.appendChild(img);\\n    };\\n    img.onerror = () =&gt; {\\n        container.innerHTML = \\'&lt;div class=\"chart-loading\"&gt;Failed to load chart&lt;/div&gt;\\';\\n    };\\n    img.src = url;\\n    img.alt = \\'Chart\\';\\n}\\n\\ndocument.addEventListener(\\'DOMContentLoaded\\', () =&gt; {\\n    loadRuns();\\n});\\n'</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/backtest/","title":"Backtest","text":"<p>API endpoints for backtest execution and status.</p> <p>Provides endpoints for starting backtests and querying their status.</p>"},{"location":"reference/dashboard/routers/backtest/#onesecondtrader.dashboard.routers.backtest.router","title":"<code>router = APIRouter(prefix='/api/backtest', tags=['backtest'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/backtest/#onesecondtrader.dashboard.routers.backtest.api_backtest_run","title":"<code>api_backtest_run(request, background_tasks)</code>  <code>async</code>","text":"<p>Start a backtest in the background and return the run ID.</p> Source code in <code>src/onesecondtrader/dashboard/routers/backtest.py</code> <pre><code>@router.post(\"/run\")\nasync def api_backtest_run(\n    request: BacktestRequest, background_tasks: BackgroundTasks\n) -&gt; dict:\n    \"\"\"Start a backtest in the background and return the run ID.\"\"\"\n    run_id = str(uuid.uuid4())[:8]\n    background_tasks.add_task(run_backtest, request, run_id)\n    return {\"run_id\": run_id, \"status\": \"started\"}\n</code></pre>"},{"location":"reference/dashboard/routers/backtest/#onesecondtrader.dashboard.routers.backtest.api_backtest_status","title":"<code>api_backtest_status(run_id)</code>  <code>async</code>","text":"<p>Return the current status of a backtest job.</p> Source code in <code>src/onesecondtrader/dashboard/routers/backtest.py</code> <pre><code>@router.get(\"/status/{run_id}\")\nasync def api_backtest_status(run_id: str) -&gt; dict:\n    \"\"\"Return the current status of a backtest job.\"\"\"\n    status = running_jobs.get(run_id, \"not found\")\n    return {\"run_id\": run_id, \"status\": status}\n</code></pre>"},{"location":"reference/dashboard/routers/presets/","title":"Presets","text":"<p>API endpoints for symbol preset management.</p> <p>Provides CRUD endpoints for managing saved symbol presets in the security master database.</p>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.router","title":"<code>router = APIRouter(prefix='/api/presets', tags=['presets'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.PresetRequest","title":"<code>PresetRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for creating or updating a preset.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the preset.</p> <code>symbols</code> <code>list[str]</code> <p>List of symbol strings in the preset.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>class PresetRequest(BaseModel):\n    \"\"\"\n    Request model for creating or updating a preset.\n\n    Attributes:\n        name:\n            Name of the preset.\n        symbols:\n            List of symbol strings in the preset.\n    \"\"\"\n\n    name: str\n    symbols: list[str]\n</code></pre>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.list_presets","title":"<code>list_presets()</code>  <code>async</code>","text":"<p>Return list of all preset names.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>@router.get(\"\")\nasync def list_presets() -&gt; dict:\n    \"\"\"Return list of all preset names.\"\"\"\n    db_path = get_secmaster_path()\n    if not os.path.exists(db_path):\n        return {\"presets\": []}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT name FROM symbol_presets ORDER BY name\")\n    presets = [row[0] for row in cursor.fetchall()]\n    conn.close()\n    return {\"presets\": presets}\n</code></pre>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.get_preset","title":"<code>get_preset(name)</code>  <code>async</code>","text":"<p>Return symbols for a specific preset.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>@router.get(\"/{name}\")\nasync def get_preset(name: str) -&gt; dict:\n    \"\"\"Return symbols for a specific preset.\"\"\"\n    db_path = get_secmaster_path()\n    if not os.path.exists(db_path):\n        return {\"error\": \"Preset not found\"}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT symbols FROM symbol_presets WHERE name = ?\", (name,))\n    row = cursor.fetchone()\n    conn.close()\n    if row is None:\n        return {\"error\": \"Preset not found\"}\n    return {\"name\": name, \"symbols\": json.loads(row[0])}\n</code></pre>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.create_preset","title":"<code>create_preset(request)</code>  <code>async</code>","text":"<p>Create a new symbol preset.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>@router.post(\"\")\nasync def create_preset(request: PresetRequest) -&gt; dict:\n    \"\"\"Create a new symbol preset.\"\"\"\n    db_path = get_secmaster_path()\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"INSERT INTO symbol_presets (name, symbols) VALUES (?, ?)\",\n        (request.name, json.dumps(request.symbols)),\n    )\n    conn.commit()\n    conn.close()\n    return {\"status\": \"created\", \"name\": request.name}\n</code></pre>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.update_preset","title":"<code>update_preset(name, request)</code>  <code>async</code>","text":"<p>Update an existing symbol preset.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>@router.put(\"/{name}\")\nasync def update_preset(name: str, request: PresetRequest) -&gt; dict:\n    \"\"\"Update an existing symbol preset.\"\"\"\n    db_path = get_secmaster_path()\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\n        \"UPDATE symbol_presets SET symbols = ? WHERE name = ?\",\n        (json.dumps(request.symbols), name),\n    )\n    conn.commit()\n    conn.close()\n    return {\"status\": \"updated\", \"name\": name}\n</code></pre>"},{"location":"reference/dashboard/routers/presets/#onesecondtrader.dashboard.routers.presets.delete_preset","title":"<code>delete_preset(name)</code>  <code>async</code>","text":"<p>Delete a symbol preset.</p> Source code in <code>src/onesecondtrader/dashboard/routers/presets.py</code> <pre><code>@router.delete(\"/{name}\")\nasync def delete_preset(name: str) -&gt; dict:\n    \"\"\"Delete a symbol preset.\"\"\"\n    db_path = get_secmaster_path()\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\"DELETE FROM symbol_presets WHERE name = ?\", (name,))\n    conn.commit()\n    conn.close()\n    return {\"status\": \"deleted\", \"name\": name}\n</code></pre>"},{"location":"reference/dashboard/routers/runs/","title":"Runs","text":"<p>API endpoints for run management.</p> <p>Provides endpoints for listing, deleting, and querying runs and their round-trips.</p>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.router","title":"<code>router = APIRouter(prefix='/api', tags=['runs'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.DeleteRunsRequest","title":"<code>DeleteRunsRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for deleting runs.</p> <p>Attributes:</p> Name Type Description <code>run_ids</code> <code>list[str]</code> <p>List of run IDs to delete.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>class DeleteRunsRequest(BaseModel):\n    \"\"\"\n    Request model for deleting runs.\n\n    Attributes:\n        run_ids:\n            List of run IDs to delete.\n    \"\"\"\n\n    run_ids: list[str]\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_runs","title":"<code>api_runs()</code>  <code>async</code>","text":"<p>Return list of recent runs from the database.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.get(\"/runs\")\nasync def api_runs() -&gt; dict:\n    \"\"\"Return list of recent runs from the database.\"\"\"\n    runs = get_runs()\n    return {\"runs\": runs}\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_delete_runs","title":"<code>api_delete_runs(request)</code>  <code>async</code>","text":"<p>Delete specified runs and their associated data.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.delete(\"/runs\")\nasync def api_delete_runs(request: DeleteRunsRequest) -&gt; dict:\n    \"\"\"Delete specified runs and their associated data.\"\"\"\n    db_path = get_runs_db_path()\n    if not os.path.exists(db_path):\n        return {\"deleted\": 0}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    deleted = 0\n    for run_id in request.run_ids:\n        for table in CHILD_TABLES:\n            cursor.execute(f\"DELETE FROM {table} WHERE run_id = ?\", (run_id,))\n        cursor.execute(\"DELETE FROM runs WHERE run_id = ?\", (run_id,))\n        deleted += cursor.rowcount\n    conn.commit()\n    conn.close()\n    return {\"deleted\": deleted}\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_run_roundtrips","title":"<code>api_run_roundtrips(run_id)</code>  <code>async</code>","text":"<p>Return computed round-trip trades for a run.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.get(\"/runs/{run_id}/roundtrips\")\nasync def api_run_roundtrips(run_id: str) -&gt; dict:\n    \"\"\"Return computed round-trip trades for a run.\"\"\"\n    roundtrips = get_roundtrips(run_id)\n    return {\"roundtrips\": roundtrips}\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_run_chart_image","title":"<code>api_run_chart_image(run_id, symbol, start_ns, end_ns, direction, pnl)</code>  <code>async</code>","text":"<p>Return a PNG chart image for a round-trip trade.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.get(\"/runs/{run_id}/chart.png\")\nasync def api_run_chart_image(\n    run_id: str,\n    symbol: str,\n    start_ns: int,\n    end_ns: int,\n    direction: str,\n    pnl: float,\n) -&gt; Response:\n    \"\"\"Return a PNG chart image for a round-trip trade.\"\"\"\n    image_bytes = generate_chart_image(run_id, symbol, start_ns, end_ns, direction, pnl)\n    return Response(content=image_bytes, media_type=\"image/png\")\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_trade_journey_chart","title":"<code>api_trade_journey_chart(run_id, symbol=None)</code>  <code>async</code>","text":"<p>Return a Trade Journey chart image for round-trip trades in a run, optionally filtered by symbol.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.get(\"/runs/{run_id}/trade-journey.png\")\nasync def api_trade_journey_chart(run_id: str, symbol: str | None = None) -&gt; Response:\n    \"\"\"Return a Trade Journey chart image for round-trip trades in a run, optionally filtered by symbol.\"\"\"\n    roundtrips = get_roundtrips(run_id)\n    if symbol:\n        roundtrips = [rt for rt in roundtrips if rt[\"symbol\"] == symbol]\n    image_bytes = generate_trade_journey_chart(run_id, roundtrips)\n    return Response(content=image_bytes, media_type=\"image/png\")\n</code></pre>"},{"location":"reference/dashboard/routers/runs/#onesecondtrader.dashboard.routers.runs.api_pnl_summary_chart","title":"<code>api_pnl_summary_chart(run_id, symbol=None)</code>  <code>async</code>","text":"<p>Return a PnL Summary chart image for round-trip trades in a run, optionally filtered by symbol.</p> Source code in <code>src/onesecondtrader/dashboard/routers/runs.py</code> <pre><code>@router.get(\"/runs/{run_id}/pnl-summary.png\")\nasync def api_pnl_summary_chart(run_id: str, symbol: str | None = None) -&gt; Response:\n    \"\"\"Return a PnL Summary chart image for round-trip trades in a run, optionally filtered by symbol.\"\"\"\n    roundtrips = get_roundtrips(run_id)\n    if symbol:\n        roundtrips = [rt for rt in roundtrips if rt[\"symbol\"] == symbol]\n    image_bytes = generate_pnl_summary_chart(roundtrips)\n    return Response(content=image_bytes, media_type=\"image/png\")\n</code></pre>"},{"location":"reference/dashboard/routers/secmaster/","title":"Secmaster","text":"<p>API endpoints for security master database queries.</p> <p>Provides endpoints for querying publishers, datasets, and symbol coverage information.</p>"},{"location":"reference/dashboard/routers/secmaster/#onesecondtrader.dashboard.routers.secmaster.router","title":"<code>router = APIRouter(prefix='/api/secmaster', tags=['secmaster'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/secmaster/#onesecondtrader.dashboard.routers.secmaster.api_secmaster_publishers","title":"<code>api_secmaster_publishers(rtype=None)</code>  <code>async</code>","text":"<p>Return list of publishers, optionally filtered by rtype.</p> Source code in <code>src/onesecondtrader/dashboard/routers/secmaster.py</code> <pre><code>@router.get(\"/publishers\")\nasync def api_secmaster_publishers(rtype: int | None = None) -&gt; dict:\n    \"\"\"Return list of publishers, optionally filtered by rtype.\"\"\"\n    db_path = get_secmaster_path()\n    if not os.path.exists(db_path):\n        return {\"publishers\": []}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    if rtype is not None:\n        cursor.execute(\n            \"SELECT DISTINCT p.name FROM publishers p \"\n            \"JOIN symbol_coverage sc ON p.publisher_id = sc.publisher_id \"\n            \"WHERE sc.rtype = ? ORDER BY p.name\",\n            (rtype,),\n        )\n    else:\n        cursor.execute(\"SELECT DISTINCT name FROM publishers ORDER BY name\")\n    publishers = [row[0] for row in cursor.fetchall()]\n    conn.close()\n    return {\"publishers\": publishers}\n</code></pre>"},{"location":"reference/dashboard/routers/secmaster/#onesecondtrader.dashboard.routers.secmaster.api_secmaster_datasets","title":"<code>api_secmaster_datasets(name, rtype=None)</code>  <code>async</code>","text":"<p>Return datasets for a publisher, optionally filtered by rtype.</p> Source code in <code>src/onesecondtrader/dashboard/routers/secmaster.py</code> <pre><code>@router.get(\"/publishers/{name}/datasets\")\nasync def api_secmaster_datasets(name: str, rtype: int | None = None) -&gt; dict:\n    \"\"\"Return datasets for a publisher, optionally filtered by rtype.\"\"\"\n    db_path = get_secmaster_path()\n    if not os.path.exists(db_path):\n        return {\"datasets\": []}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    if rtype is not None:\n        cursor.execute(\n            \"SELECT DISTINCT p.publisher_id, p.dataset FROM publishers p \"\n            \"JOIN symbol_coverage sc ON p.publisher_id = sc.publisher_id \"\n            \"WHERE p.name = ? AND sc.rtype = ? ORDER BY p.dataset\",\n            (name, rtype),\n        )\n    else:\n        cursor.execute(\n            \"SELECT publisher_id, dataset FROM publishers WHERE name = ? ORDER BY dataset\",\n            (name,),\n        )\n    datasets = [\n        {\"publisher_id\": row[0], \"dataset\": row[1]} for row in cursor.fetchall()\n    ]\n    conn.close()\n    return {\"datasets\": datasets}\n</code></pre>"},{"location":"reference/dashboard/routers/secmaster/#onesecondtrader.dashboard.routers.secmaster.api_secmaster_symbols_coverage","title":"<code>api_secmaster_symbols_coverage(publisher_id=None, rtype=None)</code>  <code>async</code>","text":"<p>Return symbol coverage data, optionally filtered by publisher_id and rtype.</p> Source code in <code>src/onesecondtrader/dashboard/routers/secmaster.py</code> <pre><code>@router.get(\"/symbols_coverage\")\nasync def api_secmaster_symbols_coverage(\n    publisher_id: int | None = None, rtype: int | None = None\n) -&gt; dict:\n    \"\"\"Return symbol coverage data, optionally filtered by publisher_id and rtype.\"\"\"\n    db_path = get_secmaster_path()\n    if not os.path.exists(db_path):\n        return {\"symbols\": []}\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    if publisher_id is not None and rtype is not None:\n        cursor.execute(\n            \"SELECT publisher_id, symbol, rtype, min_ts, max_ts FROM symbol_coverage \"\n            \"WHERE publisher_id = ? AND rtype = ? ORDER BY symbol\",\n            (publisher_id, rtype),\n        )\n    elif publisher_id is not None:\n        cursor.execute(\n            \"SELECT publisher_id, symbol, rtype, min_ts, max_ts FROM symbol_coverage \"\n            \"WHERE publisher_id = ? ORDER BY symbol, rtype\",\n            (publisher_id,),\n        )\n    elif rtype is not None:\n        cursor.execute(\n            \"SELECT publisher_id, symbol, rtype, min_ts, max_ts FROM symbol_coverage \"\n            \"WHERE rtype = ? ORDER BY symbol\",\n            (rtype,),\n        )\n    else:\n        cursor.execute(\n            \"SELECT publisher_id, symbol, rtype, min_ts, max_ts FROM symbol_coverage ORDER BY symbol, rtype\"\n        )\n    symbols = [\n        {\n            \"publisher_id\": row[0],\n            \"symbol\": row[1],\n            \"rtype\": row[2],\n            \"min_ts\": row[3],\n            \"max_ts\": row[4],\n        }\n        for row in cursor.fetchall()\n    ]\n    conn.close()\n    return {\"symbols\": symbols}\n</code></pre>"},{"location":"reference/dashboard/routers/strategies/","title":"Strategies","text":"<p>API endpoints for strategy discovery and schema retrieval.</p> <p>Provides endpoints for listing available strategies and retrieving their parameter schemas.</p>"},{"location":"reference/dashboard/routers/strategies/#onesecondtrader.dashboard.routers.strategies.router","title":"<code>router = APIRouter(prefix='/api', tags=['strategies'])</code>  <code>module-attribute</code>","text":""},{"location":"reference/dashboard/routers/strategies/#onesecondtrader.dashboard.routers.strategies.api_strategies","title":"<code>api_strategies()</code>  <code>async</code>","text":"<p>Return list of available strategy classes.</p> Source code in <code>src/onesecondtrader/dashboard/routers/strategies.py</code> <pre><code>@router.get(\"/strategies\")\nasync def api_strategies() -&gt; dict:\n    \"\"\"Return list of available strategy classes.\"\"\"\n    strategies = registry.get_strategies()\n    return {\n        \"strategies\": [\n            {\"id\": name, \"name\": cls.name} for name, cls in strategies.items()\n        ]\n    }\n</code></pre>"},{"location":"reference/dashboard/routers/strategies/#onesecondtrader.dashboard.routers.strategies.api_strategy_schema","title":"<code>api_strategy_schema(name)</code>  <code>async</code>","text":"<p>Return parameter schema for a specific strategy.</p> Source code in <code>src/onesecondtrader/dashboard/routers/strategies.py</code> <pre><code>@router.get(\"/strategies/{name}\")\nasync def api_strategy_schema(name: str) -&gt; dict:\n    \"\"\"Return parameter schema for a specific strategy.\"\"\"\n    schema = registry.get_strategy_schema(name)\n    if schema is None:\n        return {\"error\": \"Strategy not found\"}\n    return schema\n</code></pre>"},{"location":"reference/datafeeds/base/","title":"Base","text":""},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase","title":"<code>DatafeedBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for market data feed implementations.</p> <p>A data feed is responsible for connecting to an external data source, managing symbol and bar-period subscriptions, and publishing market data events onto the system event bus.</p> <p>Concrete subclasses implement the mechanics of connectivity, subscription handling, and lifecycle management for a specific data source.</p>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the data feed with an event bus.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used to publish market data events produced by this data feed.</p> required Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Initialize the data feed with an event bus.\n\n    parameters:\n        event_bus:\n            Event bus used to publish market data events produced by this data feed.\n    \"\"\"\n    self._event_bus = event_bus\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase._publish","title":"<code>_publish(event)</code>","text":"<p>Publish a market data event to the event bus.</p> <p>This method is intended for use by subclasses to forward incoming data from the external source into the internal event-driven system.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to be published.</p> required Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>def _publish(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Publish a market data event to the event bus.\n\n    This method is intended for use by subclasses to forward incoming data from the external source into the internal event-driven system.\n\n    parameters:\n        event:\n            Event instance to be published.\n    \"\"\"\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Establish a connection to the underlying data source.</p> <p>Implementations should perform any required setup, authentication, or resource allocation needed before subscriptions can be registered.</p> Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef connect(self) -&gt; None:\n    \"\"\"\n    Establish a connection to the underlying data source.\n\n    Implementations should perform any required setup, authentication, or resource allocation needed before subscriptions can be registered.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Terminate the connection to the underlying data source.</p> <p>Implementations should release resources and ensure that no further events are published after disconnection.</p> Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Terminate the connection to the underlying data source.\n\n    Implementations should release resources and ensure that no further events are published after disconnection.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.subscribe","title":"<code>subscribe(symbols, bar_period)</code>  <code>abstractmethod</code>","text":"<p>Subscribe to market data for one or more symbols at a given bar period.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>Instrument symbols to subscribe to, interpreted according to the conventions of the underlying data source.</p> required <code>bar_period</code> <code>BarPeriod</code> <p>Bar aggregation period specifying the granularity of market data.</p> required Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef subscribe(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    \"\"\"\n    Subscribe to market data for one or more symbols at a given bar period.\n\n    parameters:\n        symbols:\n            Instrument symbols to subscribe to, interpreted according to the conventions of the underlying data source.\n        bar_period:\n            Bar aggregation period specifying the granularity of market data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.unsubscribe","title":"<code>unsubscribe(symbols, bar_period)</code>  <code>abstractmethod</code>","text":"<p>Cancel existing subscriptions for one or more symbols at a given bar period.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>Instrument symbols for which subscriptions should be removed.</p> required <code>bar_period</code> <code>BarPeriod</code> <p>Bar aggregation period associated with the subscriptions.</p> required Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef unsubscribe(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    \"\"\"\n    Cancel existing subscriptions for one or more symbols at a given bar period.\n\n    parameters:\n        symbols:\n            Instrument symbols for which subscriptions should be removed.\n        bar_period:\n            Bar aggregation period associated with the subscriptions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/datafeeds/base/#onesecondtrader.datafeeds.base.DatafeedBase.wait_until_complete","title":"<code>wait_until_complete()</code>","text":"<p>Block until the data feed has completed all pending work.</p> <p>This method may be overridden by subclasses that perform asynchronous ingestion or background processing. The default implementation does nothing.</p> Source code in <code>src/onesecondtrader/datafeeds/base.py</code> <pre><code>def wait_until_complete(self) -&gt; None:\n    \"\"\"\n    Block until the data feed has completed all pending work.\n\n    This method may be overridden by subclasses that perform asynchronous ingestion or background processing.\n    The default implementation does nothing.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/datafeeds/simulated/","title":"Simulated","text":""},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated._RTYPE_MAP","title":"<code>_RTYPE_MAP = {models.BarPeriod.SECOND: 32, models.BarPeriod.MINUTE: 33, models.BarPeriod.HOUR: 34, models.BarPeriod.DAY: 35}</code>  <code>module-attribute</code>","text":""},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated._RTYPE_TO_BAR_PERIOD","title":"<code>_RTYPE_TO_BAR_PERIOD = {v: kfor (k, v) in (_RTYPE_MAP.items())}</code>  <code>module-attribute</code>","text":""},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed","title":"<code>SimulatedDatafeed</code>","text":"<p>               Bases: <code>DatafeedBase</code></p> <p>Simulated market data feed backed by a secmaster SQLite database.</p> <p>This datafeed replays historical OHLCV bars from a secmaster database, resolving symbols via time-bounded symbology mappings. Bars are delivered in timestamp order, with all bars sharing the same timestamp published before calling <code>wait_until_system_idle</code>.</p> <p>Subclasses must set <code>publisher_name</code>, <code>dataset</code>, and <code>symbol_type</code> as class attributes to scope the feed to a specific data source. The database must contain publishers with numeric <code>source_instrument_id</code> values; symbol-only publishers (e.g., yfinance) are not supported.</p>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used to publish bar events and synchronize with subscribers.</p> required Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Parameters:\n        event_bus:\n            Event bus used to publish bar events and synchronize with subscribers.\n    \"\"\"\n    super().__init__(event_bus)\n    self._db_path = self.db_path or os.environ.get(\n        \"SECMASTER_DB_PATH\", \"secmaster.db\"\n    )\n    if not self.publisher_name:\n        raise ValueError(\"publisher_name is required\")\n    if not self.dataset:\n        raise ValueError(\"dataset is required\")\n    if not self.symbol_type:\n        raise ValueError(\"symbol_type is required\")\n    self._subscriptions: set[tuple[str, models.BarPeriod]] = set()\n    self._subscriptions_lock = threading.Lock()\n    self._connection: sqlite3.Connection | None = None\n    self._thread: threading.Thread | None = None\n    self._stop_event = threading.Event()\n    self._publisher_id: int | None = None\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.connect","title":"<code>connect()</code>","text":"<p>Open a connection to the secmaster database and resolve the publisher.</p> <p>If already connected, this method returns immediately.</p> Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def connect(self) -&gt; None:\n    \"\"\"\n    Open a connection to the secmaster database and resolve the publisher.\n\n    If already connected, this method returns immediately.\n    \"\"\"\n    if self._connection:\n        return\n    self._connection = sqlite3.connect(self._db_path, check_same_thread=False)\n    self._connection.execute(\"PRAGMA foreign_keys = ON\")\n    self._connection.execute(\"PRAGMA journal_mode = WAL\")\n    row = self._connection.execute(\n        \"SELECT publisher_id FROM publishers WHERE name = ? AND dataset = ?\",\n        (self.publisher_name, self.dataset),\n    ).fetchone()\n    if row is None:\n        raise ValueError(\n            f\"Publisher not found: {self.publisher_name}/{self.dataset}\"\n        )\n    self._publisher_id = row[0]\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.disconnect","title":"<code>disconnect()</code>","text":"<p>Close the database connection and stop any active streaming.</p> <p>If not connected, this method returns immediately.</p> Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"\n    Close the database connection and stop any active streaming.\n\n    If not connected, this method returns immediately.\n    \"\"\"\n    if not self._connection:\n        return\n    self._stop_event.set()\n    if self._thread and self._thread.is_alive():\n        self._thread.join()\n    self._connection.close()\n    self._connection = None\n    self._publisher_id = None\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.subscribe","title":"<code>subscribe(symbols, bar_period)</code>","text":"<p>Register symbols for bar delivery at the specified period.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>List of ticker symbols to subscribe.</p> required <code>bar_period</code> <code>BarPeriod</code> <p>Bar aggregation period for the subscription.</p> required Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def subscribe(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    \"\"\"\n    Register symbols for bar delivery at the specified period.\n\n    Parameters:\n        symbols:\n            List of ticker symbols to subscribe.\n        bar_period:\n            Bar aggregation period for the subscription.\n    \"\"\"\n    with self._subscriptions_lock:\n        self._subscriptions.update((s, bar_period) for s in symbols)\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.unsubscribe","title":"<code>unsubscribe(symbols, bar_period)</code>","text":"<p>Remove symbols from bar delivery at the specified period.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[str]</code> <p>List of ticker symbols to unsubscribe.</p> required <code>bar_period</code> <code>BarPeriod</code> <p>Bar aggregation period for the subscription.</p> required Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def unsubscribe(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    \"\"\"\n    Remove symbols from bar delivery at the specified period.\n\n    Parameters:\n        symbols:\n            List of ticker symbols to unsubscribe.\n        bar_period:\n            Bar aggregation period for the subscription.\n    \"\"\"\n    with self._subscriptions_lock:\n        self._subscriptions.difference_update((s, bar_period) for s in symbols)\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed.wait_until_complete","title":"<code>wait_until_complete()</code>","text":"<p>Stream all subscribed bars and block until delivery is complete.</p> <p>Bars are published in timestamp order. After each timestamp batch, the method waits for all event bus subscribers to become idle before proceeding.</p> Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def wait_until_complete(self) -&gt; None:\n    \"\"\"\n    Stream all subscribed bars and block until delivery is complete.\n\n    Bars are published in timestamp order. After each timestamp batch, the method\n    waits for all event bus subscribers to become idle before proceeding.\n    \"\"\"\n    with self._subscriptions_lock:\n        has_subscriptions = bool(self._subscriptions)\n    if not has_subscriptions:\n        return\n    if self._thread is None or not self._thread.is_alive():\n        self._stop_event.clear()\n        self._thread = threading.Thread(\n            target=self._stream,\n            name=self.__class__.__name__,\n            daemon=False,\n        )\n        self._thread.start()\n    self._thread.join()\n</code></pre>"},{"location":"reference/datafeeds/simulated/#onesecondtrader.datafeeds.simulated.SimulatedDatafeed._stream","title":"<code>_stream()</code>","text":"Source code in <code>src/onesecondtrader/datafeeds/simulated.py</code> <pre><code>def _stream(self) -&gt; None:\n    if not self._connection or self._publisher_id is None:\n        return\n\n    with self._subscriptions_lock:\n        subscriptions = list(self._subscriptions)\n    if not subscriptions:\n        return\n\n    symbols = list({symbol for symbol, _ in subscriptions})\n    rtypes = list({_RTYPE_MAP[bp] for _, bp in subscriptions})\n    subscription_set = {(symbol, _RTYPE_MAP[bp]) for symbol, bp in subscriptions}\n\n    params: list = [self._publisher_id, self.symbol_type]\n    params.extend(symbols)\n    params.extend(rtypes)\n    if self.start_ts is not None:\n        params.append(self.start_ts)\n    if self.end_ts is not None:\n        params.append(self.end_ts)\n\n    query = f\"\"\"\n        SELECT s.symbol, o.rtype, o.ts_event, o.open, o.high, o.low, o.close, o.volume\n        FROM ohlcv o\n        JOIN instruments i ON i.instrument_id = o.instrument_id\n        JOIN symbology s\n          ON s.publisher_ref = i.publisher_ref\n         AND s.source_instrument_id = i.source_instrument_id\n         AND date(o.ts_event / 1000000000, 'unixepoch') &gt;= s.start_date\n         AND date(o.ts_event / 1000000000, 'unixepoch') &lt; s.end_date\n        WHERE i.publisher_ref = ?\n          AND s.symbol_type = ?\n          AND s.symbol IN ({\",\".join(\"?\" * len(symbols))})\n          AND o.rtype IN ({\",\".join(\"?\" * len(rtypes))})\n          {\"AND o.ts_event &gt;= ?\" if self.start_ts is not None else \"\"}\n          {\"AND o.ts_event &lt;= ?\" if self.end_ts is not None else \"\"}\n        ORDER BY o.ts_event, s.symbol\n    \"\"\"\n\n    rows = self._connection.execute(query, params)\n\n    def to_bar(row):\n        symbol, rtype, ts_event, open_, high, low, close, volume = row\n        if (symbol, rtype) not in subscription_set:\n            return None\n        return events.market.BarReceived(\n            ts_event_ns=ts_event,\n            symbol=symbol,\n            bar_period=_RTYPE_TO_BAR_PERIOD[rtype],\n            open=open_ / self.price_scale,\n            high=high / self.price_scale,\n            low=low / self.price_scale,\n            close=close / self.price_scale,\n            volume=volume,\n        )\n\n    for _, group in itertools.groupby(rows, key=lambda r: r[2]):\n        if self._stop_event.is_set():\n            return\n        for bar in filter(None, map(to_bar, group)):\n            self._publish(bar)\n        self._event_bus.wait_until_system_idle()\n</code></pre>"},{"location":"reference/events/base/","title":"Base","text":""},{"location":"reference/events/base/#onesecondtrader.events.base.EventBase","title":"<code>EventBase</code>  <code>dataclass</code>","text":"<p>Base class for immutable event message objects, using Unix epoch nanoseconds.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the represented fact occurred, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <p>If not provided, <code>ts_created_ns</code> is assigned automatically at object creation.</p> Source code in <code>src/onesecondtrader/events/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass EventBase:\n    \"\"\"\n    Base class for immutable event message objects, using Unix epoch nanoseconds.\n\n    | Field           | Type   | Semantics                                                              |\n    |-----------------|--------|------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`  | Time at which the represented fact occurred, as UTC epoch nanoseconds. |\n    | `ts_created_ns` | `int`  | Time at which the event object was created, as UTC epoch nanoseconds.  |\n\n    If not provided, `ts_created_ns` is assigned automatically at object creation.\n    \"\"\"\n\n    ts_event_ns: int\n    ts_created_ns: int = dataclasses.field(default_factory=time.time_ns)\n</code></pre>"},{"location":"reference/events/market/bar_processed/","title":"Bar Processed","text":""},{"location":"reference/events/market/bar_processed/#onesecondtrader.events.market.bar_processed.BarProcessed","title":"<code>BarProcessed</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BarReceived</code></p> <p>Event representing a market data bar with computed indicator values.</p> <p>This event extends <code>BarReceived</code> by attaching indicator values derived from the bar data.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the bar was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>bar_period</code> <code>models.data.BarPeriod</code> Time interval represented by the bar. <code>open</code> <code>float</code> Opening price of the bar period. <code>high</code> <code>float</code> Highest traded price during the bar period. <code>low</code> <code>float</code> Lowest traded price during the bar period. <code>close</code> <code>float</code> Closing price of the bar period. <code>volume</code> <code>int</code> or <code>None</code> Traded volume during the bar period, if available. <code>indicators</code> <code>dict[str, float]</code> Mapping of indicator names to computed indicator values. Source code in <code>src/onesecondtrader/events/market/bar_processed.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarProcessed(BarReceived):\n    \"\"\"\n    Event representing a market data bar with computed indicator values.\n\n    This event extends `BarReceived` by attaching indicator values derived from the bar data.\n\n    | Field           | Type                    | Semantics                                                                  |\n    |-----------------|-------------------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`                   | Time at which the bar was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns` | `int`                   | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `symbol`        | `str`                   | Identifier of the traded instrument.                                       |\n    | `bar_period`    | `models.data.BarPeriod` | Time interval represented by the bar.                                      |\n    | `open`          | `float`                 | Opening price of the bar period.                                           |\n    | `high`          | `float`                 | Highest traded price during the bar period.                                |\n    | `low`           | `float`                 | Lowest traded price during the bar period.                                 |\n    | `close`         | `float`                 | Closing price of the bar period.                                           |\n    | `volume`        | `int` or `None`         | Traded volume during the bar period, if available.                         |\n    | `indicators`    | `dict[str, float]`      | Mapping of indicator names to computed indicator values.                   |\n    \"\"\"\n\n    indicators: dict[str, float] = dataclasses.field(default_factory=dict)\n</code></pre>"},{"location":"reference/events/market/bar_received/","title":"Bar Received","text":""},{"location":"reference/events/market/bar_received/#onesecondtrader.events.market.bar_received.BarReceived","title":"<code>BarReceived</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Event representing the reception of a completed market data bar.</p> <p>This event represents a time-aggregated bar as received from a market data source or produced by a resampling process.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the bar was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>bar_period</code> <code>models.data.BarPeriod</code> Time interval represented by the bar. <code>open</code> <code>float</code> Opening price of the bar period. <code>high</code> <code>float</code> Highest traded price during the bar period. <code>low</code> <code>float</code> Lowest traded price during the bar period. <code>close</code> <code>float</code> Closing price of the bar period. <code>volume</code> <code>int</code> or <code>None</code> Traded volume during the bar period, if available. Source code in <code>src/onesecondtrader/events/market/bar_received.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarReceived(events.EventBase):\n    \"\"\"\n    Event representing the reception of a completed market data bar.\n\n    This event represents a time-aggregated bar as received from a market data source or produced by a resampling process.\n\n    | Field           | Type                     | Semantics                                                                   |\n    |-----------------|--------------------------|-----------------------------------------------------------------------------|\n    | `ts_event_ns`   | `int`                    | Time at which the bar was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns` | `int`                    | Time at which the event object was created, as UTC epoch nanoseconds.       |\n    | `symbol`        | `str`                    | Identifier of the traded instrument.                                        |\n    | `bar_period`    | `models.data.BarPeriod`  | Time interval represented by the bar.                                       |\n    | `open`          | `float`                  | Opening price of the bar period.                                            |\n    | `high`          | `float`                  | Highest traded price during the bar period.                                 |\n    | `low`           | `float`                  | Lowest traded price during the bar period.                                  |\n    | `close`         | `float`                  | Closing price of the bar period.                                            |\n    | `volume`        | `int` or `None`          | Traded volume during the bar period, if available.                          |\n    \"\"\"\n\n    symbol: str\n    bar_period: models.BarPeriod\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n</code></pre>"},{"location":"reference/events/orders/base/","title":"Base","text":""},{"location":"reference/events/orders/base/#onesecondtrader.events.orders.base.OrderBase","title":"<code>OrderBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for brokers-originated order events.</p> <p>Order events are brokers-originated facts about the state or execution of an order. Each order event is correlated to a system order identifier via <code>associated_order_id</code>.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the response event was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the response, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code>. Identifier of the order associated with the brokers response. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order, if reported. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/orders/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderBase(events.EventBase):\n    \"\"\"\n    Base class for brokers-originated order events.\n\n    Order events are brokers-originated facts about the state or execution of an order.\n    Each order event is correlated to a system order identifier via `associated_order_id`.\n\n    | Field                 | Type            | Semantics                                                                             |\n    |-----------------------|-----------------|---------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the response event was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                 |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the response, as UTC epoch nanoseconds.               |\n    | `associated_order_id` | `uuid.UUID`.    | Identifier of the order associated with the brokers response.                          |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the order, if reported.                                 |\n    | `symbol`              | `str`           | Identifier of the traded instrument.                                                  |\n    \"\"\"\n\n    ts_broker_ns: int\n    associated_order_id: uuid.UUID\n    broker_order_id: str | None = None\n    symbol: str\n</code></pre>"},{"location":"reference/events/orders/expirations/","title":"Expirations","text":""},{"location":"reference/events/orders/expirations/#onesecondtrader.events.orders.expirations.OrderExpired","title":"<code>OrderExpired</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderBase</code></p> <p>Event indicating that the order is no longer active at the venue due to expiration according to brokers- or venue-specific rules (e.g. time-in-force constraints).</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the expiration was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the expiration, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the expired order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the expired order, if reported. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/orders/expirations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderExpired(OrderBase):\n    \"\"\"\n    Event indicating that the order is no longer active at the venue due to expiration according to brokers- or venue-specific rules (e.g. time-in-force constraints).\n\n    | Field                 | Type            | Semantics                                                                          |\n    |-----------------------|-----------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the expiration was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the expiration, as UTC epoch nanoseconds.          |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the expired order.                                                   |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the expired order, if reported.                      |\n    | `symbol`              | `str`           | Identifier of the traded instrument.                                               |\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/events/orders/fills/","title":"Fills","text":""},{"location":"reference/events/orders/fills/#onesecondtrader.events.orders.fills.FillEvent","title":"<code>FillEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderBase</code></p> <p>Event representing the execution of a trade resulting in a fill.</p> <p>A fill event records the execution of a quantity of an order at a specific price. Multiple fill events may be associated with the same order in the case of partial execution.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the fill was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the fill, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the fill. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order associated with the fill, if available. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>fill_id</code> <code>uuid.UUID</code> System-assigned unique identifier of the fill event. <code>broker_fill_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the execution record, if available. <code>side</code> <code>models.TradeSide</code> Trade direction of the executed quantity. <code>quantity_filled</code> <code>float</code> Quantity executed in this fill. <code>fill_price</code> <code>float</code> Execution price of the fill. <code>commission</code> <code>float</code> Commission or fee associated with the fill. <code>exchange</code> <code>str</code> Identifier of the execution venue. Source code in <code>src/onesecondtrader/events/orders/fills.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass FillEvent(OrderBase):\n    \"\"\"\n    Event representing the execution of a trade resulting in a fill.\n\n    A fill event records the execution of a quantity of an order at a specific price.\n    Multiple fill events may be associated with the same order in the case of partial execution.\n\n    | Field                 | Type                | Semantics                                                                       |\n    |-----------------------|---------------------|---------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`               | Time at which the fill was observed by the system, as UTC epoch nanoseconds.    |\n    | `ts_created_ns`       | `int`               | Time at which the event object was created, as UTC epoch nanoseconds.           |\n    | `ts_broker_ns`        | `int`               | Time reported by the brokers for the fill, as UTC epoch nanoseconds.             |\n    | `associated_order_id` | `uuid.UUID`         | Identifier of the order associated with the fill.                               |\n    | `broker_order_id`     | `str` or `None`     | Broker-assigned identifier of the order associated with the fill, if available. |\n    | `symbol`              | `str`               | Identifier of the traded instrument.                                            |\n    | `fill_id`             | `uuid.UUID`         | System-assigned unique identifier of the fill event.                            |\n    | `broker_fill_id`      | `str` or `None`     | Broker-assigned identifier of the execution record, if available.               |\n    | `side`                | `models.TradeSide`  | Trade direction of the executed quantity.                                       |\n    | `quantity_filled`     | `float`             | Quantity executed in this fill.                                                 |\n    | `fill_price`          | `float`             | Execution price of the fill.                                                    |\n    | `commission`          | `float`             | Commission or fee associated with the fill.                                     |\n    | `exchange`            | `str`               | Identifier of the execution venue.                                              |\n    \"\"\"\n\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    broker_fill_id: str | None = None\n    side: models.TradeSide\n    quantity_filled: float\n    fill_price: float\n    commission: float\n    exchange: str = \"SIMULATED\"\n</code></pre>"},{"location":"reference/events/requests/base/","title":"Base","text":""},{"location":"reference/events/requests/base/#onesecondtrader.events.requests.base.RequestBase","title":"<code>RequestBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for request events.</p> <p>This class defines attributes common to all requests issued to a brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order associated with the request. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/requests/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass RequestBase(events.EventBase):\n    \"\"\"\n    Base class for request events.\n\n    This class defines attributes common to all requests issued to a brokers.\n\n    | Field             | Type        | Semantics                                                                  |\n    |-------------------|-------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`       | Time at which the request was issued, as UTC epoch nanoseconds.            |\n    | `ts_created_ns`   | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `system_order_id` | `uuid.UUID` | System-assigned identifier of the order associated with the request.       |\n    | `symbol`          | `str`       | Identifier of the traded instrument.                                       |\n    \"\"\"\n\n    system_order_id: uuid.UUID\n    symbol: str\n</code></pre>"},{"location":"reference/events/requests/order_cancellation/","title":"Order Cancellation","text":""},{"location":"reference/events/requests/order_cancellation/#onesecondtrader.events.requests.order_cancellation.OrderCancellationRequest","title":"<code>OrderCancellationRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to cancel an existing order.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the cancellation request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order to be cancelled. <code>symbol</code> <code>str</code> Identifier of the traded instrument. Source code in <code>src/onesecondtrader/events/requests/order_cancellation.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderCancellationRequest(RequestBase):\n    \"\"\"\n    Event representing a request to cancel an existing order.\n\n    | Field             | Type        | Semantics                                                                    |\n    |-------------------|-------------|------------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`       | Time at which the cancellation request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.        |\n    | `system_order_id` | `uuid.UUID` | System-assigned identifier of the order to be cancelled.                     |\n    | `symbol`          | `str`       | Identifier of the traded instrument.                                         |\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/events/requests/order_modification/","title":"Order Modification","text":""},{"location":"reference/events/requests/order_modification/#onesecondtrader.events.requests.order_modification.OrderModificationRequest","title":"<code>OrderModificationRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to modify an existing order.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the modification request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned identifier of the order to be modified. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>quantity</code> <code>float</code> or <code>None</code> Updated order quantity, if modified. <code>limit_price</code> <code>float</code> or <code>None</code> Updated limit price, if modified. <code>stop_price</code> <code>float</code> or <code>None</code> Updated stop price, if modified. Source code in <code>src/onesecondtrader/events/requests/order_modification.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderModificationRequest(RequestBase):\n    \"\"\"\n    Event representing a request to modify an existing order.\n\n    | Field             | Type              | Semantics                                                                    |\n    |-------------------|-------------------|------------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`             | Time at which the modification request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`             | Time at which the event object was created, as UTC epoch nanoseconds.        |\n    | `system_order_id` | `uuid.UUID`       | System-assigned identifier of the order to be modified.                      |\n    | `symbol`          | `str`             | Identifier of the traded instrument.                                         |\n    | `quantity`        | `float` or `None` | Updated order quantity, if modified.                                         |\n    | `limit_price`     | `float` or `None` | Updated limit price, if modified.                                            |\n    | `stop_price`      | `float` or `None` | Updated stop price, if modified.                                             |\n    \"\"\"\n\n    quantity: float | None = None\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"reference/events/requests/order_submission/","title":"Order Submission","text":""},{"location":"reference/events/requests/order_submission/#onesecondtrader.events.requests.order_submission.OrderSubmissionRequest","title":"<code>OrderSubmissionRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RequestBase</code></p> <p>Event representing a request to submit a new order to a brokers.</p> <p>The <code>system_order_id</code> is a unique identifier assigned by the system to the order submission request by default at object creation.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the submission request was issued, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>system_order_id</code> <code>uuid.UUID</code> System-assigned unique identifier for the order submission. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>order_type</code> <code>models.OrderType</code> Execution constraint of the order. <code>side</code> <code>models.TradeSide</code> Direction of the trade. <code>quantity</code> <code>float</code> Requested order quantity. <code>limit_price</code> <code>float</code> or <code>None</code> Limit price, if applicable to the order type. <code>stop_price</code> <code>float</code> or <code>None</code> Stop price, if applicable to the order type. <code>action</code> <code>models.ActionType</code> or <code>None</code> Intent of the order from the strategy's perspective (e.g., entry, exit). <code>signal</code> <code>str</code> or <code>None</code> Optional signal name or identifier that triggered this order. Source code in <code>src/onesecondtrader/events/requests/order_submission.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderSubmissionRequest(RequestBase):\n    \"\"\"\n    Event representing a request to submit a new order to a brokers.\n\n    The `system_order_id` is a unique identifier assigned by the system to the order submission request by default at object creation.\n\n    | Field             | Type                       | Semantics                                                                  |\n    |-------------------|----------------------------|----------------------------------------------------------------------------|\n    | `ts_event_ns`     | `int`                      | Time at which the submission request was issued, as UTC epoch nanoseconds. |\n    | `ts_created_ns`   | `int`                      | Time at which the event object was created, as UTC epoch nanoseconds.      |\n    | `system_order_id` | `uuid.UUID`                | System-assigned unique identifier for the order submission.                |\n    | `symbol`          | `str`                      | Identifier of the traded instrument.                                       |\n    | `order_type`      | `models.OrderType`         | Execution constraint of the order.                                         |\n    | `side`            | `models.TradeSide`         | Direction of the trade.                                                    |\n    | `quantity`        | `float`                    | Requested order quantity.                                                  |\n    | `limit_price`     | `float` or `None`          | Limit price, if applicable to the order type.                              |\n    | `stop_price`      | `float` or `None`          | Stop price, if applicable to the order type.                               |\n    | `action`          | `models.ActionType` or `None` | Intent of the order from the strategy's perspective (e.g., entry, exit).   |\n    | `signal`          | `str` or `None`            | Optional signal name or identifier that triggered this order.              |\n    \"\"\"\n\n    system_order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    order_type: models.OrderType\n    side: models.TradeSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n    action: models.ActionType | None = None\n    signal: str | None = None\n</code></pre>"},{"location":"reference/events/responses/base/","title":"Base","text":""},{"location":"reference/events/responses/base/#onesecondtrader.events.responses.base.ResponseBase","title":"<code>ResponseBase</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> <p>Base class for brokers response events.</p> <p>This class defines attributes common to all responses received from a brokers in reaction to previously issued requests.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the response event was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the response, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the brokers response. Source code in <code>src/onesecondtrader/events/responses/base.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ResponseBase(events.EventBase):\n    \"\"\"\n    Base class for brokers response events.\n\n    This class defines attributes common to all responses received from a brokers in reaction to previously issued requests.\n\n    | Field                 | Type        | Semantics                                                                             |\n    |-----------------------|-------------|---------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`       | Time at which the response event was observed by the system, as UTC epoch nanoseconds.|\n    | `ts_created_ns`       | `int`       | Time at which the event object was created, as UTC epoch nanoseconds.                 |\n    | `ts_broker_ns`        | `int`       | Time reported by the brokers for the response, as UTC epoch nanoseconds.               |\n    | `associated_order_id` | `uuid.UUID` | Identifier of the order associated with the brokers response.                          |\n    \"\"\"\n\n    ts_broker_ns: int\n    associated_order_id: uuid.UUID\n</code></pre>"},{"location":"reference/events/responses/cancellations/","title":"Cancellations","text":""},{"location":"reference/events/responses/cancellations/#onesecondtrader.events.responses.cancellations.CancellationAccepted","title":"<code>CancellationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order cancellation has been acknowledged by the brokers and the order is no longer active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the cancellation was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the cancellation, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the cancelled order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the cancelled order, if reported. Source code in <code>src/onesecondtrader/events/responses/cancellations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass CancellationAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the order cancellation has been acknowledged by the brokers and the order is no longer active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                              |\n    |-----------------------|-----------------|----------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the cancellation was observed by the system, as UTC epoch nanoseconds.   |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                  |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the cancellation, as UTC epoch nanoseconds.            |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the cancelled order.                                                     |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the cancelled order, if reported.                        |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/cancellations/#onesecondtrader.events.responses.cancellations.CancellationRejected","title":"<code>CancellationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order cancellation has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the rejected cancellation. <code>rejection_reason</code> <code>models.CancellationRejectionReason</code> Canonical classification of the cancellation rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/cancellations.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass CancellationRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the order cancellation has been rejected by the brokers.\n\n    | Field                 | Type                                 | Semantics                                                                          |\n    |-----------------------|--------------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                                | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                                | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                                | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                          | Identifier of the order associated with the rejected cancellation.                 |\n    | `rejection_reason`    | `models.CancellationRejectionReason` | Canonical classification of the cancellation rejection cause.                      |\n    | `rejection_message`   | `str`                                | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.CancellationRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/events/responses/modifications/","title":"Modifications","text":""},{"location":"reference/events/responses/modifications/#onesecondtrader.events.responses.modifications.ModificationAccepted","title":"<code>ModificationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the requested modification has been acknowledged by the brokers and that the updated order parameters are active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the modification acceptance, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the modified order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the order after modification, if reported. Source code in <code>src/onesecondtrader/events/responses/modifications.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ModificationAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the requested modification has been acknowledged by\n    the brokers and that the updated order parameters are active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                              |\n    |-----------------------|-----------------|----------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the acceptance was observed by the system, as UTC epoch nanoseconds.     |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.                  |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the modification acceptance, as UTC epoch nanoseconds. |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the modified order.                                                      |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the order after modification, if reported.               |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/modifications/#onesecondtrader.events.responses.modifications.ModificationRejected","title":"<code>ModificationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the requested modification has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the rejected modification. <code>rejection_reason</code> <code>models.ModificationRejectionReason</code> Canonical classification of the modification rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/modifications.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass ModificationRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the requested modification has been rejected by the brokers.\n\n    | Field                 | Type                                 | Semantics                                                                          |\n    |-----------------------|--------------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                                | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                                | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                                | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                          | Identifier of the order associated with the rejected modification.                 |\n    | `rejection_reason`    | `models.ModificationRejectionReason` | Canonical classification of the modification rejection cause.                      |\n    | `rejection_message`   | `str`                                | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.ModificationRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/events/responses/orders/","title":"Orders","text":""},{"location":"reference/events/responses/orders/#onesecondtrader.events.responses.orders.OrderAccepted","title":"<code>OrderAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order has been accepted by the brokers and is active at the execution venue.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the acceptance, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the accepted order. <code>broker_order_id</code> <code>str</code> or <code>None</code> Broker-assigned identifier of the accepted order. Source code in <code>src/onesecondtrader/events/responses/orders.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderAccepted(ResponseBase):\n    \"\"\"\n    Event indicating that the order has been accepted by the brokers and is active at the execution venue.\n\n    | Field                 | Type            | Semantics                                                                          |\n    |-----------------------|-----------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`           | Time at which the acceptance was observed by the system, as UTC epoch nanoseconds. |\n    | `ts_created_ns`       | `int`           | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`           | Time reported by the brokers for the acceptance, as UTC epoch nanoseconds.          |\n    | `associated_order_id` | `uuid.UUID`     | Identifier of the accepted order.                                                  |\n    | `broker_order_id`     | `str` or `None` | Broker-assigned identifier of the accepted order.                                  |\n    \"\"\"\n\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"reference/events/responses/orders/#onesecondtrader.events.responses.orders.OrderRejected","title":"<code>OrderRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ResponseBase</code></p> <p>Event indicating that the order has been rejected by the brokers.</p> Field Type Semantics <code>ts_event_ns</code> <code>int</code> Time at which the rejection was observed by the system, as UTC epoch nanoseconds. <code>ts_created_ns</code> <code>int</code> Time at which the event object was created, as UTC epoch nanoseconds. <code>ts_broker_ns</code> <code>int</code> Time reported by the brokers for the rejection, as UTC epoch nanoseconds. <code>associated_order_id</code> <code>uuid.UUID</code> Identifier of the rejected order. <code>rejection_reason</code> <code>models.OrderRejectionReason</code> Canonical classification of the rejection cause. <code>rejection_message</code> <code>str</code> Human-readable explanation provided by the brokers. Source code in <code>src/onesecondtrader/events/responses/orders.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True, slots=True)\nclass OrderRejected(ResponseBase):\n    \"\"\"\n    Event indicating that the order has been rejected by the brokers.\n\n    | Field                 | Type                          | Semantics                                                                          |\n    |-----------------------|-------------------------------|------------------------------------------------------------------------------------|\n    | `ts_event_ns`         | `int`                         | Time at which the rejection was observed by the system, as UTC epoch nanoseconds.  |\n    | `ts_created_ns`       | `int`                         | Time at which the event object was created, as UTC epoch nanoseconds.              |\n    | `ts_broker_ns`        | `int`                         | Time reported by the brokers for the rejection, as UTC epoch nanoseconds.           |\n    | `associated_order_id` | `uuid.UUID`                   | Identifier of the rejected order.                                                  |\n    | `rejection_reason`    | `models.OrderRejectionReason` | Canonical classification of the rejection cause.                                   |\n    | `rejection_message`   | `str`                         | Human-readable explanation provided by the brokers.                                 |\n    \"\"\"\n\n    rejection_reason: models.OrderRejectionReason\n    rejection_message: str\n</code></pre>"},{"location":"reference/indicators/base/","title":"Base","text":""},{"location":"reference/indicators/base/#onesecondtrader.indicators.base._indicator_registry","title":"<code>_indicator_registry = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase","title":"<code>IndicatorBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for scalar technical indicators with per-symbol history.</p> <p>The class provides a thread-safe mechanism for storing and retrieving indicator values computed from incoming market bars, keyed by symbol. It does not manage input windows or rolling computation state.</p> <p>Subclasses define a stable indicator identifier via the <code>name</code> property and implement <code>_compute_indicator</code>, which computes a single scalar value per incoming bar. Indicators with multiple conceptual outputs must be implemented as multiple single-output indicators (e.g. Bollinger Bands must be implemented via three separate indicators <code>BBUpper</code>, <code>BBMiddle</code>, and <code>BBLower</code>).</p> <p>The update mechanism is thread-safe. Indicator computation is performed outside the internal lock. Subclasses that maintain internal state are responsible for ensuring its thread safety and must not access <code>_history_data</code>.</p> <p>Indicator values are stored per symbol in bounded FIFO buffers. Missing data and out-of-bounds access yield <code>numpy.nan</code>.</p> <p>The <code>plot_at</code> attribute is an opaque identifier forwarded to the charting backend and has no intrinsic meaning within the indicator subsystem. The <code>plot_as</code> attribute specifies the visual style used to render the indicator.</p> <p>Subclasses are automatically registered for discovery when defined.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Stable identifier used for charting and downstream integration.\n    \"\"\"\n    pass\n</code></pre> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def plot_at(self) -&gt; int:\n    \"\"\"\n    Plotting identifier.\n\n    Returns:\n        Opaque identifier consumed by the charting backend.\n    \"\"\"\n    return self._plot_at\n</code></pre> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def plot_as(self) -&gt; models.PlotStyle:\n    \"\"\"\n    Plotting style.\n\n    Returns:\n        Visual style used to render the indicator.\n    \"\"\"\n    return self._plot_as\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Stable identifier used for charting and downstream integration.</p>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.plot_at","title":"<code>plot_at</code>  <code>property</code>","text":"<p>Plotting identifier.</p> <p>Returns:</p> Type Description <code>int</code> <p>Opaque identifier consumed by the charting backend.</p>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.plot_as","title":"<code>plot_as</code>  <code>property</code>","text":"<p>Plotting style.</p> <p>Returns:</p> Type Description <code>PlotStyle</code> <p>Visual style used to render the indicator.</p>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def __init_subclass__(cls, **kwargs: object) -&gt; None:\n    super().__init_subclass__(**kwargs)\n    if not cls.__name__.startswith(\"_\"):\n        _indicator_registry[cls.__name__] = cls\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.__init__","title":"<code>__init__(max_history=100, plot_at=99, plot_as=models.PlotStyle.LINE)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>max_history</code> <code>int</code> <p>Maximum number of indicator values retained per symbol. Cannot be less than 1.</p> <code>100</code> <code>plot_at</code> <code>int</code> <p>Opaque plotting identifier forwarded to the charting backend.</p> <code>99</code> <code>plot_as</code> <code>PlotStyle</code> <p>Visual style used to render the indicator.</p> <code>LINE</code> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def __init__(\n    self,\n    max_history: int = 100,\n    plot_at: int = 99,\n    plot_as: models.PlotStyle = models.PlotStyle.LINE,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        max_history:\n            Maximum number of indicator values retained per symbol.\n            Cannot be less than 1.\n        plot_at:\n            Opaque plotting identifier forwarded to the charting backend.\n        plot_as:\n            Visual style used to render the indicator.\n    \"\"\"\n    self._lock = threading.Lock()\n    self._max_history = max(1, int(max_history))\n    self._history_data: dict[str, collections.deque[float]] = {}\n    self._plot_at = plot_at\n    self._plot_as = plot_as\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>  <code>abstractmethod</code>","text":"<p>Compute the indicator value for a single market bar.</p> <p>This method is executed outside the internal lock. Implementations must not access <code>_history_data</code> and must ensure thread safety of any internal computation state.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input for indicator computation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Computed indicator value.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>@abc.abstractmethod\ndef _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Compute the indicator value for a single market bar.\n\n    This method is executed outside the internal lock.\n    Implementations must not access `_history_data` and must ensure thread safety of any internal computation state.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input for indicator computation.\n\n    Returns:\n        Computed indicator value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.update","title":"<code>update(incoming_bar)</code>","text":"<p>Update the indicator with a new market bar.</p> <p>The computed value is appended to the per-symbol history buffer.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar triggering the update.</p> required Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def update(self, incoming_bar: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Update the indicator with a new market bar.\n\n    The computed value is appended to the per-symbol history buffer.\n\n    Parameters:\n        incoming_bar:\n            Market bar triggering the update.\n    \"\"\"\n    symbol = incoming_bar.symbol\n\n    value = self._compute_indicator(incoming_bar)\n\n    with self._lock:\n        if symbol not in self._history_data:\n            self._history_data[symbol] = collections.deque(maxlen=self._max_history)\n\n        self._history_data[symbol].append(value)\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.latest","title":"<code>latest(symbol)</code>","text":"<p>Return the most recent indicator value for a symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Symbol identifier.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Most recent value, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def latest(self, symbol: str) -&gt; float:\n    \"\"\"\n    Return the most recent indicator value for a symbol.\n\n    Parameters:\n        symbol:\n            Symbol identifier.\n\n    Returns:\n        Most recent value, or `numpy.nan` if unavailable.\n    \"\"\"\n    return self[symbol, -1]\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.IndicatorBase.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve an indicator value by symbol and index.</p> <p>Indexing follows standard Python sequence semantics. Negative indices refer to positions relative to the most recent value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>tuple[str, int]</code> <p><code>(symbol, index)</code> pair specifying the symbol and history offset.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Indicator value at the specified position, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def __getitem__(self, key: tuple[str, int]) -&gt; float:\n    \"\"\"\n    Retrieve an indicator value by symbol and index.\n\n    Indexing follows standard Python sequence semantics.\n    Negative indices refer to positions relative to the most recent value.\n\n    Parameters:\n        key:\n            `(symbol, index)` pair specifying the symbol and history offset.\n\n    Returns:\n        Indicator value at the specified position, or `numpy.nan` if unavailable.\n    \"\"\"\n    symbol, index = key\n\n    with self._lock:\n        history = self._history_data.get(symbol)\n\n        if history is None:\n            return np.nan\n\n        try:\n            return history[index]\n        except IndexError:\n            return np.nan\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.get_registered_indicators","title":"<code>get_registered_indicators()</code>","text":"<p>Return all registered indicator classes.</p> <p>Returns:</p> Type Description <code>dict[str, type[IndicatorBase]]</code> <p>Dictionary mapping indicator class names to their class objects.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def get_registered_indicators() -&gt; dict[str, type[IndicatorBase]]:\n    \"\"\"\n    Return all registered indicator classes.\n\n    Returns:\n        Dictionary mapping indicator class names to their class objects.\n    \"\"\"\n    return dict(_indicator_registry)\n</code></pre>"},{"location":"reference/indicators/base/#onesecondtrader.indicators.base.discover_indicators","title":"<code>discover_indicators(directory='indicators')</code>","text":"<p>Import all Python files from a directory to register indicators.</p> <p>Any class inheriting from IndicatorBase in the imported files will be automatically registered via init_subclass.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Path to the directory containing indicator files. Defaults to \"indicators\" relative to the current working directory.</p> <code>'indicators'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of successfully imported module names.</p> Source code in <code>src/onesecondtrader/indicators/base.py</code> <pre><code>def discover_indicators(directory: str | Path = \"indicators\") -&gt; list[str]:\n    \"\"\"\n    Import all Python files from a directory to register indicators.\n\n    Any class inheriting from IndicatorBase in the imported files will be\n    automatically registered via __init_subclass__.\n\n    Parameters:\n        directory:\n            Path to the directory containing indicator files.\n            Defaults to \"indicators\" relative to the current working directory.\n\n    Returns:\n        List of successfully imported module names.\n    \"\"\"\n    path = Path(directory)\n    if not path.is_dir():\n        return []\n\n    imported = []\n    for file in path.glob(\"*.py\"):\n        if file.name.startswith(\"_\"):\n            continue\n\n        module_name = f\"user_indicators.{file.stem}\"\n        spec = importlib.util.spec_from_file_location(module_name, file)\n        if spec is None or spec.loader is None:\n            continue\n\n        module = importlib.util.module_from_spec(spec)\n        try:\n            spec.loader.exec_module(module)\n            imported.append(file.stem)\n        except Exception:\n            pass\n\n    return imported\n</code></pre>"},{"location":"reference/indicators/market_fields/","title":"Market Fields","text":""},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open","title":"<code>Open</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Open price indicator.</p> <p>This indicator exposes the open price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the open price indicator.\n    \"\"\"\n    return \"OPEN\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the open price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Open._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the open price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Open price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the open price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Open price of the bar.\n    \"\"\"\n    return incoming_bar.open\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High","title":"<code>High</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>High price indicator.</p> <p>This indicator exposes the high price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the high price indicator.\n    \"\"\"\n    return \"HIGH\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the high price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.High._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the high price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>High price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the high price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        High price of the bar.\n    \"\"\"\n    return incoming_bar.high\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low","title":"<code>Low</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Low price indicator.</p> <p>This indicator exposes the low price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the low price indicator.\n    \"\"\"\n    return \"LOW\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the low price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Low._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the low price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Low price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the low price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Low price of the bar.\n    \"\"\"\n    return incoming_bar.low\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close","title":"<code>Close</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Close price indicator.</p> <p>This indicator exposes the close price of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the close price indicator.\n    \"\"\"\n    return \"CLOSE\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the close price indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Close._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the close price from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Close price of the bar.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the close price from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Close price of the bar.\n    \"\"\"\n    return incoming_bar.close\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume","title":"<code>Volume</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Volume indicator.</p> <p>This indicator exposes the traded volume of each incoming market bar as a scalar time series. Values are stored per symbol and can be accessed historically via the indicator interface. Missing volume values yield <code>numpy.nan</code>.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Fixed identifier for the volume indicator.\n    \"\"\"\n    return \"VOLUME\"\n</code></pre>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Fixed identifier for the volume indicator.</p>"},{"location":"reference/indicators/market_fields/#onesecondtrader.indicators.market_fields.Volume._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Extract the volume from an incoming market bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Volume of the bar, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/market_fields.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the volume from an incoming market bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input.\n\n    Returns:\n        Volume of the bar, or `numpy.nan` if unavailable.\n    \"\"\"\n    return float(incoming_bar.volume) if incoming_bar.volume is not None else np.nan\n</code></pre>"},{"location":"reference/indicators/moving_averages/","title":"Moving Averages","text":""},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>IndicatorBase</code></p> <p>Simple Moving Average (SMA) indicator.</p> <p>This indicator computes the arithmetic mean of a selected bar field over a fixed rolling window. One scalar value is produced per incoming bar and stored per symbol.</p> <p>The rolling window is maintained independently for each symbol. Until the window is fully populated, the indicator yields <code>numpy.nan</code>.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def name(self) -&gt; str:\n    \"\"\"\n    Canonical indicator name.\n\n    Returns:\n        Identifier encoding the indicator type, period, and bar field.\n    \"\"\"\n    return f\"SMA_{self.period}_{self.bar_field.name}\"\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage.name","title":"<code>name</code>  <code>property</code>","text":"<p>Canonical indicator name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Identifier encoding the indicator type, period, and bar field.</p>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage.__init__","title":"<code>__init__(period=200, max_history=100, bar_field=models.BarField.CLOSE, plot_at=0, plot_as=models.PlotStyle.LINE)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size used to compute the moving average.</p> <code>200</code> <code>max_history</code> <code>int</code> <p>Maximum number of computed indicator values retained per symbol.</p> <code>100</code> <code>bar_field</code> <code>BarField</code> <p>Bar field used as the input series.</p> <code>CLOSE</code> <code>plot_at</code> <code>int</code> <p>Opaque plotting identifier forwarded to the charting backend.</p> <code>0</code> <code>plot_as</code> <code>PlotStyle</code> <p>Visual style used to render the indicator.</p> <code>LINE</code> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def __init__(\n    self,\n    period: int = 200,\n    max_history: int = 100,\n    bar_field: models.BarField = models.BarField.CLOSE,\n    plot_at: int = 0,\n    plot_as: models.PlotStyle = models.PlotStyle.LINE,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        period:\n            Window size used to compute the moving average.\n        max_history:\n            Maximum number of computed indicator values retained per symbol.\n        bar_field:\n            Bar field used as the input series.\n        plot_at:\n            Opaque plotting identifier forwarded to the charting backend.\n        plot_as:\n            Visual style used to render the indicator.\n    \"\"\"\n    super().__init__(max_history=max_history, plot_at=plot_at, plot_as=plot_as)\n\n    self.period: int = max(1, int(period))\n    self.bar_field: models.BarField = bar_field\n    self._window: dict[str, collections.deque[float]] = {}\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Compute the simple moving average for a single received bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar used as input for the computation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Simple moving average value, or <code>numpy.nan</code> if the rolling window is not yet fully populated.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Compute the simple moving average for a single received bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar used as input for the computation.\n\n    Returns:\n        Simple moving average value, or `numpy.nan` if the rolling window is not yet fully populated.\n    \"\"\"\n    symbol = incoming_bar.symbol\n    if symbol not in self._window:\n        self._window[symbol] = collections.deque(maxlen=self.period)\n\n    window = self._window[symbol]\n    value = self._extract_field(incoming_bar)\n    window.append(value)\n\n    if len(window) &lt; self.period:\n        return np.nan\n    return sum(window) / self.period\n</code></pre>"},{"location":"reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage._extract_field","title":"<code>_extract_field(incoming_bar)</code>","text":"<p>Extract the configured bar field from an incoming bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>BarReceived</code> <p>Market bar providing the input data.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Extracted field value, or <code>numpy.nan</code> if unavailable.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def _extract_field(self, incoming_bar: events.market.BarReceived) -&gt; float:\n    \"\"\"\n    Extract the configured bar field from an incoming bar.\n\n    Parameters:\n        incoming_bar:\n            Market bar providing the input data.\n\n    Returns:\n        Extracted field value, or `numpy.nan` if unavailable.\n    \"\"\"\n    match self.bar_field:\n        case models.BarField.OPEN:\n            return incoming_bar.open\n        case models.BarField.HIGH:\n            return incoming_bar.high\n        case models.BarField.LOW:\n            return incoming_bar.low\n        case models.BarField.CLOSE:\n            return incoming_bar.close\n        case models.BarField.VOLUME:\n            return (\n                float(incoming_bar.volume)\n                if incoming_bar.volume is not None\n                else np.nan\n            )\n        case _:\n            return incoming_bar.close\n</code></pre>"},{"location":"reference/messaging/eventbus/","title":"Eventbus","text":""},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus","title":"<code>EventBus</code>","text":"<p>Event dispatch mechanism for propagating event objects to subscribers.</p> <p>The event bus maintains subscriptions between subscribers and concrete event types. Events published to the bus are synchronously delivered to all subscribers registered for the exact event type.</p> <p>Subscription management and event publication are thread-safe. Event delivery itself occurs outside the internal lock.</p>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty event bus.</p> <p>The bus starts with no registered subscribers and no active subscriptions.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize an empty event bus.\n\n    The bus starts with no registered subscribers and no active subscriptions.\n    \"\"\"\n    self._per_event_subscriptions: collections.defaultdict[\n        type[events.EventBase], set[Subscriber]\n    ] = collections.defaultdict(set)\n    self._subscribers: set[Subscriber] = set()\n    self._lock: threading.Lock = threading.Lock()\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.subscribe","title":"<code>subscribe(subscriber, event_type)</code>","text":"<p>Register a subscriber for a specific event type.</p> <p>The subscriber will receive all future events whose concrete type matches <code>event_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>subscriber</code> <code>Subscriber</code> <p>Object receiving published events.</p> required <code>event_type</code> <code>type[EventBase]</code> <p>Concrete event class the subscriber is interested in.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def subscribe(\n    self,\n    subscriber: Subscriber,\n    event_type: type[events.EventBase],\n) -&gt; None:\n    \"\"\"\n    Register a subscriber for a specific event type.\n\n    The subscriber will receive all future events whose concrete type matches `event_type`.\n\n    Parameters:\n        subscriber:\n            Object receiving published events.\n        event_type:\n            Concrete event class the subscriber is interested in.\n    \"\"\"\n    with self._lock:\n        self._subscribers.add(subscriber)\n        self._per_event_subscriptions[event_type].add(subscriber)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(subscriber)</code>","text":"<p>Remove a subscriber from all event subscriptions.</p> <p>After unsubscription, the subscriber will no longer receive any events published on this bus.</p> <p>Parameters:</p> Name Type Description Default <code>subscriber</code> <code>Subscriber</code> <p>Subscriber to remove.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def unsubscribe(self, subscriber: Subscriber) -&gt; None:\n    \"\"\"\n    Remove a subscriber from all event subscriptions.\n\n    After unsubscription, the subscriber will no longer receive any events published on this bus.\n\n    Parameters:\n        subscriber:\n            Subscriber to remove.\n    \"\"\"\n    with self._lock:\n        for set_of_event_subscribers in self._per_event_subscriptions.values():\n            set_of_event_subscribers.discard(subscriber)\n        self._subscribers.discard(subscriber)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"<p>Publish an event to all subscribed listeners.</p> <p>Subscribers are matched strictly by the concrete type of the event. Parent classes and inheritance relationships are not considered.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to dispatch.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def publish(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Publish an event to all subscribed listeners.\n\n    Subscribers are matched strictly by the concrete type of the event.\n    Parent classes and inheritance relationships are not considered.\n\n    Parameters:\n        event:\n            Event instance to dispatch.\n    \"\"\"\n    with self._lock:\n        subscribers = self._per_event_subscriptions[type(event)].copy()\n    for subscriber in subscribers:\n        subscriber.receive(event)\n</code></pre>"},{"location":"reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.wait_until_system_idle","title":"<code>wait_until_system_idle()</code>","text":"<p>Block until all subscribers report an idle state.</p> <p>This method delegates to each subscriber's <code>wait_until_idle</code> method and returns only after all subscribers have completed any pending work.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def wait_until_system_idle(self) -&gt; None:\n    \"\"\"\n    Block until all subscribers report an idle state.\n\n    This method delegates to each subscriber's `wait_until_idle` method and returns only after all subscribers have completed any pending work.\n    \"\"\"\n    with self._lock:\n        subscribers = self._subscribers.copy()\n    for subscriber in subscribers:\n        subscriber.wait_until_idle()\n</code></pre>"},{"location":"reference/messaging/subscriber/","title":"Subscriber","text":""},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber","title":"<code>Subscriber</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for event bus subscribers.</p> <p>A subscriber receives events from an event bus and processes them asynchronously in a dedicated worker thread. Incoming events are queued and handled sequentially.</p> <p>Subclasses implement <code>_on_event</code> to define event-specific behavior.</p>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the subscriber and start its event-processing thread.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for subscribing to and publishing events.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    \"\"\"\n    Initialize the subscriber and start its event-processing thread.\n\n    Parameters:\n        event_bus:\n            Event bus used for subscribing to and publishing events.\n    \"\"\"\n    self._event_bus = event_bus\n    self._queue: queue.Queue[events.EventBase | None] = queue.Queue()\n\n    self._running: threading.Event = threading.Event()\n    self._running.set()\n\n    self._thread = threading.Thread(\n        target=self._event_loop, name=self.__class__.__name__\n    )\n    self._thread.start()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.receive","title":"<code>receive(event)</code>","text":"<p>Receive an event from the event bus.</p> <p>The event is enqueued for asynchronous processing if the subscriber is running.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance delivered by the event bus.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def receive(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Receive an event from the event bus.\n\n    The event is enqueued for asynchronous processing if the subscriber is running.\n\n    Parameters:\n        event:\n            Event instance delivered by the event bus.\n    \"\"\"\n    if self._running.is_set():\n        self._queue.put(event)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.wait_until_idle","title":"<code>wait_until_idle()</code>","text":"<p>Block until all queued events have been processed.</p> <p>If the subscriber is not running, this method returns immediately.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def wait_until_idle(self) -&gt; None:\n    \"\"\"\n    Block until all queued events have been processed.\n\n    If the subscriber is not running, this method returns immediately.\n    \"\"\"\n    if not self._running.is_set():\n        return\n\n    self._queue.join()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber.shutdown","title":"<code>shutdown()</code>","text":"<p>Shut down the subscriber and stop event processing.</p> <p>The subscriber is unsubscribed from the event bus, its worker thread is signaled to terminate, and all pending events are processed before shutdown completes.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shut down the subscriber and stop event processing.\n\n    The subscriber is unsubscribed from the event bus, its worker thread is signaled to terminate, and all pending events are processed before shutdown completes.\n    \"\"\"\n    if not self._running.is_set():\n        return\n\n    self._event_bus.unsubscribe(self)\n    self._running.clear()\n    self._queue.put(None)\n\n    if threading.current_thread() is not self._thread:\n        self._thread.join()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._subscribe","title":"<code>_subscribe(*event_types)</code>","text":"<p>Subscribe this subscriber to one or more event types.</p> <p>Parameters:</p> Name Type Description Default <code>*event_types</code> <code>type[EventBase]</code> <p>Concrete event classes to subscribe to.</p> <code>()</code> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _subscribe(self, *event_types: type[events.EventBase]) -&gt; None:\n    \"\"\"\n    Subscribe this subscriber to one or more event types.\n\n    Parameters:\n        *event_types:\n            Concrete event classes to subscribe to.\n    \"\"\"\n    for event_type in event_types:\n        self._event_bus.subscribe(self, event_type)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._publish","title":"<code>_publish(event)</code>","text":"<p>Publish an event to the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to publish.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _publish(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Publish an event to the event bus.\n\n    Parameters:\n        event:\n            Event instance to publish.\n    \"\"\"\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._event_loop","title":"<code>_event_loop()</code>","text":"<p>Internal worker loop for processing queued events.</p> <p>This method runs in a dedicated thread and should not be called directly.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _event_loop(self) -&gt; None:\n    \"\"\"\n    Internal worker loop for processing queued events.\n\n    This method runs in a dedicated thread and should not be called directly.\n    \"\"\"\n    while True:\n        event = self._queue.get()\n\n        if event is None:\n            self._queue.task_done()\n            break\n\n        try:\n            self._on_event(event)\n        except Exception as exc:\n            self._on_exception(exc)\n        finally:\n            self._queue.task_done()\n\n    self._cleanup()\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._on_exception","title":"<code>_on_exception(exc)</code>","text":"<p>Handle an exception raised during event processing.</p> <p>Subclasses may override this method to implement logging or recovery behavior. The default implementation ignores the exception.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>Exception raised while processing an event.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _on_exception(self, exc: Exception) -&gt; None:\n    \"\"\"\n    Handle an exception raised during event processing.\n\n    Subclasses may override this method to implement logging or recovery behavior.\n    The default implementation ignores the exception.\n\n    Parameters:\n        exc:\n            Exception raised while processing an event.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._cleanup","title":"<code>_cleanup()</code>","text":"<p>Perform cleanup after the event loop terminates.</p> <p>Subclasses may override this method to release resources or emit shutdown notifications.</p> Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>def _cleanup(self) -&gt; None:\n    \"\"\"\n    Perform cleanup after the event loop terminates.\n\n    Subclasses may override this method to release resources or emit shutdown notifications.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/messaging/subscriber/#onesecondtrader.messaging.subscriber.Subscriber._on_event","title":"<code>_on_event(event)</code>  <code>abstractmethod</code>","text":"<p>Handle a single event.</p> <p>This method is invoked sequentially for each event received by the subscriber. Implementations must not block indefinitely, as <code>wait_until_idle</code> relies on timely completion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event instance to handle.</p> required Source code in <code>src/onesecondtrader/messaging/subscriber.py</code> <pre><code>@abc.abstractmethod\ndef _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Handle a single event.\n\n    This method is invoked sequentially for each event received by the subscriber.\n    Implementations must not block indefinitely, as `wait_until_idle` relies on timely completion.\n\n    Parameters:\n        event:\n            Event instance to handle.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/models/action_types/","title":"Action Types","text":""},{"location":"reference/models/action_types/#onesecondtrader.models.action_types.ActionType","title":"<code>ActionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of trading action types.</p> <p><code>ActionType</code> specifies the intent or purpose of an order from the strategy's perspective, describing what the order is meant to accomplish in terms of position management.</p> Value Semantics <code>ENTRY</code> Opens a new position (direction-agnostic). <code>ENTRY_LONG</code> Opens a new long position. <code>ENTRY_SHORT</code> Opens a new short position. <code>EXIT</code> Closes an existing position (direction-agnostic). <code>EXIT_LONG</code> Closes an existing long position. <code>EXIT_SHORT</code> Closes an existing short position. <code>ADD</code> Increases the size of an existing position. <code>REDUCE</code> Decreases the size of an existing position without fully closing it. <code>REVERSE</code> Closes the current position and opens a new one in the opposite direction. Source code in <code>src/onesecondtrader/models/action_types.py</code> <pre><code>class ActionType(enum.Enum):\n    \"\"\"\n    Enumeration of trading action types.\n\n    `ActionType` specifies the intent or purpose of an order from the strategy's perspective,\n    describing what the order is meant to accomplish in terms of position management.\n\n    | Value         | Semantics                                                                  |\n    |---------------|----------------------------------------------------------------------------|\n    | `ENTRY`       | Opens a new position (direction-agnostic).                                 |\n    | `ENTRY_LONG`  | Opens a new long position.                                                 |\n    | `ENTRY_SHORT` | Opens a new short position.                                                |\n    | `EXIT`        | Closes an existing position (direction-agnostic).                          |\n    | `EXIT_LONG`   | Closes an existing long position.                                          |\n    | `EXIT_SHORT`  | Closes an existing short position.                                         |\n    | `ADD`         | Increases the size of an existing position.                                |\n    | `REDUCE`      | Decreases the size of an existing position without fully closing it.       |\n    | `REVERSE`     | Closes the current position and opens a new one in the opposite direction. |\n    \"\"\"\n\n    ENTRY = enum.auto()\n    ENTRY_LONG = enum.auto()\n    ENTRY_SHORT = enum.auto()\n    EXIT = enum.auto()\n    EXIT_LONG = enum.auto()\n    EXIT_SHORT = enum.auto()\n    ADD = enum.auto()\n    REDUCE = enum.auto()\n    REVERSE = enum.auto()\n</code></pre>"},{"location":"reference/models/bar_fields/","title":"Bar Fields","text":""},{"location":"reference/models/bar_fields/#onesecondtrader.models.bar_fields.BarField","title":"<code>BarField</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of bar fields used as indicator inputs.</p> Value Semantics <code>OPEN</code> Bar's opening value. <code>HIGH</code> Bar's highest value. <code>LOW</code> Bar's lowest value. <code>CLOSE</code> Bar's closing value. <code>VOLUME</code> Bar's traded volume. Source code in <code>src/onesecondtrader/models/bar_fields.py</code> <pre><code>class BarField(enum.Enum):\n    \"\"\"\n    Enumeration of bar fields used as indicator inputs.\n\n    | Value    | Semantics                          |\n    |----------|------------------------------------|\n    | `OPEN`   | Bar's opening value.               |\n    | `HIGH`   | Bar's highest value.               |\n    | `LOW`    | Bar's lowest value.                |\n    | `CLOSE`  | Bar's closing value.               |\n    | `VOLUME` | Bar's traded volume.               |\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"},{"location":"reference/models/bar_period/","title":"Bar Period","text":""},{"location":"reference/models/bar_period/#onesecondtrader.models.bar_period.BarPeriod","title":"<code>BarPeriod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of bar aggregation periods.</p> Value Semantics <code>SECOND</code> Duration of 1 second. <code>MINUTE</code> Duration of 1 minute. <code>HOUR</code> Duration of 1 hour. <code>DAY</code> Duration of 1 day. Source code in <code>src/onesecondtrader/models/bar_period.py</code> <pre><code>class BarPeriod(enum.Enum):\n    \"\"\"\n    Enumeration of bar aggregation periods.\n\n    | Value    | Semantics            |\n    |----------|----------------------|\n    | `SECOND` | Duration of 1 second.|\n    | `MINUTE` | Duration of 1 minute.|\n    | `HOUR`   | Duration of 1 hour.  |\n    | `DAY`    | Duration of 1 day.   |\n    \"\"\"\n\n    SECOND = enum.auto()\n    MINUTE = enum.auto()\n    HOUR = enum.auto()\n    DAY = enum.auto()\n</code></pre>"},{"location":"reference/models/order_types/","title":"Order Types","text":""},{"location":"reference/models/order_types/#onesecondtrader.models.order_types.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of order execution types.</p> Value Semantics <code>LIMIT</code> Executable only at the specified limit price or better. <code>MARKET</code> Executable immediately at the best available market price. <code>STOP</code> Becomes a market order once the stop price is reached. <code>STOP_LIMIT</code> Becomes a limit order once the stop price is reached. Source code in <code>src/onesecondtrader/models/order_types.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"\n    Enumeration of order execution types.\n\n    | Value        | Semantics                                                   |\n    |--------------|-------------------------------------------------------------|\n    | `LIMIT`      | Executable only at the specified limit price or better.     |\n    | `MARKET`     | Executable immediately at the best available market price.  |\n    | `STOP`       | Becomes a market order once the stop price is reached.      |\n    | `STOP_LIMIT` | Becomes a limit order once the stop price is reached.       |\n    \"\"\"\n\n    LIMIT = enum.auto()\n    MARKET = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"reference/models/plot_style/","title":"Plot Style","text":""},{"location":"reference/models/plot_style/#onesecondtrader.models.plot_style.PlotStyle","title":"<code>PlotStyle</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of indicator plot styles.</p> Value Semantics <code>LINE</code> Continuous line plot. <code>HISTOGRAM</code> Vertical bar histogram. <code>DOTS</code> Scatter plot with dots. Source code in <code>src/onesecondtrader/models/plot_style.py</code> <pre><code>class PlotStyle(enum.Enum):\n    \"\"\"\n    Enumeration of indicator plot styles.\n\n    | Value       | Semantics                          |\n    |-------------|------------------------------------|\n    | `LINE`      | Continuous line plot.              |\n    | `HISTOGRAM` | Vertical bar histogram.            |\n    | `DOTS`      | Scatter plot with dots.            |\n    \"\"\"\n\n    LINE = enum.auto()\n    HISTOGRAM = enum.auto()\n    DOTS = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/","title":"Rejection Reasons","text":""},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.OrderRejectionReason","title":"<code>OrderRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order rejection reasons.</p> <p>This enumeration defines the system-level classification of order rejection causes. It provides a stable, brokers-agnostic taxonomy for programmatic handling of rejected orders.</p> Value Semantics <code>UNKNOWN</code> The rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class OrderRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order rejection reasons.\n\n    This enumeration defines the system-level classification of order rejection causes.\n    It provides a stable, brokers-agnostic taxonomy for programmatic handling of rejected orders.\n\n    | Value     | Semantics                                                                 |\n    |-----------|---------------------------------------------------------------------------|\n    | `UNKNOWN` | The rejection reason could not be classified into a known category.       |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.ModificationRejectionReason","title":"<code>ModificationRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order modification rejection reasons.</p> <p>This enumeration defines the system-level classification of reasons for which an order modification request may be rejected by a brokers. It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of modification rejections.</p> Value Semantics <code>UNKNOWN</code> The modification rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class ModificationRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order modification rejection reasons.\n\n    This enumeration defines the system-level classification of reasons for which an order modification request may be rejected by a brokers.\n    It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of modification rejections.\n\n    | Value     | Semantics                                                                        |\n    |-----------|----------------------------------------------------------------------------------|\n    | `UNKNOWN` | The modification rejection reason could not be classified into a known category. |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/rejection_reasons/#onesecondtrader.models.rejection_reasons.CancellationRejectionReason","title":"<code>CancellationRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of canonical order cancellation rejection reasons.</p> <p>This enumeration defines the system-level classification of reasons for which an order cancellation request may be rejected by a brokers. It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of cancellation rejections.</p> Value Semantics <code>UNKNOWN</code> The cancellation rejection reason could not be classified into a known category. Source code in <code>src/onesecondtrader/models/rejection_reasons.py</code> <pre><code>class CancellationRejectionReason(enum.Enum):\n    \"\"\"\n    Enumeration of canonical order cancellation rejection reasons.\n\n    This enumeration defines the system-level classification of reasons for which an order cancellation request may be rejected by a brokers.\n    It provides a stable, brokers-agnostic taxonomy intended for programmatic handling and observability of cancellation rejections.\n\n    | Value     | Semantics                                                                        |\n    |-----------|----------------------------------------------------------------------------------|\n    | `UNKNOWN` | The cancellation rejection reason could not be classified into a known category. |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n</code></pre>"},{"location":"reference/models/trade_sides/","title":"Trade Sides","text":""},{"location":"reference/models/trade_sides/#onesecondtrader.models.trade_sides.TradeSide","title":"<code>TradeSide</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of trade direction.</p> <p><code>TradeSide</code> specifies the direction of change applied to the (net) signed position quantity from the perspective of the trading account.</p> Value Semantics <code>BUY</code> Increases the signed position quantity. <code>SELL</code> Decreases the signed position quantity. Source code in <code>src/onesecondtrader/models/trade_sides.py</code> <pre><code>class TradeSide(enum.Enum):\n    \"\"\"\n    Enumeration of trade direction.\n\n    `TradeSide` specifies the direction of change applied to the (net) signed position\n    quantity from the perspective of the trading account.\n\n    | Value   | Semantics                                      |\n    |---------|------------------------------------------------|\n    | `BUY`   | Increases the signed position quantity.        |\n    | `SELL`  | Decreases the signed position quantity.        |\n    \"\"\"\n\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/","title":"Orchestrator","text":""},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator","title":"<code>Orchestrator</code>","text":"<p>Orchestrates the execution of a trading run.</p> <p>The orchestrator instantiates strategies, broker, datafeed, and recorder components, connects them via an event bus, and coordinates the run lifecycle from start to shutdown.</p>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator.__init__","title":"<code>__init__(strategies, broker, datafeed)</code>","text":"<p>Initialize the orchestrator with component classes.</p> <p>Parameters:</p> Name Type Description Default <code>strategies</code> <code>list[type[StrategyBase]]</code> <p>List of strategy classes to instantiate for the run.</p> required <code>broker</code> <code>type[BrokerBase]</code> <p>Broker class to instantiate for order execution.</p> required <code>datafeed</code> <code>type[DatafeedBase]</code> <p>Datafeed class to instantiate for market data delivery.</p> required Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def __init__(\n    self,\n    strategies: list[type[StrategyBase]],\n    broker: type[BrokerBase],\n    datafeed: type[DatafeedBase],\n) -&gt; None:\n    \"\"\"\n    Initialize the orchestrator with component classes.\n\n    Parameters:\n        strategies:\n            List of strategy classes to instantiate for the run.\n        broker:\n            Broker class to instantiate for order execution.\n        datafeed:\n            Datafeed class to instantiate for market data delivery.\n    \"\"\"\n    dotenv.load_dotenv()\n    self._strategy_classes = strategies\n    self._broker_class = broker\n    self._datafeed_class = datafeed\n    self._event_bus: messaging.EventBus | None = None\n    self._strategies: list[StrategyBase] = []\n    self._broker: BrokerBase | None = None\n    self._datafeed: DatafeedBase | None = None\n    self._recorder: RunRecorder | None = None\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator.run","title":"<code>run()</code>","text":"<p>Execute the trading run.</p> <p>Creates all components, connects them, subscribes to symbols, waits for the datafeed to complete, and then shuts down all components.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Execute the trading run.\n\n    Creates all components, connects them, subscribes to symbols, waits for\n    the datafeed to complete, and then shuts down all components.\n    \"\"\"\n    run_id = self._generate_run_id()\n\n    self._event_bus = messaging.EventBus()\n\n    self._recorder = self._create_recorder(run_id)\n    self._broker = self._broker_class(self._event_bus)\n    self._strategies = [s(self._event_bus) for s in self._strategy_classes]\n    self._datafeed = self._datafeed_class(self._event_bus)\n\n    try:\n        self._broker.connect()\n        self._datafeed.connect()\n        self._subscribe_symbols()\n        self._datafeed.wait_until_complete()\n        self._event_bus.wait_until_system_idle()\n        self._recorder.update_run_status(\n            \"completed\", pd.Timestamp.now(tz=\"UTC\").value\n        )\n    except Exception:\n        if self._recorder:\n            self._recorder.update_run_status(\n                \"failed\", pd.Timestamp.now(tz=\"UTC\").value\n            )\n        raise\n    finally:\n        self._shutdown()\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator._generate_run_id","title":"<code>_generate_run_id()</code>","text":"<p>Generate a unique run identifier.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string combining the current UTC timestamp and strategy names.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def _generate_run_id(self) -&gt; str:\n    \"\"\"\n    Generate a unique run identifier.\n\n    Returns:\n        A string combining the current UTC timestamp and strategy names.\n    \"\"\"\n    timestamp = pd.Timestamp.now(tz=\"UTC\").strftime(\"%Y-%m-%d_%H-%M-%S\")\n    strategy_names = \"_\".join(s.name for s in self._strategy_classes)\n    return f\"{timestamp}_{strategy_names}\"\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator._collect_symbols","title":"<code>_collect_symbols()</code>","text":"<p>Collect all unique symbols from the strategy classes.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>A deduplicated list of symbols from all strategies.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def _collect_symbols(self) -&gt; list[str]:\n    \"\"\"\n    Collect all unique symbols from the strategy classes.\n\n    Returns:\n        A deduplicated list of symbols from all strategies.\n    \"\"\"\n    symbols = []\n    for strategy_class in self._strategy_classes:\n        symbols.extend(strategy_class.symbols)\n    return list(set(symbols))\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator._create_recorder","title":"<code>_create_recorder(run_id)</code>","text":"<p>Create and return a RunRecorder instance for this run.</p> <p>Parameters:</p> Name Type Description Default <code>run_id</code> <code>str</code> <p>Unique identifier for this run.</p> required <p>Returns:</p> Type Description <code>RunRecorder</code> <p>A configured RunRecorder instance.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def _create_recorder(self, run_id: str) -&gt; RunRecorder:\n    \"\"\"\n    Create and return a RunRecorder instance for this run.\n\n    Parameters:\n        run_id:\n            Unique identifier for this run.\n\n    Returns:\n        A configured RunRecorder instance.\n    \"\"\"\n    assert self._event_bus is not None\n    config = {\n        \"mode\": self.mode,\n        \"symbols\": self._collect_symbols(),\n        \"strategies\": [s.name for s in self._strategy_classes],\n        \"start_date\": self.start_date,\n        \"end_date\": self.end_date,\n    }\n    return RunRecorder(\n        event_bus=self._event_bus,\n        db_path=pathlib.Path(self.db_path),\n        run_id=run_id,\n        name=\"_\".join(s.name for s in self._strategy_classes),\n        config=config,\n    )\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator._subscribe_symbols","title":"<code>_subscribe_symbols()</code>","text":"<p>Subscribe the datafeed to symbols for each strategy's bar period.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def _subscribe_symbols(self) -&gt; None:\n    \"\"\"\n    Subscribe the datafeed to symbols for each strategy's bar period.\n    \"\"\"\n    assert self._datafeed is not None\n    subscriptions: dict[models.BarPeriod, list[str]] = {}\n    for strategy_class in self._strategy_classes:\n        bar_period_value = strategy_class.parameters[\"bar_period\"].default\n        assert isinstance(bar_period_value, models.BarPeriod)\n        if bar_period_value not in subscriptions:\n            subscriptions[bar_period_value] = []\n        subscriptions[bar_period_value].extend(strategy_class.symbols)\n    for bar_period, symbols in subscriptions.items():\n        self._datafeed.subscribe(list(set(symbols)), bar_period)\n</code></pre>"},{"location":"reference/orchestrator/orchestrator/#onesecondtrader.orchestrator.orchestrator.Orchestrator._shutdown","title":"<code>_shutdown()</code>","text":"<p>Shut down all components in the correct order.</p> Source code in <code>src/onesecondtrader/orchestrator/orchestrator.py</code> <pre><code>def _shutdown(self) -&gt; None:\n    \"\"\"\n    Shut down all components in the correct order.\n    \"\"\"\n    if self._datafeed:\n        self._datafeed.disconnect()\n    if self._broker:\n        self._broker.disconnect()\n    for strategy in self._strategies:\n        strategy.shutdown()\n    if self._recorder:\n        self._recorder.shutdown()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/","title":"Run Recorder","text":""},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.BATCH_SIZE","title":"<code>BATCH_SIZE = 1000</code>  <code>module-attribute</code>","text":""},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder","title":"<code>RunRecorder</code>","text":"<p>               Bases: <code>Subscriber</code></p> <p>Subscriber that records all trading system events to a SQLite runs database.</p> <p>The recorder subscribes to market data events, order requests, broker responses, fills, and expirations, inserting them into the appropriate tables as defined in the runs schema.</p> <p>Events are buffered and inserted in batches for performance. The buffer is flushed on shutdown via <code>_cleanup</code>.</p>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder.__init__","title":"<code>__init__(event_bus, db_path, run_id, name, config=None, metadata=None)</code>","text":"<p>Initialize the recorder and register a new run in the database.</p> <p>The database is created if it does not exist. A new row is inserted into the <code>runs</code> table with status <code>running</code> and the current timestamp as <code>ts_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for subscribing to system events.</p> required <code>db_path</code> <code>Path</code> <p>Filesystem path to the SQLite runs database.</p> required <code>run_id</code> <code>str</code> <p>Unique identifier for this run.</p> required <code>name</code> <code>str</code> <p>Human-readable name for this run.</p> required <code>config</code> <code>dict | None</code> <p>Optional configuration dictionary to store as JSON.</p> <code>None</code> <code>metadata</code> <code>dict | None</code> <p>Optional metadata dictionary to store as JSON.</p> <code>None</code> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def __init__(\n    self,\n    event_bus: messaging.EventBus,\n    db_path: pathlib.Path,\n    run_id: str,\n    name: str,\n    config: dict | None = None,\n    metadata: dict | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the recorder and register a new run in the database.\n\n    The database is created if it does not exist. A new row is inserted into the `runs`\n    table with status `running` and the current timestamp as `ts_start`.\n\n    Parameters:\n        event_bus:\n            Event bus used for subscribing to system events.\n        db_path:\n            Filesystem path to the SQLite runs database.\n        run_id:\n            Unique identifier for this run.\n        name:\n            Human-readable name for this run.\n        config:\n            Optional configuration dictionary to store as JSON.\n        metadata:\n            Optional metadata dictionary to store as JSON.\n    \"\"\"\n    self._db_path = db_path\n    self._run_id = run_id\n    self._name = name\n    self._config = config\n    self._metadata = metadata\n\n    self._conn = self._init_db()\n    self._buffers: dict[str, list[tuple]] = {\n        \"bars\": [],\n        \"bars_processed\": [],\n        \"order_submissions\": [],\n        \"order_cancellations\": [],\n        \"order_modifications\": [],\n        \"orders_accepted\": [],\n        \"orders_rejected\": [],\n        \"cancellations_accepted\": [],\n        \"cancellations_rejected\": [],\n        \"modifications_accepted\": [],\n        \"modifications_rejected\": [],\n        \"fills\": [],\n        \"expirations\": [],\n    }\n\n    self._register_run()\n\n    super().__init__(event_bus)\n    self._subscribe(\n        events.market.BarReceived,\n        events.market.BarProcessed,\n        events.requests.OrderSubmissionRequest,\n        events.requests.OrderCancellationRequest,\n        events.requests.OrderModificationRequest,\n        events.responses.OrderAccepted,\n        events.responses.OrderRejected,\n        events.responses.CancellationAccepted,\n        events.responses.CancellationRejected,\n        events.responses.ModificationAccepted,\n        events.responses.ModificationRejected,\n        events.orders.FillEvent,\n        events.orders.OrderExpired,\n    )\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._init_db","title":"<code>_init_db()</code>","text":"<p>Initialize the SQLite database connection.</p> <p>Creates the database file and parent directories if they do not exist. Applies the runs schema if the database is newly created.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Open database connection configured with WAL journal mode.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _init_db(self) -&gt; sqlite3.Connection:\n    \"\"\"\n    Initialize the SQLite database connection.\n\n    Creates the database file and parent directories if they do not exist.\n    Applies the runs schema if the database is newly created.\n\n    Returns:\n        Open database connection configured with WAL journal mode.\n    \"\"\"\n    schema_path = pathlib.Path(__file__).parent / \"runs_schema.sql\"\n    db_exists = self._db_path.is_file()\n\n    self._db_path.parent.mkdir(parents=True, exist_ok=True)\n    conn = sqlite3.connect(str(self._db_path), check_same_thread=False)\n    conn.execute(\"PRAGMA foreign_keys = ON\")\n    conn.execute(\"PRAGMA journal_mode = WAL\")\n    conn.execute(\"PRAGMA synchronous = NORMAL\")\n\n    if not db_exists:\n        conn.executescript(schema_path.read_text())\n\n    return conn\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._register_run","title":"<code>_register_run()</code>","text":"<p>Insert a new run record into the database.</p> <p>The run is created with status 'running' and the current timestamp as start time.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _register_run(self) -&gt; None:\n    \"\"\"\n    Insert a new run record into the database.\n\n    The run is created with status 'running' and the current timestamp as start time.\n    \"\"\"\n    self._conn.execute(\n        \"\"\"\n        INSERT INTO runs (run_id, name, ts_start, status, config, metadata)\n        VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\",\n        (\n            self._run_id,\n            self._name,\n            time.time_ns(),\n            \"running\",\n            json.dumps(self._config) if self._config else None,\n            json.dumps(self._metadata) if self._metadata else None,\n        ),\n    )\n    self._conn.commit()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder.update_run_status","title":"<code>update_run_status(status, ts_end=None)</code>","text":"<p>Update the status and end timestamp of the current run.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>New status value (e.g., 'completed', 'failed', 'cancelled').</p> required <code>ts_end</code> <code>int | None</code> <p>End timestamp in nanoseconds since Unix epoch. Defaults to current time.</p> <code>None</code> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def update_run_status(\n    self,\n    status: str,\n    ts_end: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the status and end timestamp of the current run.\n\n    Parameters:\n        status:\n            New status value (e.g., 'completed', 'failed', 'cancelled').\n        ts_end:\n            End timestamp in nanoseconds since Unix epoch. Defaults to current time.\n    \"\"\"\n    if ts_end is None:\n        ts_end = time.time_ns()\n    self._conn.execute(\n        \"UPDATE runs SET status = ?, ts_end = ? WHERE run_id = ?\",\n        (status, ts_end, self._run_id),\n    )\n    self._conn.commit()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._on_event","title":"<code>_on_event(event)</code>","text":"<p>Dispatch an incoming event to the appropriate buffer method.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EventBase</code> <p>Event received from the event bus.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    \"\"\"\n    Dispatch an incoming event to the appropriate buffer method.\n\n    Parameters:\n        event:\n            Event received from the event bus.\n    \"\"\"\n    match event:\n        case events.market.BarProcessed() as matched:\n            self._buffer_bar_processed(matched)\n        case events.market.BarReceived() as matched:\n            self._buffer_bar_received(matched)\n        case events.requests.OrderSubmissionRequest() as matched:\n            self._buffer_order_submission(matched)\n        case events.requests.OrderCancellationRequest() as matched:\n            self._buffer_order_cancellation(matched)\n        case events.requests.OrderModificationRequest() as matched:\n            self._buffer_order_modification(matched)\n        case events.responses.OrderAccepted() as matched:\n            self._buffer_order_accepted(matched)\n        case events.responses.OrderRejected() as matched:\n            self._buffer_order_rejected(matched)\n        case events.responses.CancellationAccepted() as matched:\n            self._buffer_cancellation_accepted(matched)\n        case events.responses.CancellationRejected() as matched:\n            self._buffer_cancellation_rejected(matched)\n        case events.responses.ModificationAccepted() as matched:\n            self._buffer_modification_accepted(matched)\n        case events.responses.ModificationRejected() as matched:\n            self._buffer_modification_rejected(matched)\n        case events.orders.FillEvent() as matched:\n            self._buffer_fill(matched)\n        case events.orders.OrderExpired() as matched:\n            self._buffer_expiration(matched)\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._on_exception","title":"<code>_on_exception(exc)</code>","text":"<p>Handle an exception raised during event processing.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>Exception that was raised.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _on_exception(self, exc: Exception) -&gt; None:\n    \"\"\"\n    Handle an exception raised during event processing.\n\n    Parameters:\n        exc:\n            Exception that was raised.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._cleanup","title":"<code>_cleanup()</code>","text":"<p>Flush all buffered records and close the database connection.</p> <p>Called automatically during subscriber shutdown.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _cleanup(self) -&gt; None:\n    \"\"\"\n    Flush all buffered records and close the database connection.\n\n    Called automatically during subscriber shutdown.\n    \"\"\"\n    self._flush_all()\n    self._conn.close()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_all","title":"<code>_flush_all()</code>","text":"<p>Flush all event buffers to the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_all(self) -&gt; None:\n    \"\"\"\n    Flush all event buffers to the database.\n    \"\"\"\n    self._flush_bars()\n    self._flush_bars_processed()\n    self._flush_order_submissions()\n    self._flush_order_cancellations()\n    self._flush_order_modifications()\n    self._flush_orders_accepted()\n    self._flush_orders_rejected()\n    self._flush_cancellations_accepted()\n    self._flush_cancellations_rejected()\n    self._flush_modifications_accepted()\n    self._flush_modifications_rejected()\n    self._flush_fills()\n    self._flush_expirations()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_bar_received","title":"<code>_buffer_bar_received(event)</code>","text":"<p>Buffer a bar received event for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Bar received event to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_bar_received(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Buffer a bar received event for batch insertion.\n\n    Parameters:\n        event:\n            Bar received event to buffer.\n    \"\"\"\n    self._buffers[\"bars\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.symbol,\n            event.bar_period.name,\n            event.open,\n            event.high,\n            event.low,\n            event.close,\n            event.volume,\n        )\n    )\n    if len(self._buffers[\"bars\"]) &gt;= BATCH_SIZE:\n        self._flush_bars()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_bar_processed","title":"<code>_buffer_bar_processed(event)</code>","text":"<p>Buffer a bar processed event for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarProcessed</code> <p>Bar processed event to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_bar_processed(self, event: events.market.BarProcessed) -&gt; None:\n    \"\"\"\n    Buffer a bar processed event for batch insertion.\n\n    Parameters:\n        event:\n            Bar processed event to buffer.\n    \"\"\"\n    self._buffers[\"bars_processed\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.symbol,\n            event.bar_period.name,\n            event.open,\n            event.high,\n            event.low,\n            event.close,\n            event.volume,\n            json.dumps(event.indicators),\n        )\n    )\n    if len(self._buffers[\"bars_processed\"]) &gt;= BATCH_SIZE:\n        self._flush_bars_processed()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_order_submission","title":"<code>_buffer_order_submission(event)</code>","text":"<p>Buffer an order submission request for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderSubmissionRequest</code> <p>Order submission request to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_order_submission(\n    self, event: events.requests.OrderSubmissionRequest\n) -&gt; None:\n    \"\"\"\n    Buffer an order submission request for batch insertion.\n\n    Parameters:\n        event:\n            Order submission request to buffer.\n    \"\"\"\n    self._buffers[\"order_submissions\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            str(event.system_order_id),\n            event.symbol,\n            event.order_type.name,\n            event.side.name,\n            event.quantity,\n            event.limit_price,\n            event.stop_price,\n            event.action.name if event.action else None,\n            event.signal,\n        )\n    )\n    if len(self._buffers[\"order_submissions\"]) &gt;= BATCH_SIZE:\n        self._flush_order_submissions()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_order_cancellation","title":"<code>_buffer_order_cancellation(event)</code>","text":"<p>Buffer an order cancellation request for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderCancellationRequest</code> <p>Order cancellation request to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_order_cancellation(\n    self, event: events.requests.OrderCancellationRequest\n) -&gt; None:\n    \"\"\"\n    Buffer an order cancellation request for batch insertion.\n\n    Parameters:\n        event:\n            Order cancellation request to buffer.\n    \"\"\"\n    self._buffers[\"order_cancellations\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            str(event.system_order_id),\n            event.symbol,\n        )\n    )\n    if len(self._buffers[\"order_cancellations\"]) &gt;= BATCH_SIZE:\n        self._flush_order_cancellations()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_order_modification","title":"<code>_buffer_order_modification(event)</code>","text":"<p>Buffer an order modification request for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderModificationRequest</code> <p>Order modification request to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_order_modification(\n    self, event: events.requests.OrderModificationRequest\n) -&gt; None:\n    \"\"\"\n    Buffer an order modification request for batch insertion.\n\n    Parameters:\n        event:\n            Order modification request to buffer.\n    \"\"\"\n    self._buffers[\"order_modifications\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            str(event.system_order_id),\n            event.symbol,\n            event.quantity,\n            event.limit_price,\n            event.stop_price,\n        )\n    )\n    if len(self._buffers[\"order_modifications\"]) &gt;= BATCH_SIZE:\n        self._flush_order_modifications()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_order_accepted","title":"<code>_buffer_order_accepted(event)</code>","text":"<p>Buffer an order accepted response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderAccepted</code> <p>Order accepted response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_order_accepted(self, event: events.responses.OrderAccepted) -&gt; None:\n    \"\"\"\n    Buffer an order accepted response for batch insertion.\n\n    Parameters:\n        event:\n            Order accepted response to buffer.\n    \"\"\"\n    self._buffers[\"orders_accepted\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.broker_order_id,\n        )\n    )\n    if len(self._buffers[\"orders_accepted\"]) &gt;= BATCH_SIZE:\n        self._flush_orders_accepted()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_order_rejected","title":"<code>_buffer_order_rejected(event)</code>","text":"<p>Buffer an order rejected response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderRejected</code> <p>Order rejected response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_order_rejected(self, event: events.responses.OrderRejected) -&gt; None:\n    \"\"\"\n    Buffer an order rejected response for batch insertion.\n\n    Parameters:\n        event:\n            Order rejected response to buffer.\n    \"\"\"\n    self._buffers[\"orders_rejected\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.rejection_reason.name,\n            event.rejection_message,\n        )\n    )\n    if len(self._buffers[\"orders_rejected\"]) &gt;= BATCH_SIZE:\n        self._flush_orders_rejected()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_cancellation_accepted","title":"<code>_buffer_cancellation_accepted(event)</code>","text":"<p>Buffer a cancellation accepted response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>CancellationAccepted</code> <p>Cancellation accepted response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_cancellation_accepted(\n    self, event: events.responses.CancellationAccepted\n) -&gt; None:\n    \"\"\"\n    Buffer a cancellation accepted response for batch insertion.\n\n    Parameters:\n        event:\n            Cancellation accepted response to buffer.\n    \"\"\"\n    self._buffers[\"cancellations_accepted\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.broker_order_id,\n        )\n    )\n    if len(self._buffers[\"cancellations_accepted\"]) &gt;= BATCH_SIZE:\n        self._flush_cancellations_accepted()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_cancellation_rejected","title":"<code>_buffer_cancellation_rejected(event)</code>","text":"<p>Buffer a cancellation rejected response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>CancellationRejected</code> <p>Cancellation rejected response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_cancellation_rejected(\n    self, event: events.responses.CancellationRejected\n) -&gt; None:\n    \"\"\"\n    Buffer a cancellation rejected response for batch insertion.\n\n    Parameters:\n        event:\n            Cancellation rejected response to buffer.\n    \"\"\"\n    self._buffers[\"cancellations_rejected\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.rejection_reason.name,\n            event.rejection_message,\n        )\n    )\n    if len(self._buffers[\"cancellations_rejected\"]) &gt;= BATCH_SIZE:\n        self._flush_cancellations_rejected()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_modification_accepted","title":"<code>_buffer_modification_accepted(event)</code>","text":"<p>Buffer a modification accepted response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ModificationAccepted</code> <p>Modification accepted response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_modification_accepted(\n    self, event: events.responses.ModificationAccepted\n) -&gt; None:\n    \"\"\"\n    Buffer a modification accepted response for batch insertion.\n\n    Parameters:\n        event:\n            Modification accepted response to buffer.\n    \"\"\"\n    self._buffers[\"modifications_accepted\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.broker_order_id,\n        )\n    )\n    if len(self._buffers[\"modifications_accepted\"]) &gt;= BATCH_SIZE:\n        self._flush_modifications_accepted()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_modification_rejected","title":"<code>_buffer_modification_rejected(event)</code>","text":"<p>Buffer a modification rejected response for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ModificationRejected</code> <p>Modification rejected response to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_modification_rejected(\n    self, event: events.responses.ModificationRejected\n) -&gt; None:\n    \"\"\"\n    Buffer a modification rejected response for batch insertion.\n\n    Parameters:\n        event:\n            Modification rejected response to buffer.\n    \"\"\"\n    self._buffers[\"modifications_rejected\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.rejection_reason.name,\n            event.rejection_message,\n        )\n    )\n    if len(self._buffers[\"modifications_rejected\"]) &gt;= BATCH_SIZE:\n        self._flush_modifications_rejected()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_fill","title":"<code>_buffer_fill(event)</code>","text":"<p>Buffer a fill event for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>FillEvent</code> <p>Fill event to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_fill(self, event: events.orders.FillEvent) -&gt; None:\n    \"\"\"\n    Buffer a fill event for batch insertion.\n\n    Parameters:\n        event:\n            Fill event to buffer.\n    \"\"\"\n    self._buffers[\"fills\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.broker_order_id,\n            event.symbol,\n            str(event.fill_id),\n            event.broker_fill_id,\n            event.side.name,\n            event.quantity_filled,\n            event.fill_price,\n            event.commission,\n            event.exchange,\n        )\n    )\n    if len(self._buffers[\"fills\"]) &gt;= BATCH_SIZE:\n        self._flush_fills()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._buffer_expiration","title":"<code>_buffer_expiration(event)</code>","text":"<p>Buffer an order expiration event for batch insertion.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>OrderExpired</code> <p>Order expiration event to buffer.</p> required Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _buffer_expiration(self, event: events.orders.OrderExpired) -&gt; None:\n    \"\"\"\n    Buffer an order expiration event for batch insertion.\n\n    Parameters:\n        event:\n            Order expiration event to buffer.\n    \"\"\"\n    self._buffers[\"expirations\"].append(\n        (\n            self._run_id,\n            event.ts_event_ns,\n            event.ts_created_ns,\n            event.ts_broker_ns,\n            str(event.associated_order_id),\n            event.broker_order_id,\n            event.symbol,\n        )\n    )\n    if len(self._buffers[\"expirations\"]) &gt;= BATCH_SIZE:\n        self._flush_expirations()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_bars","title":"<code>_flush_bars()</code>","text":"<p>Insert buffered bar received records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_bars(self) -&gt; None:\n    \"\"\"\n    Insert buffered bar received records into the database.\n    \"\"\"\n    if not self._buffers[\"bars\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO bars (run_id, ts_event_ns, ts_created_ns, symbol, bar_period, open, high, low, close, volume)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"bars\"],\n    )\n    self._conn.commit()\n    self._buffers[\"bars\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_bars_processed","title":"<code>_flush_bars_processed()</code>","text":"<p>Insert buffered bar processed records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_bars_processed(self) -&gt; None:\n    \"\"\"\n    Insert buffered bar processed records into the database.\n    \"\"\"\n    if not self._buffers[\"bars_processed\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO bars_processed (run_id, ts_event_ns, ts_created_ns, symbol, bar_period, open, high, low, close, volume, indicators)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"bars_processed\"],\n    )\n    self._conn.commit()\n    self._buffers[\"bars_processed\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_order_submissions","title":"<code>_flush_order_submissions()</code>","text":"<p>Insert buffered order submission records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_order_submissions(self) -&gt; None:\n    \"\"\"\n    Insert buffered order submission records into the database.\n    \"\"\"\n    if not self._buffers[\"order_submissions\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO order_submissions (run_id, ts_event_ns, ts_created_ns, system_order_id, symbol, order_type, side, quantity, limit_price, stop_price, action, signal)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"order_submissions\"],\n    )\n    self._conn.commit()\n    self._buffers[\"order_submissions\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_order_cancellations","title":"<code>_flush_order_cancellations()</code>","text":"<p>Insert buffered order cancellation records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_order_cancellations(self) -&gt; None:\n    \"\"\"\n    Insert buffered order cancellation records into the database.\n    \"\"\"\n    if not self._buffers[\"order_cancellations\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO order_cancellations (run_id, ts_event_ns, ts_created_ns, system_order_id, symbol)\n        VALUES (?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"order_cancellations\"],\n    )\n    self._conn.commit()\n    self._buffers[\"order_cancellations\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_order_modifications","title":"<code>_flush_order_modifications()</code>","text":"<p>Insert buffered order modification records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_order_modifications(self) -&gt; None:\n    \"\"\"\n    Insert buffered order modification records into the database.\n    \"\"\"\n    if not self._buffers[\"order_modifications\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO order_modifications (run_id, ts_event_ns, ts_created_ns, system_order_id, symbol, quantity, limit_price, stop_price)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"order_modifications\"],\n    )\n    self._conn.commit()\n    self._buffers[\"order_modifications\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_orders_accepted","title":"<code>_flush_orders_accepted()</code>","text":"<p>Insert buffered order accepted records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_orders_accepted(self) -&gt; None:\n    \"\"\"\n    Insert buffered order accepted records into the database.\n    \"\"\"\n    if not self._buffers[\"orders_accepted\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO orders_accepted (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, broker_order_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"orders_accepted\"],\n    )\n    self._conn.commit()\n    self._buffers[\"orders_accepted\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_orders_rejected","title":"<code>_flush_orders_rejected()</code>","text":"<p>Insert buffered order rejected records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_orders_rejected(self) -&gt; None:\n    \"\"\"\n    Insert buffered order rejected records into the database.\n    \"\"\"\n    if not self._buffers[\"orders_rejected\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO orders_rejected (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, rejection_reason, rejection_message)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"orders_rejected\"],\n    )\n    self._conn.commit()\n    self._buffers[\"orders_rejected\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_cancellations_accepted","title":"<code>_flush_cancellations_accepted()</code>","text":"<p>Insert buffered cancellation accepted records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_cancellations_accepted(self) -&gt; None:\n    \"\"\"\n    Insert buffered cancellation accepted records into the database.\n    \"\"\"\n    if not self._buffers[\"cancellations_accepted\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO cancellations_accepted (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, broker_order_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"cancellations_accepted\"],\n    )\n    self._conn.commit()\n    self._buffers[\"cancellations_accepted\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_cancellations_rejected","title":"<code>_flush_cancellations_rejected()</code>","text":"<p>Insert buffered cancellation rejected records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_cancellations_rejected(self) -&gt; None:\n    \"\"\"\n    Insert buffered cancellation rejected records into the database.\n    \"\"\"\n    if not self._buffers[\"cancellations_rejected\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO cancellations_rejected (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, rejection_reason, rejection_message)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"cancellations_rejected\"],\n    )\n    self._conn.commit()\n    self._buffers[\"cancellations_rejected\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_modifications_accepted","title":"<code>_flush_modifications_accepted()</code>","text":"<p>Insert buffered modification accepted records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_modifications_accepted(self) -&gt; None:\n    \"\"\"\n    Insert buffered modification accepted records into the database.\n    \"\"\"\n    if not self._buffers[\"modifications_accepted\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO modifications_accepted (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, broker_order_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"modifications_accepted\"],\n    )\n    self._conn.commit()\n    self._buffers[\"modifications_accepted\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_modifications_rejected","title":"<code>_flush_modifications_rejected()</code>","text":"<p>Insert buffered modification rejected records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_modifications_rejected(self) -&gt; None:\n    \"\"\"\n    Insert buffered modification rejected records into the database.\n    \"\"\"\n    if not self._buffers[\"modifications_rejected\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO modifications_rejected (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, rejection_reason, rejection_message)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"modifications_rejected\"],\n    )\n    self._conn.commit()\n    self._buffers[\"modifications_rejected\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_fills","title":"<code>_flush_fills()</code>","text":"<p>Insert buffered fill records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_fills(self) -&gt; None:\n    \"\"\"\n    Insert buffered fill records into the database.\n    \"\"\"\n    if not self._buffers[\"fills\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO fills (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, broker_order_id, symbol, fill_id, broker_fill_id, side, quantity_filled, fill_price, commission, exchange)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"fills\"],\n    )\n    self._conn.commit()\n    self._buffers[\"fills\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/run_recorder/#onesecondtrader.orchestrator.run_recorder.RunRecorder._flush_expirations","title":"<code>_flush_expirations()</code>","text":"<p>Insert buffered expiration records into the database.</p> Source code in <code>src/onesecondtrader/orchestrator/run_recorder.py</code> <pre><code>def _flush_expirations(self) -&gt; None:\n    \"\"\"\n    Insert buffered expiration records into the database.\n    \"\"\"\n    if not self._buffers[\"expirations\"]:\n        return\n    self._conn.executemany(\n        \"\"\"\n        INSERT INTO expirations (run_id, ts_event_ns, ts_created_ns, ts_broker_ns, associated_order_id, broker_order_id, symbol)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"\"\",\n        self._buffers[\"expirations\"],\n    )\n    self._conn.commit()\n    self._buffers[\"expirations\"].clear()\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/","title":"Runs Schema","text":"<p>Runs database schema.</p> <p>The schema stores metadata about trading system runs and all events that occurred during each run. Events are recorded by a runs_recorder subscriber listening to the event_bus. Each event type has a dedicated table with typed columns for efficient querying and charting.</p> Table Description <code>runs</code> Registry of trading system runs with metadata. <code>bars</code> Market data bars (BarReceived events). <code>bars_processed</code> Processed bars with indicator values (BarProcessed events). <code>order_submissions</code> Order submission requests. <code>order_cancellations</code> Order cancellation requests. <code>order_modifications</code> Order modification requests. <code>orders_accepted</code> Broker order acceptance responses. <code>orders_rejected</code> Broker order rejection responses. <code>cancellations_accepted</code> Broker cancellation acceptance responses. <code>cancellations_rejected</code> Broker cancellation rejection responses. <code>modifications_accepted</code> Broker modification acceptance responses. <code>modifications_rejected</code> Broker modification rejection responses. <code>fills</code> Trade execution fill events. <code>expirations</code> Order expiration events."},{"location":"reference/orchestrator/runs_schema/#runs","title":"Runs","text":"<p>Registry of trading system runs.</p> <p>Each row represents a single execution of the trading system, whether a backtest or live session. A run is uniquely identified by <code>run_id</code> which is a UUID assigned at run creation. The <code>config</code> and <code>metadata</code> fields store JSON-encoded data for flexibility.</p> Field Type Constraints Description <code>run_id</code> <code>TEXT</code> <code>PRIMARY KEY</code> Unique identifier for the run (UUID string). <code>name</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable name or label for the run. <code>ts_start</code> <code>INTEGER</code> <code>NOT NULL</code> Start time of the run as nanoseconds since the UTC Unix epoch. <code>ts_end</code> <code>INTEGER</code> End time of the run as nanoseconds since the UTC Unix epoch; NULL if still in progress. <code>status</code> <code>TEXT</code> <code>NOT NULL</code>, <code>CHECK IN ('running','completed','failed','cancelled')</code> Current status of the run. <code>config</code> <code>TEXT</code> JSON-encoded configuration used for the run. <code>metadata</code> <code>TEXT</code> JSON-encoded additional metadata about the run. <pre><code>CREATE TABLE runs (\n    run_id TEXT PRIMARY KEY,\n    name TEXT NOT NULL,\n    ts_start INTEGER NOT NULL,\n    ts_end INTEGER,\n    status TEXT NOT NULL CHECK(status IN ('running', 'completed', 'failed', 'cancelled')),\n    config TEXT,\n    metadata TEXT\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#bars","title":"Bars","text":"<p>Stores market data bars received during a run.</p> <p>Each row represents a BarReceived event captured from the event bus. Bars are time-aggregated OHLCV data from a market data source or resampling process.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the bar record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this bar belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the bar was observed by the system, as nanoseconds since UTC Unix epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <code>bar_period</code> <code>TEXT</code> <code>NOT NULL</code> Time interval represented by the bar (e.g. 'SECOND', 'MINUTE', 'HOUR', 'DAY'). <code>open</code> <code>REAL</code> <code>NOT NULL</code> Opening price of the bar period. <code>high</code> <code>REAL</code> <code>NOT NULL</code> Highest traded price during the bar period. <code>low</code> <code>REAL</code> <code>NOT NULL</code> Lowest traded price during the bar period. <code>close</code> <code>REAL</code> <code>NOT NULL</code> Closing price of the bar period. <code>volume</code> <code>INTEGER</code> Traded volume during the bar period; may be NULL if not available. <pre><code>CREATE TABLE bars (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    symbol TEXT NOT NULL,\n    bar_period TEXT NOT NULL,\n    open REAL NOT NULL,\n    high REAL NOT NULL,\n    low REAL NOT NULL,\n    close REAL NOT NULL,\n    volume INTEGER,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_bars_run_symbol_ts","title":"Idx_bars_run_symbol_ts","text":"<pre><code>CREATE INDEX idx_bars_run_symbol_ts ON bars(run_id, symbol, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#bars_processed","title":"Bars_processed","text":"<p>Stores processed market data bars with computed indicator values.</p> <p>Each row represents a BarProcessed event captured from the event bus. This extends BarReceived by attaching indicator values derived from the bar data.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the bar record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this bar belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the bar was observed by the system, as nanoseconds since UTC Unix epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <code>bar_period</code> <code>TEXT</code> <code>NOT NULL</code> Time interval represented by the bar (e.g. 'SECOND', 'MINUTE', 'HOUR', 'DAY'). <code>open</code> <code>REAL</code> <code>NOT NULL</code> Opening price of the bar period. <code>high</code> <code>REAL</code> <code>NOT NULL</code> Highest traded price during the bar period. <code>low</code> <code>REAL</code> <code>NOT NULL</code> Lowest traded price during the bar period. <code>close</code> <code>REAL</code> <code>NOT NULL</code> Closing price of the bar period. <code>volume</code> <code>INTEGER</code> Traded volume during the bar period; may be NULL if not available. <code>indicators</code> <code>TEXT</code> <code>NOT NULL</code> JSON-encoded mapping of indicator names to computed values. <pre><code>CREATE TABLE bars_processed (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    symbol TEXT NOT NULL,\n    bar_period TEXT NOT NULL,\n    open REAL NOT NULL,\n    high REAL NOT NULL,\n    low REAL NOT NULL,\n    close REAL NOT NULL,\n    volume INTEGER,\n    indicators TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_bars_processed_run_symbol_ts","title":"Idx_bars_processed_run_symbol_ts","text":"<pre><code>CREATE INDEX idx_bars_processed_run_symbol_ts ON bars_processed(run_id, symbol, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#order_submissions","title":"Order_submissions","text":"<p>Stores order submission requests issued by strategies.</p> <p>Each row represents an OrderSubmissionRequest event captured from the event bus. This records the intent to submit a new order to the broker.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the request was issued, as nanoseconds since UTC Unix epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>system_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned unique identifier for the order (UUID string). <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <code>order_type</code> <code>TEXT</code> <code>NOT NULL</code> Execution constraint of the order (e.g. 'MARKET', 'LIMIT', 'STOP', 'STOP_LIMIT'). <code>side</code> <code>TEXT</code> <code>NOT NULL</code> Direction of the trade (e.g. 'BUY', 'SELL'). <code>quantity</code> <code>REAL</code> <code>NOT NULL</code> Requested order quantity. <code>limit_price</code> <code>REAL</code> Limit price, if applicable to the order type. <code>stop_price</code> <code>REAL</code> Stop price, if applicable to the order type. <code>action</code> <code>TEXT</code> Intent of the order from the strategy's perspective (e.g. 'ENTRY', 'EXIT'). <code>signal</code> <code>TEXT</code> Optional signal name or identifier that triggered this order. <pre><code>CREATE TABLE order_submissions (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    system_order_id TEXT NOT NULL,\n    symbol TEXT NOT NULL,\n    order_type TEXT NOT NULL,\n    side TEXT NOT NULL,\n    quantity REAL NOT NULL,\n    limit_price REAL,\n    stop_price REAL,\n    action TEXT,\n    signal TEXT,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_submissions_run_ts","title":"Idx_order_submissions_run_ts","text":"<pre><code>CREATE INDEX idx_order_submissions_run_ts ON order_submissions(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_submissions_order_id","title":"Idx_order_submissions_order_id","text":"<pre><code>CREATE INDEX idx_order_submissions_order_id ON order_submissions(system_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#order_cancellations","title":"Order_cancellations","text":"<p>Stores order cancellation requests issued by strategies.</p> <p>Each row represents an OrderCancellationRequest event captured from the event bus. This records the intent to cancel an existing order.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the request was issued, as nanoseconds since UTC Unix epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>system_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the order to be cancelled (UUID string). <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <pre><code>CREATE TABLE order_cancellations (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    system_order_id TEXT NOT NULL,\n    symbol TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_cancellations_run_ts","title":"Idx_order_cancellations_run_ts","text":"<pre><code>CREATE INDEX idx_order_cancellations_run_ts ON order_cancellations(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_cancellations_order_id","title":"Idx_order_cancellations_order_id","text":"<pre><code>CREATE INDEX idx_order_cancellations_order_id ON order_cancellations(system_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#order_modifications","title":"Order_modifications","text":"<p>Stores order modification requests issued by strategies.</p> <p>Each row represents an OrderModificationRequest event captured from the event bus. This records the intent to modify an existing order's parameters.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the request was issued, as nanoseconds since UTC Unix epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>system_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the order to be modified (UUID string). <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <code>quantity</code> <code>REAL</code> Updated order quantity, if modified. <code>limit_price</code> <code>REAL</code> Updated limit price, if modified. <code>stop_price</code> <code>REAL</code> Updated stop price, if modified. <pre><code>CREATE TABLE order_modifications (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    system_order_id TEXT NOT NULL,\n    symbol TEXT NOT NULL,\n    quantity REAL,\n    limit_price REAL,\n    stop_price REAL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_modifications_run_ts","title":"Idx_order_modifications_run_ts","text":"<pre><code>CREATE INDEX idx_order_modifications_run_ts ON order_modifications(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_order_modifications_order_id","title":"Idx_order_modifications_order_id","text":"<pre><code>CREATE INDEX idx_order_modifications_order_id ON order_modifications(system_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#orders_accepted","title":"Orders_accepted","text":"<p>Stores broker order acceptance responses.</p> <p>Each row represents an OrderAccepted event captured from the event bus. This indicates that an order has been accepted by the broker and is active at the execution venue.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the acceptance was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the acceptance, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the accepted order (UUID string). <code>broker_order_id</code> <code>TEXT</code> Broker-assigned identifier of the accepted order, if reported. <pre><code>CREATE TABLE orders_accepted (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    broker_order_id TEXT,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_orders_accepted_run_ts","title":"Idx_orders_accepted_run_ts","text":"<pre><code>CREATE INDEX idx_orders_accepted_run_ts ON orders_accepted(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_orders_accepted_order_id","title":"Idx_orders_accepted_order_id","text":"<pre><code>CREATE INDEX idx_orders_accepted_order_id ON orders_accepted(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#orders_rejected","title":"Orders_rejected","text":"<p>Stores broker order rejection responses.</p> <p>Each row represents an OrderRejected event captured from the event bus. This indicates that an order has been rejected by the broker.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the rejection was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the rejection, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the rejected order (UUID string). <code>rejection_reason</code> <code>TEXT</code> <code>NOT NULL</code> Canonical classification of the rejection cause (e.g. 'INSUFFICIENT_FUNDS'). <code>rejection_message</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable explanation provided by the broker. <pre><code>CREATE TABLE orders_rejected (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    rejection_reason TEXT NOT NULL,\n    rejection_message TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_orders_rejected_run_ts","title":"Idx_orders_rejected_run_ts","text":"<pre><code>CREATE INDEX idx_orders_rejected_run_ts ON orders_rejected(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_orders_rejected_order_id","title":"Idx_orders_rejected_order_id","text":"<pre><code>CREATE INDEX idx_orders_rejected_order_id ON orders_rejected(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#cancellations_accepted","title":"Cancellations_accepted","text":"<p>Stores broker cancellation acceptance responses.</p> <p>Each row represents a CancellationAccepted event captured from the event bus. This indicates that an order cancellation has been acknowledged and the order is no longer active.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the cancellation was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the cancellation, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the cancelled order (UUID string). <code>broker_order_id</code> <code>TEXT</code> Broker-assigned identifier of the cancelled order, if reported. <pre><code>CREATE TABLE cancellations_accepted (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    broker_order_id TEXT,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_cancellations_accepted_run_ts","title":"Idx_cancellations_accepted_run_ts","text":"<pre><code>CREATE INDEX idx_cancellations_accepted_run_ts ON cancellations_accepted(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_cancellations_accepted_order_id","title":"Idx_cancellations_accepted_order_id","text":"<pre><code>CREATE INDEX idx_cancellations_accepted_order_id ON cancellations_accepted(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#cancellations_rejected","title":"Cancellations_rejected","text":"<p>Stores broker cancellation rejection responses.</p> <p>Each row represents a CancellationRejected event captured from the event bus. This indicates that an order cancellation request has been rejected by the broker.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the rejection was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the rejection, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the order associated with the rejected cancellation. <code>rejection_reason</code> <code>TEXT</code> <code>NOT NULL</code> Canonical classification of the cancellation rejection cause. <code>rejection_message</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable explanation provided by the broker. <pre><code>CREATE TABLE cancellations_rejected (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    rejection_reason TEXT NOT NULL,\n    rejection_message TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_cancellations_rejected_run_ts","title":"Idx_cancellations_rejected_run_ts","text":"<pre><code>CREATE INDEX idx_cancellations_rejected_run_ts ON cancellations_rejected(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_cancellations_rejected_order_id","title":"Idx_cancellations_rejected_order_id","text":"<pre><code>CREATE INDEX idx_cancellations_rejected_order_id ON cancellations_rejected(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#modifications_accepted","title":"Modifications_accepted","text":"<p>Stores broker modification acceptance responses.</p> <p>Each row represents a ModificationAccepted event captured from the event bus. This indicates that an order modification has been acknowledged and the updated parameters are active.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the acceptance was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the modification acceptance, as nanoseconds since UTC epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the modified order (UUID string). <code>broker_order_id</code> <code>TEXT</code> Broker-assigned identifier of the order after modification, if reported. <pre><code>CREATE TABLE modifications_accepted (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    broker_order_id TEXT,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_modifications_accepted_run_ts","title":"Idx_modifications_accepted_run_ts","text":"<pre><code>CREATE INDEX idx_modifications_accepted_run_ts ON modifications_accepted(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_modifications_accepted_order_id","title":"Idx_modifications_accepted_order_id","text":"<pre><code>CREATE INDEX idx_modifications_accepted_order_id ON modifications_accepted(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#modifications_rejected","title":"Modifications_rejected","text":"<p>Stores broker modification rejection responses.</p> <p>Each row represents a ModificationRejected event captured from the event bus. This indicates that an order modification request has been rejected by the broker.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the rejection was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the rejection, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the order associated with the rejected modification. <code>rejection_reason</code> <code>TEXT</code> <code>NOT NULL</code> Canonical classification of the modification rejection cause. <code>rejection_message</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable explanation provided by the broker. <pre><code>CREATE TABLE modifications_rejected (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    rejection_reason TEXT NOT NULL,\n    rejection_message TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_modifications_rejected_run_ts","title":"Idx_modifications_rejected_run_ts","text":"<pre><code>CREATE INDEX idx_modifications_rejected_run_ts ON modifications_rejected(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_modifications_rejected_order_id","title":"Idx_modifications_rejected_order_id","text":"<pre><code>CREATE INDEX idx_modifications_rejected_order_id ON modifications_rejected(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#fills","title":"Fills","text":"<p>Stores trade execution fill events.</p> <p>Each row represents a FillEvent captured from the event bus. A fill records the execution of a quantity of an order at a specific price. Multiple fills may be associated with the same order in the case of partial execution.</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the fill was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the fill, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the order associated with the fill (UUID string). <code>broker_order_id</code> <code>TEXT</code> Broker-assigned identifier of the order, if available. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <code>fill_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned unique identifier of the fill event (UUID string). <code>broker_fill_id</code> <code>TEXT</code> Broker-assigned identifier of the execution record, if available. <code>side</code> <code>TEXT</code> <code>NOT NULL</code> Trade direction of the executed quantity (e.g. 'BUY', 'SELL'). <code>quantity_filled</code> <code>REAL</code> <code>NOT NULL</code> Quantity executed in this fill. <code>fill_price</code> <code>REAL</code> <code>NOT NULL</code> Execution price of the fill. <code>commission</code> <code>REAL</code> <code>NOT NULL</code> Commission or fee associated with the fill. <code>exchange</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the execution venue. <pre><code>CREATE TABLE fills (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    broker_order_id TEXT,\n    symbol TEXT NOT NULL,\n    fill_id TEXT NOT NULL,\n    broker_fill_id TEXT,\n    side TEXT NOT NULL,\n    quantity_filled REAL NOT NULL,\n    fill_price REAL NOT NULL,\n    commission REAL NOT NULL,\n    exchange TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_fills_run_ts","title":"Idx_fills_run_ts","text":"<pre><code>CREATE INDEX idx_fills_run_ts ON fills(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_fills_run_symbol_ts","title":"Idx_fills_run_symbol_ts","text":"<pre><code>CREATE INDEX idx_fills_run_symbol_ts ON fills(run_id, symbol, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_fills_order_id","title":"Idx_fills_order_id","text":"<pre><code>CREATE INDEX idx_fills_order_id ON fills(associated_order_id);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#expirations","title":"Expirations","text":"<p>Stores order expiration events.</p> <p>Each row represents an OrderExpired event captured from the event bus. This indicates that an order is no longer active due to expiration according to broker or venue rules (e.g. time-in-force constraints).</p> Field Type Constraints Description <code>id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Auto-incrementing surrogate key for the record. <code>run_id</code> <code>TEXT</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>runs.run_id</code>, identifying the run this event belongs to. <code>ts_event_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the expiration was observed by the system, as nanoseconds since UTC epoch. <code>ts_created_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time at which the event object was created, as nanoseconds since UTC Unix epoch. <code>ts_broker_ns</code> <code>INTEGER</code> <code>NOT NULL</code> Time reported by the broker for the expiration, as nanoseconds since UTC Unix epoch. <code>associated_order_id</code> <code>TEXT</code> <code>NOT NULL</code> System-assigned identifier of the expired order (UUID string). <code>broker_order_id</code> <code>TEXT</code> Broker-assigned identifier of the expired order, if reported. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the traded instrument. <pre><code>CREATE TABLE expirations (\n    id INTEGER PRIMARY KEY,\n    run_id TEXT NOT NULL,\n    ts_event_ns INTEGER NOT NULL,\n    ts_created_ns INTEGER NOT NULL,\n    ts_broker_ns INTEGER NOT NULL,\n    associated_order_id TEXT NOT NULL,\n    broker_order_id TEXT,\n    symbol TEXT NOT NULL,\n    FOREIGN KEY (run_id) REFERENCES runs(run_id)\n);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_expirations_run_ts","title":"Idx_expirations_run_ts","text":"<pre><code>CREATE INDEX idx_expirations_run_ts ON expirations(run_id, ts_event_ns);\n</code></pre>"},{"location":"reference/orchestrator/runs_schema/#idx_expirations_order_id","title":"Idx_expirations_order_id","text":"<pre><code>CREATE INDEX idx_expirations_order_id ON expirations(associated_order_id);\n</code></pre>"},{"location":"reference/secmaster/utils/","title":"Utils","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.BATCH_SIZE","title":"<code>BATCH_SIZE = 10000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.LOG_EVERY_OHLCV","title":"<code>LOG_EVERY_OHLCV = 1000000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.LOG_EVERY_SYMBOLOGY","title":"<code>LOG_EVERY_SYMBOLOGY = 50000</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.create_secmaster_db","title":"<code>create_secmaster_db(db_path, schema_version=1)</code>","text":"<p>Create a new security master SQLite database using a selected schema version.</p> <p>The database file is created at the given path and initialized by executing the SQL script located in the <code>schema_versions</code> directory adjacent to this module.</p> <p>The function expects the schema script to set <code>PRAGMA user_version</code> to the corresponding schema version and verifies this after execution.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>Filesystem path at which the SQLite database file will be created.</p> required <code>schema_version</code> <code>int</code> <p>Version number selecting the schema script to apply.</p> <code>1</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the created database file.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If a file already exists at <code>db_path</code>.</p> <code>FileNotFoundError</code> <p>If the schema script for <code>schema_version</code> does not exist.</p> <code>DatabaseError</code> <p>If the applied schema does not set the expected <code>user_version</code> or if SQLite fails while executing the schema.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def create_secmaster_db(db_path: pathlib.Path, schema_version: int = 1) -&gt; pathlib.Path:\n    \"\"\"\n    Create a new security master SQLite database using a selected schema version.\n\n    The database file is created at the given path and initialized by executing the SQL script\n    located in the `schema_versions` directory adjacent to this module.\n\n    The function expects the schema script to set `PRAGMA user_version` to the corresponding\n    schema version and verifies this after execution.\n\n    Parameters:\n        db_path:\n            Filesystem path at which the SQLite database file will be created.\n        schema_version:\n            Version number selecting the schema script to apply.\n\n    Returns:\n        The path to the created database file.\n\n    Raises:\n        FileExistsError:\n            If a file already exists at `db_path`.\n        FileNotFoundError:\n            If the schema script for `schema_version` does not exist.\n        sqlite3.DatabaseError:\n            If the applied schema does not set the expected `user_version` or if SQLite fails\n            while executing the schema.\n    \"\"\"\n    if db_path.exists():\n        raise FileExistsError(f\"Database already exists: {db_path}\")\n\n    schema_path = (\n        pathlib.Path(__file__).resolve().parent\n        / \"schema_versions\"\n        / f\"secmaster_schema_v{schema_version}.sql\"\n    )\n\n    if not schema_path.is_file():\n        raise FileNotFoundError(\n            f\"Schema version {schema_version} not found: {schema_path}\"\n        )\n\n    db_path.parent.mkdir(parents=True, exist_ok=True)\n\n    schema_sql = schema_path.read_text(encoding=\"utf-8\")\n\n    with sqlite3.connect(str(db_path)) as con:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        con.executescript(schema_sql)\n\n        row = con.execute(\"PRAGMA user_version;\").fetchone()\n        actual_version = int(row[0]) if row else 0\n\n        if actual_version != schema_version:\n            raise sqlite3.DatabaseError(\n                f\"Schema script set user_version={actual_version}, expected {schema_version}\"\n            )\n\n    return db_path\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.rebuild_symbol_coverage","title":"<code>rebuild_symbol_coverage(db_path)</code>","text":"<p>Rebuild the symbol_coverage table from actual OHLCV data.</p> <p>For each symbology mapping, finds OHLCV data within the valid date range, then aggregates per publisher, symbol and rtype to get overall coverage. This ensures coverage reflects only data accessible via each symbol during its valid period.</p> <p>The algorithm: 1. Create temp table with OHLCV coverage per (instrument_id, rtype) 2. Create temp table joining instruments with symbology (with ts conversion) 3. Join and compute intersection, aggregate per (publisher_id, symbol, rtype)</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>Path to the security master SQLite database.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of (publisher_id, symbol, rtype) combinations with coverage data.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def rebuild_symbol_coverage(db_path: pathlib.Path) -&gt; int:\n    \"\"\"\n    Rebuild the symbol_coverage table from actual OHLCV data.\n\n    For each symbology mapping, finds OHLCV data within the valid date range,\n    then aggregates per publisher, symbol and rtype to get overall coverage. This ensures\n    coverage reflects only data accessible via each symbol during its valid period.\n\n    The algorithm:\n    1. Create temp table with OHLCV coverage per (instrument_id, rtype)\n    2. Create temp table joining instruments with symbology (with ts conversion)\n    3. Join and compute intersection, aggregate per (publisher_id, symbol, rtype)\n\n    Parameters:\n        db_path:\n            Path to the security master SQLite database.\n\n    Returns:\n        The number of (publisher_id, symbol, rtype) combinations with coverage data.\n    \"\"\"\n    logger.info(\"Rebuilding symbol_coverage table from OHLCV data\")\n\n    con = sqlite3.connect(str(db_path))\n    try:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        _assert_secmaster_db(con)\n\n        logger.info(\"Step 1: Aggregating OHLCV coverage per instrument and rtype\")\n        con.execute(\"DROP TABLE IF EXISTS _tmp_instrument_coverage\")\n        con.execute(\n            \"\"\"\n            CREATE TEMP TABLE _tmp_instrument_coverage AS\n            SELECT instrument_id, rtype, MIN(ts_event) AS min_ts, MAX(ts_event) AS max_ts\n            FROM ohlcv\n            GROUP BY instrument_id, rtype\n        \"\"\"\n        )\n        con.execute(\n            \"CREATE INDEX _tmp_ic_idx ON _tmp_instrument_coverage(instrument_id)\"\n        )\n\n        logger.info(\"Step 2: Building symbol-to-instrument mapping with timestamps\")\n        con.execute(\"DROP TABLE IF EXISTS _tmp_symbol_instrument\")\n        con.execute(\n            \"\"\"\n            CREATE TEMP TABLE _tmp_symbol_instrument AS\n            SELECT\n                s.publisher_ref AS publisher_id,\n                s.symbol,\n                i.instrument_id,\n                CAST(strftime('%s', s.start_date) AS INTEGER) * 1000000000 AS start_ts,\n                CAST(strftime('%s', s.end_date) AS INTEGER) * 1000000000 AS end_ts\n            FROM symbology s\n            JOIN instruments i\n                ON s.publisher_ref = i.publisher_ref\n                AND s.source_instrument_id = i.source_instrument_id\n        \"\"\"\n        )\n        con.execute(\"CREATE INDEX _tmp_si_idx ON _tmp_symbol_instrument(instrument_id)\")\n\n        logger.info(\"Step 3: Computing symbol coverage with date intersection\")\n        con.execute(\"DELETE FROM symbol_coverage\")\n        con.execute(\n            \"\"\"\n            INSERT INTO symbol_coverage (publisher_id, symbol, rtype, min_ts, max_ts)\n            SELECT\n                si.publisher_id,\n                si.symbol,\n                ic.rtype,\n                MIN(MAX(ic.min_ts, si.start_ts)),\n                MAX(MIN(ic.max_ts, si.end_ts))\n            FROM _tmp_symbol_instrument si\n            JOIN _tmp_instrument_coverage ic ON si.instrument_id = ic.instrument_id\n            WHERE ic.min_ts &lt; si.end_ts AND ic.max_ts &gt;= si.start_ts\n            GROUP BY si.publisher_id, si.symbol, ic.rtype\n        \"\"\"\n        )\n\n        con.execute(\"DROP TABLE IF EXISTS _tmp_instrument_coverage\")\n        con.execute(\"DROP TABLE IF EXISTS _tmp_symbol_instrument\")\n        con.commit()\n\n        count = con.execute(\"SELECT COUNT(*) FROM symbol_coverage\").fetchone()[0]\n    finally:\n        con.close()\n\n    logger.info(\n        \"Rebuilt symbol_coverage: %d publisher/symbol/rtype combinations\", count\n    )\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_databento_zip","title":"<code>ingest_databento_zip(zip_path, db_path, publisher_name='databento', symbol_type='raw_symbol', dataset=None)</code>","text":"<p>Ingest market data from a Databento zip archive into the security master database.</p> <p>The archive may contain one or more DBN files and an optional <code>symbology.json</code>. The function ingests OHLCV records from DBN files into <code>ohlcv</code> and ingests symbol-to-instrument mappings into <code>symbology</code>.</p> <p>The publisher namespace is created if absent. Publisher identity is determined by the pair <code>(publisher_name, dataset)</code>, where <code>dataset</code> is extracted from <code>metadata.json</code> in the archive.</p> <p>Ingestion is idempotent with respect to primary keys: existing <code>ohlcv</code> and <code>symbology</code> rows are left unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>zip_path</code> <code>Path</code> <p>Path to the Databento zip archive.</p> required <code>db_path</code> <code>Path</code> <p>Path to the security master SQLite database.</p> required <code>publisher_name</code> <code>str</code> <p>Vendor name stored in <code>publishers.name</code>. The dataset is derived from archive metadata.</p> <code>'databento'</code> <code>symbol_type</code> <code>str</code> <p>Symbol scheme stored in <code>symbology.symbol_type</code> for symbols found in <code>symbology.json</code>.</p> <code>'raw_symbol'</code> <code>dataset</code> <code>str | None</code> <p>Optional dataset override. If provided, it is used when <code>metadata.json</code> is missing or does not specify a dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple of (ohlcv_record_count_seen, symbology_record_count_seen).</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_databento_zip(\n    zip_path: pathlib.Path,\n    db_path: pathlib.Path,\n    publisher_name: str = \"databento\",\n    symbol_type: str = \"raw_symbol\",\n    dataset: str | None = None,\n) -&gt; tuple[int, int]:\n    \"\"\"\n    Ingest market data from a Databento zip archive into the security master database.\n\n    The archive may contain one or more DBN files and an optional `symbology.json`. The function\n    ingests OHLCV records from DBN files into `ohlcv` and ingests symbol-to-instrument mappings\n    into `symbology`.\n\n    The publisher namespace is created if absent. Publisher identity is determined by the pair\n    `(publisher_name, dataset)`, where `dataset` is extracted from `metadata.json` in the archive.\n\n    Ingestion is idempotent with respect to primary keys: existing `ohlcv` and `symbology` rows are\n    left unchanged.\n\n    Parameters:\n        zip_path:\n            Path to the Databento zip archive.\n        db_path:\n            Path to the security master SQLite database.\n        publisher_name:\n            Vendor name stored in `publishers.name`. The dataset is derived from archive metadata.\n        symbol_type:\n            Symbol scheme stored in `symbology.symbol_type` for symbols found in `symbology.json`.\n        dataset:\n            Optional dataset override. If provided, it is used when `metadata.json` is missing or\n            does not specify a dataset.\n\n    Returns:\n        A tuple of (ohlcv_record_count_seen, symbology_record_count_seen).\n    \"\"\"\n    ohlcv_count = 0\n    symbology_count = 0\n\n    logger.info(\"Opening Databento archive: %s\", zip_path)\n\n    if not db_path.is_file():\n        raise FileNotFoundError(f\"Security master DB not found: {db_path}\")\n\n    con = sqlite3.connect(str(db_path))\n\n    try:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        _assert_secmaster_db(con)\n        _enable_bulk_loading(con)\n\n        with con:\n            with zipfile.ZipFile(zip_path, \"r\") as zf:\n                dataset, venue = _extract_dataset_info(zf, dataset_override=dataset)\n                logger.info(\n                    \"Publisher resolved: name=%s dataset=%s venue=%s\",\n                    publisher_name,\n                    dataset,\n                    venue,\n                )\n                publisher_id = _get_or_create_publisher(\n                    con, publisher_name, dataset, venue\n                )\n\n                with tempfile.TemporaryDirectory() as tmpdir:\n                    dbn_files = [\n                        n\n                        for n in zf.namelist()\n                        if n.endswith(\".dbn.zst\") or n.endswith(\".dbn\")\n                    ]\n                    symbology_member = _zip_find_member(zf, \"symbology.json\")\n\n                    if not dbn_files and symbology_member is None:\n                        raise ValueError(\n                            \"Archive contains no DBN files and no symbology.json\"\n                        )\n\n                    logger.info(\"Found %d DBN file(s) in archive\", len(dbn_files))\n\n                    for name in dbn_files:\n                        extracted_path = _zip_member_to_tempfile(zf, name, tmpdir)\n                        try:\n                            logger.info(\"Ingesting DBN file: %s\", extracted_path.name)\n                            ohlcv_count += _ingest_dbn(\n                                extracted_path, con, publisher_id\n                            )\n                        finally:\n                            try:\n                                extracted_path.unlink()\n                            except FileNotFoundError:\n                                pass\n\n                    if symbology_member is not None:\n                        symbology_path = _zip_member_to_tempfile(\n                            zf, symbology_member, tmpdir\n                        )\n                        try:\n                            logger.info(\"Ingesting symbology.json\")\n                            symbology_count += _ingest_symbology(\n                                symbology_path,\n                                con,\n                                publisher_id,\n                                symbol_type=symbol_type,\n                            )\n                        finally:\n                            try:\n                                symbology_path.unlink()\n                            except FileNotFoundError:\n                                pass\n                    else:\n                        logger.info(\"No symbology.json present in archive\")\n    finally:\n        try:\n            _disable_bulk_loading(con)\n        finally:\n            con.close()\n\n    logger.info(\n        \"Finished zip ingestion: %s (%d OHLCV records, %d symbology records)\",\n        zip_path.name,\n        ohlcv_count,\n        symbology_count,\n    )\n\n    rebuild_symbol_coverage(db_path)\n\n    return ohlcv_count, symbology_count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_databento_dbn","title":"<code>ingest_databento_dbn(dbn_path, db_path, publisher_name='databento')</code>","text":"<p>Ingest market data from a Databento DBN file into the security master database.</p> <p>Reads OHLCV records from the DBN file and inserts them into <code>ohlcv</code>. The publisher namespace is created if absent. Publisher identity is determined by the pair <code>(publisher_name, dataset)</code>, where <code>dataset</code> is read from DBN metadata.</p> <p>Ingestion is idempotent with respect to primary keys: existing bars are left unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>dbn_path</code> <code>Path</code> <p>Path to the DBN file (.dbn or .dbn.zst).</p> required <code>db_path</code> <code>Path</code> <p>Path to the security master SQLite database.</p> required <code>publisher_name</code> <code>str</code> <p>Vendor name stored in <code>publishers.name</code>. The dataset is derived from DBN metadata.</p> <code>'databento'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of OHLCV records seen in the DBN stream.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_databento_dbn(\n    dbn_path: pathlib.Path,\n    db_path: pathlib.Path,\n    publisher_name: str = \"databento\",\n) -&gt; int:\n    \"\"\"\n    Ingest market data from a Databento DBN file into the security master database.\n\n    Reads OHLCV records from the DBN file and inserts them into `ohlcv`. The publisher namespace\n    is created if absent. Publisher identity is determined by the pair `(publisher_name, dataset)`,\n    where `dataset` is read from DBN metadata.\n\n    Ingestion is idempotent with respect to primary keys: existing bars are left unchanged.\n\n    Parameters:\n        dbn_path:\n            Path to the DBN file (.dbn or .dbn.zst).\n        db_path:\n            Path to the security master SQLite database.\n        publisher_name:\n            Vendor name stored in `publishers.name`. The dataset is derived from DBN metadata.\n\n    Returns:\n        The number of OHLCV records seen in the DBN stream.\n    \"\"\"\n    logger.info(\"Starting DBN ingestion: %s\", dbn_path)\n\n    if not db_path.is_file():\n        raise FileNotFoundError(f\"Security master DB not found: {db_path}\")\n\n    con = sqlite3.connect(str(db_path))\n\n    try:\n        con.execute(\"PRAGMA foreign_keys = ON;\")\n        _assert_secmaster_db(con)\n        _enable_bulk_loading(con)\n\n        with con:\n            store = databento.DBNStore.from_file(dbn_path)\n            dataset = store.metadata.dataset\n            if not dataset:\n                raise ValueError(f\"DBN metadata missing dataset: {dbn_path}\")\n            venue = dataset.split(\".\")[0] if \".\" in dataset else None\n\n            logger.info(\n                \"Publisher resolved: name=%s dataset=%s venue=%s\",\n                publisher_name,\n                dataset,\n                venue,\n            )\n\n            publisher_id = _get_or_create_publisher(con, publisher_name, dataset, venue)\n            count = _ingest_dbn(dbn_path, con, publisher_id)\n    finally:\n        try:\n            _disable_bulk_loading(con)\n        finally:\n            con.close()\n\n    logger.info(\"Finished DBN ingestion: %s (%d OHLCV records)\", dbn_path.name, count)\n\n    rebuild_symbol_coverage(db_path)\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._extract_dataset_info","title":"<code>_extract_dataset_info(zf, dataset_override=None)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _extract_dataset_info(\n    zf: zipfile.ZipFile,\n    dataset_override: str | None = None,\n) -&gt; tuple[str, str | None]:\n    metadata_member = _zip_find_member(zf, \"metadata.json\")\n    if metadata_member is None:\n        if dataset_override is None:\n            raise ValueError(\n                \"Archive is missing metadata.json and no dataset override was provided\"\n            )\n        dataset = dataset_override\n    else:\n        with zf.open(metadata_member) as f:\n            metadata = json.load(f)\n        dataset = metadata.get(\"query\", {}).get(\"dataset\")\n        if not dataset:\n            if dataset_override is None:\n                raise ValueError(\n                    f\"metadata.json is missing query.dataset (member={metadata_member!r})\"\n                )\n            dataset = dataset_override\n\n    venue = dataset.split(\".\")[0] if \".\" in dataset else None\n    return dataset, venue\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._zip_find_member","title":"<code>_zip_find_member(zf, basename, allow_multiple=False)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _zip_find_member(\n    zf: zipfile.ZipFile,\n    basename: str,\n    allow_multiple: bool = False,\n) -&gt; str | None:\n    candidates = [\n        name\n        for name in zf.namelist()\n        if name == basename or name.endswith(\"/\" + basename)\n    ]\n    if not candidates:\n        return None\n    if len(candidates) == 1:\n        return candidates[0]\n\n    candidates = sorted(candidates)\n    if not allow_multiple:\n        raise ValueError(f\"Multiple {basename} members found in archive: {candidates}\")\n\n    selected = candidates[0]\n    logger.warning(\"Multiple %s found in archive; using %s\", basename, selected)\n    return selected\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._zip_member_to_tempfile","title":"<code>_zip_member_to_tempfile(zf, member_name, tmpdir)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _zip_member_to_tempfile(\n    zf: zipfile.ZipFile,\n    member_name: str,\n    tmpdir: str,\n) -&gt; pathlib.Path:\n    suffix = \"\".join(pathlib.PurePosixPath(member_name).suffixes)\n    with tempfile.NamedTemporaryFile(\n        mode=\"wb\",\n        suffix=suffix,\n        delete=False,\n        dir=tmpdir,\n    ) as tmp:\n        with zf.open(member_name) as src:\n            shutil.copyfileobj(src, tmp)\n        return pathlib.Path(tmp.name)\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._get_or_create_publisher","title":"<code>_get_or_create_publisher(con, name, dataset, venue)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _get_or_create_publisher(\n    con: sqlite3.Connection,\n    name: str,\n    dataset: str,\n    venue: str | None,\n) -&gt; int:\n    cursor = con.cursor()\n    cursor.execute(\n        \"SELECT publisher_id FROM publishers WHERE name = ? AND dataset = ?\",\n        (name, dataset),\n    )\n    row = cursor.fetchone()\n    if row:\n        return row[0]\n\n    cursor.execute(\n        \"INSERT INTO publishers (name, dataset, venue) VALUES (?, ?, ?)\",\n        (name, dataset, venue),\n    )\n    return cursor.lastrowid  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._get_or_create_instrument","title":"<code>_get_or_create_instrument(con, publisher_id, source_instrument_id)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _get_or_create_instrument(\n    con: sqlite3.Connection,\n    publisher_id: int,\n    source_instrument_id: int,\n) -&gt; int:\n    cursor = con.cursor()\n    cursor.execute(\n        \"SELECT instrument_id FROM instruments WHERE publisher_ref = ? AND source_instrument_id = ?\",\n        (publisher_id, source_instrument_id),\n    )\n    row = cursor.fetchone()\n    if row:\n        return row[0]\n\n    cursor.execute(\n        \"INSERT INTO instruments (publisher_ref, source_instrument_id) VALUES (?, ?)\",\n        (publisher_id, source_instrument_id),\n    )\n    return cursor.lastrowid  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._assert_secmaster_db","title":"<code>_assert_secmaster_db(con, expected_user_version=1)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _assert_secmaster_db(\n    con: sqlite3.Connection, expected_user_version: int = 1\n) -&gt; None:\n    row = con.execute(\"PRAGMA user_version;\").fetchone()\n    user_version = int(row[0]) if row else 0\n    if user_version != expected_user_version:\n        raise sqlite3.DatabaseError(\n            \"Security master schema user_version=\"\n            f\"{user_version} does not match expected {expected_user_version}\"\n        )\n\n    required = {\"publishers\", \"instruments\", \"ohlcv\", \"symbology\"}\n    present = {\n        r[0]\n        for r in con.execute(\n            \"SELECT name FROM sqlite_master WHERE type = 'table'\"\n        ).fetchall()\n    }\n    missing = sorted(required - present)\n    if missing:\n        raise sqlite3.DatabaseError(\n            f\"Security master schema missing required tables: {', '.join(missing)}\"\n        )\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_dbn","title":"<code>_ingest_dbn(dbn_path, con, publisher_id)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_dbn(\n    dbn_path: pathlib.Path,\n    con: sqlite3.Connection,\n    publisher_id: int,\n) -&gt; int:\n    store = databento.DBNStore.from_file(dbn_path)\n    cursor = con.cursor()\n\n    instrument_cache: dict[int, int] = {}\n    batch: list[tuple] = []\n    count = 0\n\n    logger.info(\"Streaming OHLCV records from: %s\", dbn_path.name)\n\n    for record in store:\n        if not isinstance(record, databento.OHLCVMsg):\n            continue\n\n        source_id = record.instrument_id\n        if source_id not in instrument_cache:\n            instrument_cache[source_id] = _get_or_create_instrument(\n                con, publisher_id, source_id\n            )\n        internal_id = instrument_cache[source_id]\n\n        rtype_val = (\n            record.rtype.value if hasattr(record.rtype, \"value\") else record.rtype\n        )\n\n        batch.append(\n            (\n                internal_id,\n                rtype_val,\n                record.ts_event,\n                record.open,\n                record.high,\n                record.low,\n                record.close,\n                record.volume,\n            )\n        )\n        count += 1\n\n        if count % LOG_EVERY_OHLCV == 0:\n            logger.info(\"Ingested %d OHLCV records from %s\", count, dbn_path.name)\n\n        if len(batch) &gt;= BATCH_SIZE:\n            cursor.executemany(\n                \"INSERT OR IGNORE INTO ohlcv \"\n                \"(instrument_id, rtype, ts_event, open, high, low, close, volume) \"\n                \"VALUES (?, ?, ?, ?, ?, ?, ?, ?)\",\n                batch,\n            )\n            batch.clear()\n\n    if batch:\n        cursor.executemany(\n            \"INSERT OR IGNORE INTO ohlcv \"\n            \"(instrument_id, rtype, ts_event, open, high, low, close, volume) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?)\",\n            batch,\n        )\n\n    logger.info(\"Completed OHLCV ingest from %s (%d records)\", dbn_path.name, count)\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_symbology","title":"<code>_ingest_symbology(json_path, con, publisher_id, symbol_type='raw_symbol')</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_symbology(\n    json_path: pathlib.Path,\n    con: sqlite3.Connection,\n    publisher_id: int,\n    symbol_type: str = \"raw_symbol\",\n) -&gt; int:\n    if not isinstance(symbol_type, str) or not symbol_type:\n        raise ValueError(\"symbol_type must be a non-empty string\")\n\n    with open(json_path, \"r\") as f:\n        data = json.load(f)\n\n    if not isinstance(data, dict):\n        raise ValueError(\"symbology.json root must be a JSON object\")\n\n    result = data.get(\"result\", {})\n    if not isinstance(result, dict):\n        raise ValueError(\"symbology.json['result'] must be an object\")\n    cursor = con.cursor()\n\n    batch: list[tuple] = []\n    count = 0\n\n    logger.info(\"Streaming symbology mappings from: %s\", json_path.name)\n\n    instrument_cache: set[int] = set()\n\n    for symbol, mappings in result.items():\n        if not isinstance(mappings, list):\n            raise ValueError(\n                f\"symbology.json mappings must be a list for symbol={symbol!r}\"\n            )\n\n        for i, mapping in enumerate(mappings):\n            if not isinstance(mapping, dict):\n                raise ValueError(\n                    f\"symbology.json mapping must be an object at symbol={symbol!r} index={i}\"\n                )\n\n            missing_keys = [k for k in (\"s\", \"d0\", \"d1\") if k not in mapping]\n            if missing_keys:\n                raise ValueError(\n                    \"symbology.json mapping missing key(s) \"\n                    f\"{missing_keys} at symbol={symbol!r} index={i}\"\n                )\n\n            source_id = int(mapping[\"s\"])\n\n            if source_id not in instrument_cache:\n                _get_or_create_instrument(con, publisher_id, source_id)\n                instrument_cache.add(source_id)\n\n            batch.append(\n                (\n                    publisher_id,\n                    symbol,\n                    symbol_type,\n                    source_id,\n                    mapping[\"d0\"],\n                    mapping[\"d1\"],\n                )\n            )\n            count += 1\n\n            if count % LOG_EVERY_SYMBOLOGY == 0:\n                logger.info(\n                    \"Ingested %d symbology mappings from %s\", count, json_path.name\n                )\n\n            if len(batch) &gt;= BATCH_SIZE:\n                cursor.executemany(\n                    \"INSERT OR IGNORE INTO symbology \"\n                    \"(publisher_ref, symbol, symbol_type, source_instrument_id, start_date, end_date) \"\n                    \"VALUES (?, ?, ?, ?, ?, ?)\",\n                    batch,\n                )\n                batch.clear()\n\n    if batch:\n        cursor.executemany(\n            \"INSERT OR IGNORE INTO symbology \"\n            \"(publisher_ref, symbol, symbol_type, source_instrument_id, start_date, end_date) \"\n            \"VALUES (?, ?, ?, ?, ?, ?)\",\n            batch,\n        )\n\n    _validate_no_overlapping_symbology(con, publisher_id, symbol_type)\n\n    logger.info(\n        \"Completed symbology ingest from %s (%d mappings)\", json_path.name, count\n    )\n\n    return count\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._validate_no_overlapping_symbology","title":"<code>_validate_no_overlapping_symbology(con, publisher_id, symbol_type)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _validate_no_overlapping_symbology(\n    con: sqlite3.Connection,\n    publisher_id: int,\n    symbol_type: str,\n) -&gt; None:\n    query = \"\"\"\n        WITH ordered AS (\n            SELECT\n                symbol,\n                start_date,\n                end_date,\n                LEAD(start_date) OVER (\n                    PARTITION BY symbol ORDER BY start_date\n                ) AS next_start\n            FROM symbology\n            WHERE publisher_ref = ? AND symbol_type = ?\n        )\n        SELECT symbol, start_date, end_date, next_start\n        FROM ordered\n        WHERE next_start IS NOT NULL AND end_date &gt; next_start\n        LIMIT 1\n    \"\"\"\n    row = con.execute(query, (publisher_id, symbol_type)).fetchone()\n    if row:\n        symbol, start, end, next_start = row\n        raise ValueError(\n            f\"Overlapping symbology detected for symbol={symbol!r}: \"\n            f\"segment [{start}, {end}) overlaps with next segment starting {next_start}\"\n        )\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._enable_bulk_loading","title":"<code>_enable_bulk_loading(con)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _enable_bulk_loading(con: sqlite3.Connection) -&gt; None:\n    con.execute(\"PRAGMA journal_mode = WAL\")\n    con.execute(\"PRAGMA synchronous = NORMAL\")\n    con.execute(\"PRAGMA cache_size = -64000\")\n</code></pre>"},{"location":"reference/secmaster/utils/#onesecondtrader.secmaster.utils._disable_bulk_loading","title":"<code>_disable_bulk_loading(con)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _disable_bulk_loading(con: sqlite3.Connection) -&gt; None:\n    con.execute(\"PRAGMA synchronous = FULL\")\n    con.execute(\"PRAGMA journal_mode = DELETE\")\n    con.execute(\"PRAGMA cache_size = -2000\")\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/","title":"Secmaster Schema V1","text":"<p>Security master database schema.</p> <p>The schema is designed for Databento-native ingestion via DBN files, while remaining compatible with other sources. Instrument identity is modeled per publisher namespace and supports either numeric upstream identifiers or symbols. Contract specifications and other static reference metadata are intentionally out of scope for this schema and should be stored separately if ingested.</p> <p>The schema is explicitly ingestion-safe in the sense that:</p> <p>1) publishers are keyed by (vendor, dataset) rather than vendor alone, allowing multiple feeds per vendor; 2) symbology admits multiple mappings sharing the same start date by including the resolved instrument identifier in the primary key, preventing accidental overwrites during bulk ingestion.</p> Table Description <code>publishers</code> Registry of vendor+dataset namespaces used for market data and instrument ingestion. <code>instruments</code> Registry of instruments observed from ingestion within a publisher namespace. <code>ohlcv</code> Aggregated OHLCV bar data keyed by instrument, bar duration (<code>rtype</code>), and event timestamp (<code>ts_event</code>). <code>symbology</code> Time-bounded mappings from publisher-native symbols to publisher-native instrument identifiers."},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#publishers","title":"Publishers","text":"<p>Registry of all data sources used for market data and instrument ingestion.</p> <p>Each row represents a distinct data product (feed) within a vendor namespace. A publisher record is uniquely identified by the pair (<code>name</code>, <code>dataset</code>), not by <code>name</code> alone. This allows a single vendor (e.g. Databento) to appear multiple times, once per concrete dataset/feed (e.g. <code>GLBX.MDP3</code>, <code>XNAS.ITCH</code>).</p> <p>A publisher establishes the provenance of instrument definitions and price data and provides the context in which raw symbols and native instrument identifiers are interpreted.</p> Field Type Constraints Description <code>publisher_id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Internal surrogate key uniquely identifying a publisher record within the system. <code>name</code> <code>TEXT</code> <code>NOT NULL</code> Human-readable vendor identifier for the data source (e.g. <code>databento</code>, <code>yfinance</code>). <code>dataset</code> <code>TEXT</code> <code>NOT NULL</code> Identifier of the concrete data product or feed through which data is sourced; uses Databento dataset names (e.g. <code>GLBX.MDP3</code>) for Databento ingestion and internal identifiers for other sources (e.g. <code>YFINANCE</code>). <code>venue</code> <code>TEXT</code> Optional ISO 10383 Market Identifier Code (MIC) describing the primary trading venue; may be NULL for aggregated or multi-venue sources. <p>Table constraints</p> <ul> <li><code>UNIQUE(name, dataset)</code> ensures that each vendor+feed combination is represented at most once.</li> </ul> <p>Examples</p> <p>Databento CME Globex feed:</p> <ul> <li><code>name</code>    = <code>'databento'</code></li> <li><code>dataset</code> = <code>'GLBX.MDP3'</code></li> <li><code>venue</code>   = <code>XCME</code></li> </ul> <p>Databento NASDAQ TotalView feed:</p> <ul> <li><code>name</code>    = <code>'databento'</code></li> <li><code>dataset</code> = <code>'XNAS.ITCH'</code></li> <li><code>venue</code>   = <code>XNAS</code></li> </ul> <p>Yahoo Finance equity data:</p> <ul> <li><code>name</code>    = <code>'yfinance'</code></li> <li><code>dataset</code> = <code>'YFINANCE'</code></li> <li><code>venue</code>   = <code>NULL</code></li> </ul> <pre><code>CREATE TABLE publishers (\n    publisher_id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    dataset TEXT NOT NULL,\n    venue TEXT,\n    UNIQUE (name, dataset)\n);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#instruments","title":"Instruments","text":"<p>Registry of instruments observed through market data ingestion.</p> <p>Each row represents an instrument identity within a publisher namespace. Instruments may be identified by a publisher-native numeric identifier, a symbol identifier, or both. Databento ingestion uses <code>source_instrument_id</code> as the primary identifier and may optionally store a symbol from symbology. Symbol-first sources such as yfinance use <code>symbol</code> as the primary identifier and typically leave <code>source_instrument_id</code> to be <code>NULL</code>.</p> <p>The table does not store contract specifications or other reference metadata. Such metadata must be stored separately when available.</p> Field Type Constraints Description <code>instrument_id</code> <code>INTEGER</code> <code>PRIMARY KEY</code> Internal surrogate key identifying an instrument record within the system. <code>publisher_ref</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>publishers.publisher_id</code>, defining the publisher namespace in which this instrument identity is valid. <code>source_instrument_id</code> <code>INTEGER</code> Publisher-native numeric instrument identifier as provided by the upstream data source (e.g. Databento instrument_id); may be <code>NULL</code> for symbol-only sources. <code>symbol</code> <code>TEXT</code> Publisher-native symbol string identifying the instrument (e.g. raw symbol, ticker); may be NULL when numeric identifiers are used. <code>symbol_type</code> <code>TEXT</code> Identifier describing the symbol scheme or resolution type used by the publisher (e.g. <code>raw_symbol</code>, <code>continuous</code>, <code>ticker</code>). <p>Each instrument must be identifiable by at least one of <code>source_instrument_id</code> or <code>symbol</code>. Uniqueness constraints ensure that instrument identities do not collide within a publisher namespace. The table intentionally excludes contract specifications and other reference metadata, which must be stored separately when available.</p> <pre><code>CREATE TABLE instruments (\n    instrument_id INTEGER PRIMARY KEY,\n    publisher_ref INTEGER NOT NULL,\n    source_instrument_id INTEGER,\n    symbol TEXT,\n    symbol_type TEXT,\n    FOREIGN KEY (publisher_ref) REFERENCES publishers(publisher_id),\n    CHECK (\n        source_instrument_id IS NOT NULL\n        OR symbol IS NOT NULL\n    ),\n    CHECK (symbol IS NULL OR symbol_type IS NOT NULL),\n    UNIQUE (publisher_ref, source_instrument_id),\n    UNIQUE (publisher_ref, symbol, symbol_type)\n);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#ohlcv","title":"OHLCV","text":"<p>Stores aggregated OHLCV bars for instruments at multiple time resolutions.</p> Field Type Constraints Description <code>instrument_id</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>instruments.instrument_id</code>, identifying the instrument to which this bar belongs. <code>rtype</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK IN (32, 33, 34, 35, 36)</code> Record type code encoding the bar duration using Databento OHLCV conventions (e.g. <code>32</code>=1s, <code>33</code>=1m, <code>34</code>=1h, <code>35</code>=1d). <code>ts_event</code> <code>INTEGER</code> <code>NOT NULL</code> Event timestamp of the bar as provided by the upstream source, stored as nanoseconds since the UTC Unix epoch. <code>open</code> <code>INTEGER</code> <code>NOT NULL</code> Opening price of the bar interval, stored as a fixed-point integer using the upstream price scaling convention. <code>high</code> <code>INTEGER</code> <code>NOT NULL</code> Highest traded price during the bar interval, stored as a fixed-point integer. <code>low</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK(low &lt;= high)</code> Lowest traded price during the bar interval, stored as a fixed-point integer. <code>close</code> <code>INTEGER</code> <code>NOT NULL</code> Closing price of the bar interval, stored as a fixed-point integer. <code>volume</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>CHECK(volume &gt;= 0)</code> Total traded volume during the bar interval. <p>The composite primary key enforces uniqueness per instrument, bar duration, and event timestamp. Integrity constraints ensure basic OHLC consistency and prevent invalid price relationships from being stored. The table uses <code>WITHOUT ROWID</code> to store rows directly in the primary key B-tree for reduced storage overhead and faster lookups.</p> <pre><code>CREATE TABLE ohlcv (\n    instrument_id INTEGER NOT NULL,\n    rtype INTEGER NOT NULL CHECK(rtype IN (32, 33, 34, 35, 36)),\n    ts_event INTEGER NOT NULL,\n    open INTEGER NOT NULL,\n    high INTEGER NOT NULL,\n    low INTEGER NOT NULL,\n    close INTEGER NOT NULL,\n    volume INTEGER NOT NULL CHECK(volume &gt;= 0),\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, rtype, ts_event),\n    CHECK(low &lt;= high),\n    CHECK(open BETWEEN low AND high),\n    CHECK(close BETWEEN low AND high)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#symbology","title":"Symbology","text":"<p>Stores time-bounded mappings from publisher-native symbols to publisher-native instrument identifiers.</p> <p>The table captures symbol resolution rules as provided by upstream data sources and must be interpreted within the namespace of a specific publisher.</p> <p>The schema permits multiple mappings to share the same <code>start_date</code> for a given (<code>publisher_ref</code>, <code>symbol</code>, <code>symbol_type</code>) by including <code>source_instrument_id</code> in the primary key. This prevents accidental overwrite when upstream symbology exports contain same-day corrections, backfills, or parallel resolution segments.</p> Field Type Constraints Description <code>publisher_ref</code> <code>INTEGER</code> <code>NOT NULL</code>, <code>FK</code> Foreign key reference to <code>publishers.publisher_id</code>, defining the publisher namespace in which the symbol mapping is valid. <code>symbol</code> <code>TEXT</code> <code>NOT NULL</code> Publisher-native symbol string as provided by the upstream source (e.g. raw symbol, continuous symbol). <code>symbol_type</code> <code>TEXT</code> <code>NOT NULL</code> Identifier describing the symbol scheme or resolution type used by the publisher (e.g. <code>raw_symbol</code>, <code>continuous</code>). <code>source_instrument_id</code> <code>INTEGER</code> <code>NOT NULL</code> Publisher-native numeric instrument identifier corresponding to the resolved symbol. <code>start_date</code> <code>TEXT</code> <code>NOT NULL</code> First calendar date (inclusive) on which this symbol-to-instrument mapping is valid, stored in YYYY-MM-DD format. <code>end_date</code> <code>TEXT</code> <code>NOT NULL</code> First calendar date (exclusive) after which this symbol-to-instrument mapping is no longer valid, stored in YYYY-MM-DD format. <p>The primary key enforces uniqueness of mappings at the granularity of a resolved instrument. Date bounds are interpreted as half-open intervals [start_date, end_date).</p> <pre><code>CREATE TABLE symbology (\n    publisher_ref INTEGER NOT NULL,\n    symbol TEXT NOT NULL,\n    symbol_type TEXT NOT NULL,\n    source_instrument_id INTEGER NOT NULL,\n    start_date TEXT NOT NULL,\n    end_date TEXT NOT NULL,\n    FOREIGN KEY (publisher_ref) REFERENCES publishers(publisher_id),\n    FOREIGN KEY (publisher_ref, source_instrument_id)\n        REFERENCES instruments(publisher_ref, source_instrument_id),\n    PRIMARY KEY (publisher_ref, symbol, symbol_type, start_date, source_instrument_id),\n    CHECK (start_date &lt;= end_date)\n);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#idx_symbology_symbol","title":"Idx_symbology_symbol","text":"<pre><code>CREATE INDEX idx_symbology_symbol ON symbology(symbol);\n</code></pre>"},{"location":"reference/secmaster/schema_versions/secmaster_schema_v1/#symbol_coverage","title":"Symbol_coverage","text":"<pre><code>CREATE TABLE symbol_coverage (\n    publisher_id INTEGER NOT NULL,\n    symbol TEXT NOT NULL,\n    rtype INTEGER NOT NULL,\n    min_ts INTEGER NOT NULL,\n    max_ts INTEGER NOT NULL,\n    FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id),\n    PRIMARY KEY (publisher_id, symbol, rtype)\n);\n</code></pre>"},{"location":"reference/strategies/base/","title":"Base","text":""},{"location":"reference/strategies/base/#onesecondtrader.strategies.base._strategy_registry","title":"<code>_strategy_registry = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.ParamSpec","title":"<code>ParamSpec</code>  <code>dataclass</code>","text":"<p>Specification for a strategy parameter.</p> <p>Defines the default value and optional constraints for a configurable strategy parameter. Used to declare tunable parameters that can be overridden at strategy instantiation.</p> Field Type Semantics <code>default</code> <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, or <code>Enum</code> Default value of the parameter. <code>min</code> <code>int</code>, <code>float</code>, or <code>None</code> Minimum allowed value, if applicable. <code>max</code> <code>int</code>, <code>float</code>, or <code>None</code> Maximum allowed value, if applicable. <code>step</code> <code>int</code>, <code>float</code>, or <code>None</code> Step size for parameter sweeps, if applicable. <code>choices</code> <code>list</code> or <code>None</code> Explicit list of allowed values, if applicable. Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>@dataclasses.dataclass\nclass ParamSpec:\n    \"\"\"\n    Specification for a strategy parameter.\n\n    Defines the default value and optional constraints for a configurable strategy parameter.\n    Used to declare tunable parameters that can be overridden at strategy instantiation.\n\n    | Field     | Type                                      | Semantics                                                    |\n    |-----------|-------------------------------------------|--------------------------------------------------------------|\n    | `default` | `int`, `float`, `str`, `bool`, or `Enum`  | Default value of the parameter.                              |\n    | `min`     | `int`, `float`, or `None`                 | Minimum allowed value, if applicable.                        |\n    | `max`     | `int`, `float`, or `None`                 | Maximum allowed value, if applicable.                        |\n    | `step`    | `int`, `float`, or `None`                 | Step size for parameter sweeps, if applicable.               |\n    | `choices` | `list` or `None`                          | Explicit list of allowed values, if applicable.              |\n    \"\"\"\n\n    default: int | float | str | bool | enum.Enum\n    min: int | float | None = None\n    max: int | float | None = None\n    step: int | float | None = None\n    choices: list | None = None\n\n    @property\n    def resolved_choices(self) -&gt; list | None:\n        \"\"\"\n        Return the effective list of allowed values for this parameter.\n\n        If `choices` is explicitly set, returns that list.\n        If `default` is an enum member, returns all members of that enum type.\n        Otherwise, returns `None`.\n        \"\"\"\n        if self.choices is not None:\n            return self.choices\n        if isinstance(self.default, enum.Enum):\n            return list(type(self.default))\n        return None\n</code></pre> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def resolved_choices(self) -&gt; list | None:\n    \"\"\"\n    Return the effective list of allowed values for this parameter.\n\n    If `choices` is explicitly set, returns that list.\n    If `default` is an enum member, returns all members of that enum type.\n    Otherwise, returns `None`.\n    \"\"\"\n    if self.choices is not None:\n        return self.choices\n    if isinstance(self.default, enum.Enum):\n        return list(type(self.default))\n    return None\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.ParamSpec.resolved_choices","title":"<code>resolved_choices</code>  <code>property</code>","text":"<p>Return the effective list of allowed values for this parameter.</p> <p>If <code>choices</code> is explicitly set, returns that list. If <code>default</code> is an enum member, returns all members of that enum type. Otherwise, returns <code>None</code>.</p>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.OrderRecord","title":"<code>OrderRecord</code>  <code>dataclass</code>","text":"<p>Internal record of an order submitted by a strategy.</p> <p>Tracks the state of an order from submission through fill or cancellation.</p> Field Type Semantics <code>order_id</code> <code>uuid.UUID</code> System-assigned unique identifier for the order. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>order_type</code> <code>models.OrderType</code> Execution constraint of the order. <code>side</code> <code>models.TradeSide</code> Direction of the trade. <code>quantity</code> <code>float</code> Requested order quantity. <code>limit_price</code> <code>float</code> or <code>None</code> Limit price, if applicable to the order type. <code>stop_price</code> <code>float</code> or <code>None</code> Stop price, if applicable to the order type. <code>signal</code> <code>str</code> or <code>None</code> Optional signal name associated with the order. <code>filled_quantity</code> <code>float</code> Cumulative quantity filled for this order. Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>@dataclasses.dataclass\nclass OrderRecord:\n    \"\"\"\n    Internal record of an order submitted by a strategy.\n\n    Tracks the state of an order from submission through fill or cancellation.\n\n    | Field             | Type               | Semantics                                           |\n    |-------------------|--------------------|-----------------------------------------------------|\n    | `order_id`        | `uuid.UUID`        | System-assigned unique identifier for the order.    |\n    | `symbol`          | `str`              | Identifier of the traded instrument.                |\n    | `order_type`      | `models.OrderType` | Execution constraint of the order.                  |\n    | `side`            | `models.TradeSide` | Direction of the trade.                             |\n    | `quantity`        | `float`            | Requested order quantity.                           |\n    | `limit_price`     | `float` or `None`  | Limit price, if applicable to the order type.       |\n    | `stop_price`      | `float` or `None`  | Stop price, if applicable to the order type.        |\n    | `signal`          | `str` or `None`    | Optional signal name associated with the order.     |\n    | `filled_quantity` | `float`            | Cumulative quantity filled for this order.          |\n    \"\"\"\n\n    order_id: uuid.UUID\n    symbol: str\n    order_type: models.OrderType\n    side: models.TradeSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n    signal: str | None = None\n    filled_quantity: float = 0.0\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.FillRecord","title":"<code>FillRecord</code>  <code>dataclass</code>","text":"<p>Internal record of a fill received by a strategy.</p> <p>Captures execution details for a single fill event.</p> Field Type Semantics <code>fill_id</code> <code>uuid.UUID</code> System-assigned unique identifier for the fill. <code>order_id</code> <code>uuid.UUID</code> Identifier of the order associated with the fill. <code>symbol</code> <code>str</code> Identifier of the traded instrument. <code>side</code> <code>models.TradeSide</code> Trade direction of the executed quantity. <code>quantity</code> <code>float</code> Quantity executed in this fill. <code>price</code> <code>float</code> Execution price of the fill. <code>commission</code> <code>float</code> Commission or fee associated with the fill. <code>ts_event</code> <code>pd.Timestamp</code> Timestamp at which the fill was observed by the strategy. Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>@dataclasses.dataclass\nclass FillRecord:\n    \"\"\"\n    Internal record of a fill received by a strategy.\n\n    Captures execution details for a single fill event.\n\n    | Field        | Type               | Semantics                                                 |\n    |--------------|--------------------|-----------------------------------------------------------|\n    | `fill_id`    | `uuid.UUID`        | System-assigned unique identifier for the fill.           |\n    | `order_id`   | `uuid.UUID`        | Identifier of the order associated with the fill.         |\n    | `symbol`     | `str`              | Identifier of the traded instrument.                      |\n    | `side`       | `models.TradeSide` | Trade direction of the executed quantity.                 |\n    | `quantity`   | `float`            | Quantity executed in this fill.                           |\n    | `price`      | `float`            | Execution price of the fill.                              |\n    | `commission` | `float`            | Commission or fee associated with the fill.               |\n    | `ts_event`   | `pd.Timestamp`     | Timestamp at which the fill was observed by the strategy. |\n    \"\"\"\n\n    fill_id: uuid.UUID\n    order_id: uuid.UUID\n    symbol: str\n    side: models.TradeSide\n    quantity: float\n    price: float\n    commission: float\n    ts_event: pd.Timestamp\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase","title":"<code>StrategyBase</code>","text":"<p>               Bases: <code>Subscriber</code>, <code>ABC</code></p> <p>Abstract base class for trading strategies.</p> <p>A strategy subscribes to market data and order events, maintains position state, and submits orders through the event bus. Subclasses implement <code>on_bar</code> to define trading logic and optionally override <code>setup</code> to register indicators.</p> <p>Subclasses are automatically registered for dashboard discovery when defined.</p> Class Attributes <p>name:     Human-readable name of the strategy. symbols:     List of instrument symbols the strategy trades. parameters:     Dictionary mapping parameter names to their specifications.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def position(self) -&gt; float:\n    \"\"\"\n    Return the current position for the active symbol.\n\n    The active symbol is set by the most recently processed bar event.\n    \"\"\"\n    return self._positions.get(self._current_symbol, 0.0)\n</code></pre> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def avg_price(self) -&gt; float:\n    \"\"\"\n    Return the average entry price for the current position on the active symbol.\n\n    Returns zero if there is no open position.\n    \"\"\"\n    return self._avg_prices.get(self._current_symbol, 0.0)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.position","title":"<code>position</code>  <code>property</code>","text":"<p>Return the current position for the active symbol.</p> <p>The active symbol is set by the most recently processed bar event.</p>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.avg_price","title":"<code>avg_price</code>  <code>property</code>","text":"<p>Return the average entry price for the current position on the active symbol.</p> <p>Returns zero if there is no open position.</p>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def __init_subclass__(cls, **kwargs: object) -&gt; None:\n    super().__init_subclass__(**kwargs)\n    if not cls.__name__.startswith(\"_\"):\n        _strategy_registry[cls.__name__] = cls\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.__init__","title":"<code>__init__(event_bus, **overrides)</code>","text":"<p>Initialize the strategy and start event processing.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used for subscribing to and publishing events.</p> required <code>**overrides</code> <code>object</code> <p>Parameter values to override defaults defined in <code>parameters</code>.</p> <code>{}</code> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus, **overrides: object) -&gt; None:\n    \"\"\"\n    Initialize the strategy and start event processing.\n\n    Parameters:\n        event_bus:\n            Event bus used for subscribing to and publishing events.\n        **overrides:\n            Parameter values to override defaults defined in `parameters`.\n    \"\"\"\n    super().__init__(event_bus)\n\n    for name, spec in self.parameters.items():\n        value = overrides.get(name, spec.default)\n        setattr(self, name, value)\n\n    self._subscribe(\n        events.market.BarReceived,\n        events.responses.OrderAccepted,\n        events.responses.ModificationAccepted,\n        events.responses.CancellationAccepted,\n        events.responses.OrderRejected,\n        events.responses.ModificationRejected,\n        events.responses.CancellationRejected,\n        events.orders.FillEvent,\n        events.orders.OrderExpired,\n    )\n\n    self._current_symbol: str = \"\"\n    self._current_ts: pd.Timestamp = pd.Timestamp.now(tz=\"UTC\")\n    self._indicators: list[indicators.IndicatorBase] = []\n\n    self._fills: dict[str, list[FillRecord]] = {}\n    self._positions: dict[str, float] = {}\n    self._avg_prices: dict[str, float] = {}\n    self._pending_orders: dict[uuid.UUID, OrderRecord] = {}\n    self._submitted_orders: dict[uuid.UUID, OrderRecord] = {}\n    self._submitted_modifications: dict[uuid.UUID, OrderRecord] = {}\n    self._submitted_cancellations: dict[uuid.UUID, OrderRecord] = {}\n\n    # OHLCV as indicators for history access: self.bar.close.history\n    self.bar = SimpleNamespace(\n        open=self.add_indicator(indicators.Open()),\n        high=self.add_indicator(indicators.High()),\n        low=self.add_indicator(indicators.Low()),\n        close=self.add_indicator(indicators.Close()),\n        volume=self.add_indicator(indicators.Volume()),\n    )\n\n    # Hook for subclasses to register indicators without overriding __init__\n    self.setup()\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.add_indicator","title":"<code>add_indicator(ind)</code>","text":"<p>Register an indicator with the strategy.</p> <p>Registered indicators are automatically updated on each bar event.</p> <p>Parameters:</p> Name Type Description Default <code>ind</code> <code>IndicatorBase</code> <p>Indicator instance to register.</p> required <p>Returns:</p> Type Description <code>IndicatorBase</code> <p>The registered indicator instance.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def add_indicator(self, ind: indicators.IndicatorBase) -&gt; indicators.IndicatorBase:\n    \"\"\"\n    Register an indicator with the strategy.\n\n    Registered indicators are automatically updated on each bar event.\n\n    Parameters:\n        ind:\n            Indicator instance to register.\n\n    Returns:\n        The registered indicator instance.\n    \"\"\"\n    self._indicators.append(ind)\n    return ind\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.submit_order","title":"<code>submit_order(order_type, side, quantity, limit_price=None, stop_price=None, action=None, signal=None)</code>","text":"<p>Submit a new order for the active symbol.</p> <p>Parameters:</p> Name Type Description Default <code>order_type</code> <code>OrderType</code> <p>Execution constraint of the order.</p> required <code>side</code> <code>TradeSide</code> <p>Direction of the trade.</p> required <code>quantity</code> <code>float</code> <p>Requested order quantity.</p> required <code>limit_price</code> <code>float | None</code> <p>Limit price, if applicable to the order type.</p> <code>None</code> <code>stop_price</code> <code>float | None</code> <p>Stop price, if applicable to the order type.</p> <code>None</code> <code>action</code> <code>ActionType | None</code> <p>Intent of the order from the strategy's perspective (e.g., entry, exit).</p> <code>None</code> <code>signal</code> <code>str | None</code> <p>Optional signal name associated with the order.</p> <code>None</code> <p>Returns:</p> Type Description <code>UUID</code> <p>System-assigned unique identifier for the submitted order.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def submit_order(\n    self,\n    order_type: models.OrderType,\n    side: models.TradeSide,\n    quantity: float,\n    limit_price: float | None = None,\n    stop_price: float | None = None,\n    action: models.ActionType | None = None,\n    signal: str | None = None,\n) -&gt; uuid.UUID:\n    \"\"\"\n    Submit a new order for the active symbol.\n\n    Parameters:\n        order_type:\n            Execution constraint of the order.\n        side:\n            Direction of the trade.\n        quantity:\n            Requested order quantity.\n        limit_price:\n            Limit price, if applicable to the order type.\n        stop_price:\n            Stop price, if applicable to the order type.\n        action:\n            Intent of the order from the strategy's perspective (e.g., entry, exit).\n        signal:\n            Optional signal name associated with the order.\n\n    Returns:\n        System-assigned unique identifier for the submitted order.\n    \"\"\"\n    order_id = uuid.uuid4()\n\n    event = events.requests.OrderSubmissionRequest(\n        ts_event_ns=int(self._current_ts.value),\n        system_order_id=order_id,\n        symbol=self._current_symbol,\n        order_type=order_type,\n        side=side,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n        action=action,\n        signal=signal,\n    )\n\n    order = OrderRecord(\n        order_id=order_id,\n        symbol=self._current_symbol,\n        order_type=order_type,\n        side=side,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n        signal=signal,\n    )\n\n    self._submitted_orders[order_id] = order\n    self._publish(event)\n    return order_id\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.submit_modification","title":"<code>submit_modification(order_id, quantity=None, limit_price=None, stop_price=None)</code>","text":"<p>Submit a modification request for a pending order.</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>UUID</code> <p>Identifier of the order to modify.</p> required <code>quantity</code> <code>float | None</code> <p>Updated order quantity, or <code>None</code> to keep unchanged.</p> <code>None</code> <code>limit_price</code> <code>float | None</code> <p>Updated limit price, or <code>None</code> to keep unchanged.</p> <code>None</code> <code>stop_price</code> <code>float | None</code> <p>Updated stop price, or <code>None</code> to keep unchanged.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the modification request was submitted, <code>False</code> if the order was not found.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def submit_modification(\n    self,\n    order_id: uuid.UUID,\n    quantity: float | None = None,\n    limit_price: float | None = None,\n    stop_price: float | None = None,\n) -&gt; bool:\n    \"\"\"\n    Submit a modification request for a pending order.\n\n    Parameters:\n        order_id:\n            Identifier of the order to modify.\n        quantity:\n            Updated order quantity, or `None` to keep unchanged.\n        limit_price:\n            Updated limit price, or `None` to keep unchanged.\n        stop_price:\n            Updated stop price, or `None` to keep unchanged.\n\n    Returns:\n        `True` if the modification request was submitted, `False` if the order was not found.\n    \"\"\"\n    original_order = self._pending_orders.get(order_id)\n    if original_order is None:\n        return False\n\n    event = events.requests.OrderModificationRequest(\n        ts_event_ns=int(self._current_ts.value),\n        system_order_id=order_id,\n        symbol=original_order.symbol,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n    )\n\n    modified_order = OrderRecord(\n        order_id=order_id,\n        symbol=original_order.symbol,\n        order_type=original_order.order_type,\n        side=original_order.side,\n        quantity=quantity if quantity is not None else original_order.quantity,\n        limit_price=(\n            limit_price if limit_price is not None else original_order.limit_price\n        ),\n        stop_price=(\n            stop_price if stop_price is not None else original_order.stop_price\n        ),\n        signal=original_order.signal,\n        filled_quantity=original_order.filled_quantity,\n    )\n\n    self._submitted_modifications[order_id] = modified_order\n    self._publish(event)\n    return True\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.submit_cancellation","title":"<code>submit_cancellation(order_id)</code>","text":"<p>Submit a cancellation request for a pending order.</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>UUID</code> <p>Identifier of the order to cancel.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the cancellation request was submitted, <code>False</code> if the order was not found.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def submit_cancellation(self, order_id: uuid.UUID) -&gt; bool:\n    \"\"\"\n    Submit a cancellation request for a pending order.\n\n    Parameters:\n        order_id:\n            Identifier of the order to cancel.\n\n    Returns:\n        `True` if the cancellation request was submitted, `False` if the order was not found.\n    \"\"\"\n    original_order = self._pending_orders.get(order_id)\n    if original_order is None:\n        return False\n\n    event = events.requests.OrderCancellationRequest(\n        ts_event_ns=int(self._current_ts.value),\n        system_order_id=order_id,\n        symbol=original_order.symbol,\n    )\n\n    self._submitted_cancellations[order_id] = original_order\n    self._publish(event)\n    return True\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_event","title":"<code>_on_event(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    match event:\n        case events.market.BarReceived() as bar_event:\n            self._on_bar_received(bar_event)\n        case events.responses.OrderAccepted() as accepted:\n            self._on_order_submission_accepted(accepted)\n        case events.responses.ModificationAccepted() as accepted:\n            self._on_order_modification_accepted(accepted)\n        case events.responses.CancellationAccepted() as accepted:\n            self._on_order_cancellation_accepted(accepted)\n        case events.responses.OrderRejected() as rejected:\n            self._on_order_submission_rejected(rejected)\n        case events.responses.ModificationRejected() as rejected:\n            self._on_order_modification_rejected(rejected)\n        case events.responses.CancellationRejected() as rejected:\n            self._on_order_cancellation_rejected(rejected)\n        case events.orders.FillEvent() as filled:\n            self._on_order_filled(filled)\n        case events.orders.OrderExpired() as expired:\n            self._on_order_expired(expired)\n        case _:\n            return\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_bar_received","title":"<code>_on_bar_received(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_bar_received(self, event: events.market.BarReceived) -&gt; None:\n    if event.symbol not in self.symbols:\n        return\n    if event.bar_period != self.bar_period:  # type: ignore[attr-defined]\n        return\n\n    self._current_symbol = event.symbol\n    self._current_ts = pd.Timestamp(event.ts_event_ns, tz=\"UTC\")\n\n    for ind in self._indicators:\n        ind.update(event)\n\n    self._emit_processed_bar(event)\n    self.on_bar(event)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._emit_processed_bar","title":"<code>_emit_processed_bar(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _emit_processed_bar(self, event: events.market.BarReceived) -&gt; None:\n    ohlcv_names = {\"OPEN\", \"HIGH\", \"LOW\", \"CLOSE\", \"VOLUME\"}\n    style_codes = {\n        models.PlotStyle.LINE: \"L\",\n        models.PlotStyle.HISTOGRAM: \"H\",\n        models.PlotStyle.DOTS: \"D\",\n    }\n\n    indicator_values = {\n        f\"{ind.plot_at:02d}{style_codes[ind.plot_as]}_{ind.name}\": ind.latest(\n            event.symbol\n        )\n        for ind in self._indicators\n        if ind.name not in ohlcv_names or ind.plot_at != 99\n    }\n\n    processed_bar = events.market.BarProcessed(\n        ts_event_ns=event.ts_event_ns,\n        symbol=event.symbol,\n        bar_period=event.bar_period,\n        open=event.open,\n        high=event.high,\n        low=event.low,\n        close=event.close,\n        volume=event.volume,\n        indicators=indicator_values,\n    )\n\n    self._publish(processed_bar)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_submission_accepted","title":"<code>_on_order_submission_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_submission_accepted(\n    self, event: events.responses.OrderAccepted\n) -&gt; None:\n    order = self._submitted_orders.pop(event.associated_order_id, None)\n    if order is not None:\n        self._pending_orders[event.associated_order_id] = order\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_modification_accepted","title":"<code>_on_order_modification_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_modification_accepted(\n    self, event: events.responses.ModificationAccepted\n) -&gt; None:\n    modified_order = self._submitted_modifications.pop(\n        event.associated_order_id, None\n    )\n    if modified_order is not None:\n        self._pending_orders[event.associated_order_id] = modified_order\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_cancellation_accepted","title":"<code>_on_order_cancellation_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_cancellation_accepted(\n    self, event: events.responses.CancellationAccepted\n) -&gt; None:\n    self._submitted_cancellations.pop(event.associated_order_id, None)\n    self._pending_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_submission_rejected","title":"<code>_on_order_submission_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_submission_rejected(\n    self, event: events.responses.OrderRejected\n) -&gt; None:\n    self._submitted_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_modification_rejected","title":"<code>_on_order_modification_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_modification_rejected(\n    self, event: events.responses.ModificationRejected\n) -&gt; None:\n    self._submitted_modifications.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_cancellation_rejected","title":"<code>_on_order_cancellation_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_cancellation_rejected(\n    self, event: events.responses.CancellationRejected\n) -&gt; None:\n    self._submitted_cancellations.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_filled","title":"<code>_on_order_filled(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_filled(self, event: events.orders.FillEvent) -&gt; None:\n    order = self._pending_orders.get(event.associated_order_id)\n    if order:\n        order.filled_quantity += event.quantity_filled\n        if order.filled_quantity &gt;= order.quantity:\n            self._pending_orders.pop(event.associated_order_id)\n\n    fill = FillRecord(\n        fill_id=event.fill_id,\n        order_id=event.associated_order_id,\n        symbol=event.symbol,\n        side=event.side,\n        quantity=event.quantity_filled,\n        price=event.fill_price,\n        commission=event.commission,\n        ts_event=pd.Timestamp(event.ts_event_ns, tz=\"UTC\"),\n    )\n\n    self._fills.setdefault(event.symbol, []).append(fill)\n    self._update_position(event)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._update_position","title":"<code>_update_position(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _update_position(self, event: events.orders.FillEvent) -&gt; None:\n    symbol = event.symbol\n    fill_qty = event.quantity_filled\n    fill_price = event.fill_price\n\n    signed_qty = 0.0\n    match event.side:\n        case models.TradeSide.BUY:\n            signed_qty = fill_qty\n        case models.TradeSide.SELL:\n            signed_qty = -fill_qty\n\n    old_pos = self._positions.get(symbol, 0.0)\n    old_avg = self._avg_prices.get(symbol, 0.0)\n    new_pos = old_pos + signed_qty\n\n    if new_pos == 0.0:\n        new_avg = 0.0\n    elif old_pos == 0.0:\n        new_avg = fill_price\n    elif (old_pos &gt; 0 and signed_qty &gt; 0) or (old_pos &lt; 0 and signed_qty &lt; 0):\n        new_avg = (old_avg * abs(old_pos) + fill_price * abs(signed_qty)) / abs(\n            new_pos\n        )\n    else:\n        if abs(new_pos) &lt;= abs(old_pos):\n            new_avg = old_avg\n        else:\n            new_avg = fill_price\n\n    self._positions[symbol] = new_pos\n    self._avg_prices[symbol] = new_avg\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase._on_order_expired","title":"<code>_on_order_expired(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def _on_order_expired(self, event: events.orders.OrderExpired) -&gt; None:\n    self._pending_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.setup","title":"<code>setup()</code>","text":"<p>Hook for subclasses to register indicators and perform initialization.</p> <p>Called at the end of <code>__init__</code>. Override this method to register indicators using <code>add_indicator</code> without needing to override <code>__init__</code>.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def setup(self) -&gt; None:\n    \"\"\"\n    Hook for subclasses to register indicators and perform initialization.\n\n    Called at the end of `__init__`. Override this method to register indicators\n    using `add_indicator` without needing to override `__init__`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.StrategyBase.on_bar","title":"<code>on_bar(event)</code>  <code>abstractmethod</code>","text":"<p>Handle a bar event for a subscribed symbol.</p> <p>Called after all registered indicators have been updated. Subclasses implement this method to define trading logic.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>BarReceived</code> <p>Bar event containing OHLCV data for the current bar.</p> required Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>@abc.abstractmethod\ndef on_bar(self, event: events.market.BarReceived) -&gt; None:\n    \"\"\"\n    Handle a bar event for a subscribed symbol.\n\n    Called after all registered indicators have been updated. Subclasses implement\n    this method to define trading logic.\n\n    Parameters:\n        event:\n            Bar event containing OHLCV data for the current bar.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.get_registered_strategies","title":"<code>get_registered_strategies()</code>","text":"<p>Return all registered strategy classes.</p> <p>Returns:</p> Type Description <code>dict[str, type[StrategyBase]]</code> <p>Dictionary mapping strategy class names to their class objects.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def get_registered_strategies() -&gt; dict[str, type[StrategyBase]]:\n    \"\"\"\n    Return all registered strategy classes.\n\n    Returns:\n        Dictionary mapping strategy class names to their class objects.\n    \"\"\"\n    return dict(_strategy_registry)\n</code></pre>"},{"location":"reference/strategies/base/#onesecondtrader.strategies.base.discover_strategies","title":"<code>discover_strategies(directory='strategies')</code>","text":"<p>Import all Python files from a directory to register strategies.</p> <p>Any class inheriting from StrategyBase in the imported files will be automatically registered via init_subclass.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>Path to the directory containing strategy files. Defaults to \"strategies\" relative to the current working directory.</p> <code>'strategies'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of successfully imported module names.</p> Source code in <code>src/onesecondtrader/strategies/base.py</code> <pre><code>def discover_strategies(directory: str | Path = \"strategies\") -&gt; list[str]:\n    \"\"\"\n    Import all Python files from a directory to register strategies.\n\n    Any class inheriting from StrategyBase in the imported files will be\n    automatically registered via __init_subclass__.\n\n    Parameters:\n        directory:\n            Path to the directory containing strategy files.\n            Defaults to \"strategies\" relative to the current working directory.\n\n    Returns:\n        List of successfully imported module names.\n    \"\"\"\n    path = Path(directory)\n    if not path.is_dir():\n        return []\n\n    imported = []\n    for file in path.glob(\"*.py\"):\n        if file.name.startswith(\"_\"):\n            continue\n\n        module_name = f\"user_strategies.{file.stem}\"\n        spec = importlib.util.spec_from_file_location(module_name, file)\n        if spec is None or spec.loader is None:\n            continue\n\n        module = importlib.util.module_from_spec(spec)\n        try:\n            spec.loader.exec_module(module)\n            imported.append(file.stem)\n        except Exception:\n            pass\n\n    return imported\n</code></pre>"},{"location":"reference/strategies/examples/","title":"Examples","text":""},{"location":"reference/strategies/examples/#onesecondtrader.strategies.examples.SMACrossover","title":"<code>SMACrossover</code>","text":"<p>               Bases: <code>StrategyBase</code></p>"},{"location":"reference/strategies/examples/#onesecondtrader.strategies.examples.SMACrossover.setup","title":"<code>setup()</code>","text":"Source code in <code>src/onesecondtrader/strategies/examples.py</code> <pre><code>def setup(self) -&gt; None:\n    self.fast_sma = self.add_indicator(\n        indicators.SimpleMovingAverage(period=self.fast_period, plot_at=0)  # type: ignore[attr-defined]\n    )\n    self.slow_sma = self.add_indicator(\n        indicators.SimpleMovingAverage(period=self.slow_period, plot_at=0)  # type: ignore[attr-defined]\n    )\n    self.add_indicator(\n        indicators.Volume(plot_at=1, plot_as=models.PlotStyle.HISTOGRAM)\n    )\n</code></pre>"},{"location":"reference/strategies/examples/#onesecondtrader.strategies.examples.SMACrossover.on_bar","title":"<code>on_bar(event)</code>","text":"Source code in <code>src/onesecondtrader/strategies/examples.py</code> <pre><code>def on_bar(self, event: events.market.BarReceived) -&gt; None:\n    sym = event.symbol\n    if (\n        self.fast_sma[sym, -2] &lt;= self.slow_sma[sym, -2]\n        and self.fast_sma.latest(sym) &gt; self.slow_sma.latest(sym)\n        and self.position &lt;= 0\n    ):\n        self.submit_order(\n            models.OrderType.MARKET,\n            models.TradeSide.BUY,\n            self.quantity,  # type: ignore[attr-defined]\n            action=models.ActionType.ENTRY,\n            signal=\"sma_crossover_up\",\n        )\n\n    if (\n        self.fast_sma[sym, -2] &gt;= self.slow_sma[sym, -2]\n        and self.fast_sma.latest(sym) &lt; self.slow_sma.latest(sym)\n        and self.position &gt;= 0\n    ):\n        self.submit_order(\n            models.OrderType.MARKET,\n            models.TradeSide.SELL,\n            self.quantity,  # type: ignore[attr-defined]\n            action=models.ActionType.EXIT,\n            signal=\"sma_crossover_down\",\n        )\n</code></pre>"},{"location":"tutorials/getting_started/","title":"Getting Started","text":"<p>This guide will teach you how to develop indicators, design strategies, and run backtests using OneSecondTrader. </p>"},{"location":"tutorials/getting_started/#installation","title":"Installation","text":"PipPoetry <p>Step 0</p> <p>Make sure that pip is installed. If not, install it by following the Official Documentation.</p> <p>Step 1</p> <p>Navigate to the folder you want to use or create a new one. Then run the following comand inside this folder to create a virtual environment:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <p>Step 2</p> <p>Install OneSecondTrader by running the following command:</p> <pre><code>pip install onesecondtrader\n</code></pre> <p>Step 0</p> <p>Make sure that poetry is installed. If not, install it by following the Official Documentation.</p> <p>Step 1</p> <p>Navigate to the folder you want to use or create a new one. Then run the following comand inside this folder:</p> <pre><code>poetry init\n</code></pre> <p>Step 2</p> <p>Add <code>package-mode = false</code> to your <code>pyproject.toml</code> file. It should look similar to this:</p> <pre><code>[project]\nname = \"stratdev\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\n    {name = \"...\",email = \"...\"}\n]\npackage-mode = false\n\n[tool.poetry.dependencies]\npython = \"&gt;=3.11,&lt;4.0\"\n\n[build-system]\nrequires = [\"poetry-core&gt;=2.0.0,&lt;3.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> <p>Step 3</p> <p>Install OneSecondTrader by running the following command:</p> <pre><code>poetry add onesecondtrader\n</code></pre> <p>Step 4</p> <p>Activate the virtual environment by running the following command:</p> <pre><code>poetry env activate\n</code></pre>"},{"location":"tutorials/getting_started/#historical-market-data","title":"Historical Market Data","text":"<p>Running backtests requires historical market data. For serious work, we recommend using a data provider like Databento.</p> DatabentoOther Providers <p>Step 0</p> <p>Assuming you already have a Databento account, download the data you want to use for backtesting in <code>.dbn</code> format and <code>.zst</code> compression (note that it does not matter how you choose to split the files). For more information, see the Databento Documentation. You should receive a .zip file that contains a <code>.dbn</code> file(s) and some metadata <code>.json</code> files (importantly, <code>symbology.json</code>).</p> <p>Step 1</p> <p>Start an interactive Python session (<code>poetry run python</code> if you use poetry, <code>python</code> or <code>python3</code> if you are using venv) and run the following commands to create an empty securities master database:</p> <pre><code>from onesecondtrader import secmaster\nfrom pathlib import Path\nsecmaster.create_secmaster_db(Path(\"secmaster.db\"))\n</code></pre> <p>Step 2</p> <p>Still in an interactive Python session, run the following commands to ingest the data into the database:</p> <pre><code>secmaster.ingest_databento_zip(Path(\"path/to/your/download.zip\"), Path(\"./secmaster.db\"))\n</code></pre> <p>This may take a while. After it's done, you can exit the interactive Python session (<code>exit()</code>).</p> <p>Step 3</p> <p>Set the <code>SECMASTER_DB_PATH</code> environment variable to the path of the database you just created. You can do this by running the following command (this is not necessary if you are running the dashboard from the same directory as the database):</p> macOS / LinuxWindows (PowerShell)Windows (CMD) <pre><code>export SECMASTER_DB_PATH=/path/to/your/secmaster.db\n</code></pre> <pre><code>$env:SECMASTER_DB_PATH = \"C:\\path\\to\\your\\secmaster.db\"\n</code></pre> <pre><code>set SECMASTER_DB_PATH=C:\\path\\to\\your\\secmaster.db\n</code></pre> <p>Coming Soon</p> <p>Other providers will be supported soon. If you want to contribute, please open an issue or submit a pull request.</p>"},{"location":"tutorials/getting_started/#exploring-the-dashboard","title":"Exploring the Dashboard","text":"<p>Now it is time to explore the dashboard. It will allow you to run backtests and analyze performance metrics. The OneSecondTrader package provides a simple SMA crossover strategy that you will backtest to acquaint yourself with the dashboard. Afterward, you will learn how to create your own indicators and strategies and backtest them via the dashboard.</p> <p>Step 0</p> <p>Start the dashboard server:</p> PipPoetry <pre><code>onesecondtrader\n</code></pre> <pre><code>poetry run onesecondtrader\n</code></pre> <p>Open your browser and navigate to http://127.0.0.1:8001.</p> <p>Step 1</p> <p>Once the dashboard is up and running, you should see the following page:</p> <p></p> <p>Now select the strategy (recommended: <code>SMA Crossover</code> for demonstration purposes) and optionally tweak the parameters. Then select the bar period (the shown options depend on the data you have ingested) and the publisher and dataset (again, you will only see what you have ingested).</p> <p>Then select a symbol (or symbols) and set the date range.</p> <p></p> <p>Step 2</p> <p>Click <code>Run Backtest</code> and wait for it to finish.</p> <p></p> <p>You can then click on the run once it is completed to view the performance metrics and charts. This will guide you to the performance page. You can also access the performance page by clicking on the <code>Performance</code> link in the sidebar. Once a run is selected, you will be shown the performance metrics for that run. If you click on a specific trade in the table, you will be shown a chart of that trade. To view per-trade performance metrics, you will need to select the symbol first via the search bar above the table.</p> <p></p>"},{"location":"tutorials/getting_started/#developing-indicators","title":"Developing Indicators","text":"<p>Now it is time to develop your first indicator.</p> <p>Step 0</p> <p>It is advisable to familiarize yourself with how OneSecondTrader works under the hood. I recommend that you take a look at (at least) the following packages and their source code:</p> <ul> <li><code>onesecondtrader.models</code></li> <li><code>onesecondtrader.events</code></li> <li><code>onesecondtrader.messaging</code></li> <li><code>onesecondtrader.indicators</code></li> <li><code>onesecondtrader.strategies</code></li> </ul> <p>Step 1</p> <p>Create an <code>indicators/</code> folder in the same directory as your <code>secmaster.db</code> file, then create a new file called <code>my_indicators.py</code> inside it.</p> <p>Step 2</p> <p>Implement your indicator by subclassing <code>onesecondtrader.indicators.IndicatorBase</code> and implementing the <code>name</code> property and the <code>_compute_indicator</code> method. Let us implement one of the simplest of indicators, the close price indicator.</p> indicators/my_indicators.py<pre><code>from onesecondtrader import events, indicators\n\nclass ClosePriceIndicator(indicators.IndicatorBase):\n    @property\n    def name(self) -&gt; str:\n        return \"CLOSE\"\n\n    def _compute_indicator(self, incoming_bar: events.market.BarReceived) -&gt; float:\n        return incoming_bar.close\n</code></pre> <p>Any indicator files placed in the <code>indicators/</code> folder will be automatically discovered when the dashboard starts.</p>"},{"location":"tutorials/getting_started/#developing-strategies","title":"Developing Strategies","text":"<p>Step 0</p> <p>If you have not already done so already in the previous step, familiarize yourself with how OneSecondTrader works under the hood. I recommend that you take a look at (at least) the following packages and their source code:</p> <ul> <li><code>onesecondtrader.models</code></li> <li><code>onesecondtrader.events</code></li> <li><code>onesecondtrader.messaging</code></li> <li><code>onesecondtrader.indicators</code></li> <li><code>onesecondtrader.strategies</code></li> </ul> <p>Step 1</p> <p>Create a <code>strategies/</code> folder in the same directory as your <code>secmaster.db</code> file, then create a new file called <code>my_strategies.py</code> inside it.</p> <p>Step 2</p> <p>Implement your strategy by subclassing <code>onesecondtrader.strategies.StrategyBase</code>. Note that you can access the indicator you implemented in the previous step by importing it.</p> strategies/my_strategies.py<pre><code>from onesecondtrader import events, models, strategies\nfrom indicators.my_indicators import ClosePriceIndicator\n\n\nclass MySimpleStrategy(strategies.StrategyBase):\n    name = \"My Simple Strategy\"\n    parameters = {\n        \"bar_period\": strategies.base.ParamSpec(default=models.BarPeriod.SECOND),\n        \"quantity\": strategies.base.ParamSpec(default=1.0, min=0.1, max=100.0, step=0.1),\n    }\n\n    def setup(self) -&gt; None:\n        self.close_price = self.add_indicator(\n            ClosePriceIndicator(plot_at=1, plot_as=models.PlotStyle.LINE)\n        )\n\n    def on_bar(self, event: events.market.BarReceived) -&gt; None:\n        sym = event.symbol\n\n        if self.close_price[sym, -1] &gt; self.close_price[sym, -2]:\n            self.submit_order(\n                models.OrderType.MARKET,\n                models.TradeSide.BUY,\n                self.quantity,\n                action=models.ActionType.ENTRY,\n                signal=\"price_up\",\n            )\n\n        if (\n            self.position &gt; 0 and\n            self.close_price[sym, -1] &lt; self.close_price[sym, -2]\n        ):\n            self.submit_order(\n                models.OrderType.MARKET,\n                models.TradeSide.SELL,\n                self.quantity,\n                action=models.ActionType.EXIT,\n                signal=\"price_down\",\n            )\n</code></pre> <p>Any strategy files placed in the <code>strategies/</code> folder will be automatically discovered when the dashboard starts and will appear in the strategy dropdown.</p>"},{"location":"tutorials/local/","title":"Running the Dashboard Locally","text":"<p>This guide shows how to install OneSecondTrader and run the dashboard on your local machine.</p>"},{"location":"tutorials/local/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>A <code>secmaster.db</code> file containing your market data</li> </ul>"},{"location":"tutorials/local/#virtual-environment-setup","title":"Virtual Environment Setup","text":"<p>Create and activate a virtual environment:</p> macOS / LinuxWindows (PowerShell)Windows (CMD) <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\n</code></pre>"},{"location":"tutorials/local/#installation","title":"Installation","text":"<pre><code>pip install onesecondtrader\n</code></pre>"},{"location":"tutorials/local/#configuration","title":"Configuration","text":"<p>Set the path to your security master database:</p> macOS / LinuxWindows (PowerShell)Windows (CMD) <pre><code>export SECMASTER_DB_PATH=/path/to/your/secmaster.db\n</code></pre> <pre><code>$env:SECMASTER_DB_PATH = \"C:\\path\\to\\your\\secmaster.db\"\n</code></pre> <pre><code>set SECMASTER_DB_PATH=C:\\path\\to\\your\\secmaster.db\n</code></pre> <p>Optionally, set a custom path for the runs database (defaults to <code>runs.db</code> in the current directory):</p> macOS / LinuxWindows (PowerShell)Windows (CMD) <pre><code>export RUNS_DB_PATH=/path/to/runs.db\n</code></pre> <pre><code>$env:RUNS_DB_PATH = \"C:\\path\\to\\runs.db\"\n</code></pre> <pre><code>set RUNS_DB_PATH=C:\\path\\to\\runs.db\n</code></pre>"},{"location":"tutorials/local/#running-the-dashboard","title":"Running the Dashboard","text":"<p>Start the dashboard server:</p> <pre><code>onesecondtrader\n</code></pre> <p>Open your browser and navigate to http://127.0.0.1:8001.</p>"}]}