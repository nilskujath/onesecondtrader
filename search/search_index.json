{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"pippoetry <pre><code>pip install onesecondtrader \n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Core </p> <p>Contains:</p> <p><code>component.py</code>, <code>eventbus.py</code>, <code>events.py</code>, <code>models.py</code></p> <p> View <code>core/</code> package API</p> </li> </ul>"},{"location":"api-reference/core/component/","title":"Component","text":"<p>Read first: <code>events.py</code>, <code>eventbus.py</code>.</p> <p>This module defines the <code>Component</code> class.</p> <p>In an event-driven system, components interact exclusively via event messages. The <code>Component</code> class is an abstract base class that defines a common interface for publishing and receiving such messages and is intended to be subclassed by all system components.</p>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all system components.</p> <p>Incoming events are delivered via <code>receive()</code> and stored in an internal queue. A dedicated thread runs an event loop that consumes queued events and dispatches them to <code>_process()</code>, which subclasses must implement. For publication, <code>publish()</code> forwards events to the event bus. The <code>join_queue()</code> method is used by the event bus to block until all queued events have been processed, which is useful for deterministic, stepwise execution in backtesting.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>class Component:\n\n    def __init__(self, eventbus: EventBus) -&gt; None:\n        ...\n\n    def publish(self, event: Event) -&gt; None:\n        ...\n\n    def receive(self, event: Event) -&gt; None:\n        ...\n\n    def join_queue(self) -&gt; None:\n        ...\n\n    def _event_loop(self) -&gt; None:\n        ...\n\n    @abc.abstractmethod\n    def _process(self, event: Event) -&gt; None:\n        ...\n\n    def _shutdown(self) -&gt; None:\n        ...\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component.__init__","title":"<code>__init__(eventbus)</code>","text":"<p>Initialize the component and start its event-loop thread.</p> <p>Stores a reference to the event bus, creates an internal queue for incoming events, and starts a non-daemon thread for the event loop that runs until shutdown.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def __init__(self, eventbus: EventBus) -&gt; None:\n    \"\"\"\n    Initialize the component and start its event-loop thread.\n\n    Stores a reference to the event bus, creates an internal queue for incoming\n    events, and starts a non-daemon thread for the event loop that runs until\n    shutdown.\n    \"\"\"\n    self._event_bus = eventbus\n    self._incoming_event_queue: queue.Queue[Event | None] = queue.Queue()\n    self._thread: threading.Thread = threading.Thread(\n        target=self._event_loop,\n        name=self.__class__.__name__,\n        daemon=False,\n    )\n    self._thread.start()\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component.publish","title":"<code>publish(event)</code>","text":"<p>Wrapper for the event bus's <code>publish()</code> method.</p> <p>For convenience, this method can be used by subclasses to publish events via the event bus's publication mechanism.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def publish(self, event: Event) -&gt; None:\n    \"\"\"\n    Wrapper for the event bus's `publish()` method.\n\n    For convenience, this method can be used by subclasses to publish events via the\n    event bus's publication mechanism.\n    \"\"\"\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component.receive","title":"<code>receive(event)</code>","text":"<p>Store incoming events in the component's queue.</p> <p>This method is typically called by the event bus when an event is published that the component has subscribed to. It simply puts the event in the queue for processing by the subscribed component.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def receive(self, event: Event) -&gt; None:\n    \"\"\"\n    Store incoming events in the component's queue.\n\n    This method is typically called by the event bus when an event is published that\n    the component has subscribed to.\n    It simply puts the event in the queue for processing by the subscribed\n    component.\n    \"\"\"\n    self._incoming_event_queue.put(event)\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component.join_queue","title":"<code>join_queue()</code>","text":"<p>Block until all queued events have been processed.</p> <p>This method is used by the event bus to block until all queued events have been processed. This is useful for deterministic, stepwise execution in backtesting.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def join_queue(self) -&gt; None:\n    \"\"\"\n    Block until all queued events have been processed.\n\n    This method is used by the event bus to block until all queued events have been\n    processed.\n    This is useful for deterministic, stepwise execution in backtesting.\n    \"\"\"\n    self._incoming_event_queue.join()\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component._event_loop","title":"<code>_event_loop()</code>","text":"<p>Event-processing loop executed in the component\u2019s dedicated thread.</p> <p>The loop continuously retrieves events from the <code>incoming_event_queue</code>, processes each event via <code>_process()</code>, and signals completion with <code>task_done()</code>. Execution terminates upon receipt of a <code>None</code> sentinel, at which point <code>_shutdown()</code> is invoked before exiting the thread to ensure proper cleanup.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def _event_loop(self) -&gt; None:\n    \"\"\"\n    Event-processing loop executed in the component\u2019s dedicated thread.\n\n    The loop continuously retrieves events from the `incoming_event_queue`,\n    processes each event via `_process()`, and signals completion with\n    `task_done()`.\n    Execution terminates upon receipt of a `None` sentinel, at which point\n    `_shutdown()` is invoked before exiting the thread to ensure proper cleanup.\n    \"\"\"\n    while True:\n        incoming_event = self._incoming_event_queue.get()\n        if incoming_event is None:\n            self._shutdown()\n            self._incoming_event_queue.task_done()\n            break\n        self._process(incoming_event)\n        self._incoming_event_queue.task_done()\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component._process","title":"<code>_process(event)</code>  <code>abstractmethod</code>","text":"<p>Process a single event.</p> <p>This method is invoked by the event loop for each incoming event. Subclasses must implement it to define event-handling behavior.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>@abc.abstractmethod\ndef _process(self, event: Event) -&gt; None:\n    \"\"\"\n    Process a single event.\n\n    This method is invoked by the event loop for each incoming event.\n    Subclasses must implement it to define event-handling behavior.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/core/component/#onesecondtrader.core.component.Component._shutdown","title":"<code>_shutdown()</code>","text":"<p>Perform cleanup when the component is shutting down.</p> <p>Called by <code>_event_loop()</code> when a <code>None</code> sentinel is received. Subclasses may override this method to perform cleanup tasks such as closing files or connections before the thread exits.</p> Source code in <code>src/onesecondtrader/core/component.py</code> <pre><code>def _shutdown(self) -&gt; None:\n    \"\"\"\n    Perform cleanup when the component is shutting down.\n\n    Called by `_event_loop()` when a `None` sentinel is received.\n    Subclasses may override this method to perform cleanup tasks such as closing\n    files or connections before the thread exits.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/core/eventbus/","title":"Eventbus","text":"<p>Read first: <code>events.py</code>, <code>component.py</code>.</p> <p>This module defines the <code>EventBus</code> class.</p> <p>The event bus provides a publish\u2013subscribe mechanism for event-driven systems. It maintains subscriptions between event types and components and delivers published events to all subscribed components in a thread-safe manner.</p>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus","title":"<code>EventBus</code>","text":"<p>Central event-dispatch mechanism for the system.</p> <p>The event bus manages subscriptions between event types and components and forwards published events to all subscribed components.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>class EventBus:\n\n    def __init__(self) -&gt; None:\n        ...\n\n    def subscribe(self, subscriber: Component, event_types: type[Event]) -&gt; None:\n        ...\n\n    def unsubscribe(self, subscriber: Component) -&gt; None:\n        ...\n\n    def publish(self, event: Event) -&gt; None:\n        ...\n\n    def wait_until_idle(self) -&gt; None:\n        ...\n</code></pre>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the event bus.</p> <p>Sets up internal data structures for managing subscriptions and registered components and initializes a lock to ensure thread-safe access.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the event bus.\n\n    Sets up internal data structures for managing subscriptions and registered\n    components and initializes a lock to ensure thread-safe access.\n    \"\"\"\n    self._subscriptions: collections.defaultdict[type[Event], set[Component]] = (\n        collections.defaultdict(set)\n    )\n    self._components: set[Component] = set()\n    self._lock: threading.Lock = threading.Lock()\n</code></pre>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus.subscribe","title":"<code>subscribe(subscriber, *event_types)</code>","text":"<p>Subscribe a component to one or more event types.</p> <p>The subscriber will receive all future events whose type matches one of the specified event types.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>def subscribe(self, subscriber: Component, *event_types: type[Event]) -&gt; None:\n    \"\"\"\n    Subscribe a component to one or more event types.\n\n    The subscriber will receive all future events whose type matches one of the\n    specified event types.\n    \"\"\"\n    with self._lock:\n        self._components.add(subscriber)\n        for event_type in event_types:\n            self._subscriptions[event_type].add(subscriber)\n</code></pre>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(subscriber)</code>","text":"<p>Remove a component from all event subscriptions.</p> <p>After unsubscription, the component will no longer receive published events.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>def unsubscribe(self, subscriber: Component) -&gt; None:\n    \"\"\"\n    Remove a component from all event subscriptions.\n\n    After unsubscription, the component will no longer receive published events.\n    \"\"\"\n    with self._lock:\n        for component_set in self._subscriptions.values():\n            component_set.discard(subscriber)\n        self._components.discard(subscriber)\n</code></pre>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"<p>Publish an event to all subscribed components.</p> <p>The event is delivered to each subscriber by invoking its <code>receive()</code> method.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>def publish(self, event: Event) -&gt; None:\n    \"\"\"\n    Publish an event to all subscribed components.\n\n    The event is delivered to each subscriber by invoking its `receive()` method.\n    \"\"\"\n    with self._lock:\n        components = self._subscriptions[type(event)].copy()\n    for component in components:\n        component.receive(event)\n</code></pre>"},{"location":"api-reference/core/eventbus/#onesecondtrader.core.eventbus.EventBus.wait_until_idle","title":"<code>wait_until_idle()</code>","text":"<p>Block until all components have processed their queued events.</p> <p>This method is primarily used in backtesting to enforce deterministic, system-wide synchronization.</p> Source code in <code>src/onesecondtrader/core/eventbus.py</code> <pre><code>def wait_until_idle(self) -&gt; None:\n    \"\"\"\n    Block until all components have processed their queued events.\n\n    This method is primarily used in backtesting to enforce deterministic,\n    system-wide synchronization.\n    \"\"\"\n    with self._lock:\n        components = self._components.copy()\n    for component in components:\n        component.join_queue()\n</code></pre>"},{"location":"api-reference/core/events/","title":"Events","text":"<p>Read first: <code>models.py</code>.</p> <p>This module provides all event message classes used in the system.</p> <p>In an event-driven system, components communicate by sending event messages to each other. An event message is an immutable object that contains all information relevant to a specific occurrence, such as incoming market data, order submissions, fills, or other domain-specific events.</p>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>Base class for all event messages in the system.</p> <p>All events include a timestamp indicating when the event was created or received. Subclasses define specific event types with additional fields relevant to that event.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Event:\n    \"\"\"\n    Base class for all event messages in the system.\n\n    All events include a timestamp indicating when the event was created or received.\n    Subclasses define specific event types with additional fields relevant to that\n    event.\n    \"\"\"\n\n    ts_event: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.ReceivedNewBar","title":"<code>ReceivedNewBar</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating a new bar of market data has been received.</p> <p>Contains OHLCV data for a specific symbol and bar period. This event is typically emitted by data feed components when new market data arrives.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass ReceivedNewBar(Event):\n    \"\"\"\n    Event indicating a new bar of market data has been received.\n\n    Contains OHLCV data for a specific symbol and bar period. This event is typically\n    emitted by data feed components when new market data arrives.\n    \"\"\"\n\n    ts_event: pd.Timestamp\n    symbol: str\n    bar_period: BarPeriod\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.ProcessedBar","title":"<code>ProcessedBar</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating a bar has been processed and enriched with indicator values.</p> <p>Contains the same OHLCV data as ReceivedNewBar, plus a dictionary of computed indicator values. This event is typically emitted after strategies or other components have calculated technical indicators for the bar.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass ProcessedBar(Event):\n    \"\"\"\n    Event indicating a bar has been processed and enriched with indicator values.\n\n    Contains the same OHLCV data as ReceivedNewBar, plus a dictionary of computed\n    indicator values. This event is typically emitted after strategies or other\n    components have calculated technical indicators for the bar.\n    \"\"\"\n\n    ts_event: pd.Timestamp\n    symbol: str\n    bar_period: BarPeriod\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n    indicators: dict[str, float] = dataclasses.field(default_factory=dict)\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RequestOrderSubmission","title":"<code>RequestOrderSubmission</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event requesting submission of a new order with the broker.</p> <p>Contains all parameters needed to submit an order, including symbol, order type, side, quantity, and optional limit/stop prices. A unique order_id is automatically generated if not provided.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RequestOrderSubmission(Event):\n    \"\"\"\n    Event requesting submission of a new order with the broker.\n\n    Contains all parameters needed to submit an order, including symbol, order type,\n    side, quantity, and optional limit/stop prices. A unique order_id is automatically\n    generated if not provided.\n    \"\"\"\n\n    order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    symbol: str\n    order_type: OrderType\n    side: OrderSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RequestOrderModification","title":"<code>RequestOrderModification</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event requesting modification of an existing order.</p> <p>Identifies the order to modify by order_id and symbol. Any of quantity, limit_price, or stop_price can be updated by providing new values.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RequestOrderModification(Event):\n    \"\"\"\n    Event requesting modification of an existing order.\n\n    Identifies the order to modify by order_id and symbol. Any of quantity, limit_price,\n    or stop_price can be updated by providing new values.\n    \"\"\"\n\n    symbol: str\n    order_id: uuid.UUID\n    quantity: float | None = None\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RequestOrderCancellation","title":"<code>RequestOrderCancellation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event requesting cancellation of an existing order.</p> <p>Identifies the order to cancel by order_id and symbol.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RequestOrderCancellation(Event):\n    \"\"\"\n    Event requesting cancellation of an existing order.\n\n    Identifies the order to cancel by order_id and symbol.\n    \"\"\"\n\n    symbol: str\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.AcceptedOrderSubmission","title":"<code>AcceptedOrderSubmission</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has accepted an order submission.</p> <p>Contains the system's order_id and optionally the broker's order_id if provided by the broker.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass AcceptedOrderSubmission(Event):\n    \"\"\"\n    Event indicating the broker has accepted an order submission.\n\n    Contains the system's order_id and optionally the broker's order_id if provided\n    by the broker.\n    \"\"\"\n\n    order_id: uuid.UUID\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.AcceptedOrderModification","title":"<code>AcceptedOrderModification</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has accepted an order modification.</p> <p>Contains the system's order_id and optionally the broker's order_id if provided by the broker.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass AcceptedOrderModification(Event):\n    \"\"\"\n    Event indicating the broker has accepted an order modification.\n\n    Contains the system's order_id and optionally the broker's order_id if provided\n    by the broker.\n    \"\"\"\n\n    order_id: uuid.UUID\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.AcceptedOrderCancellation","title":"<code>AcceptedOrderCancellation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has accepted an order cancellation.</p> <p>Contains the system's order_id for the cancelled order.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass AcceptedOrderCancellation(Event):\n    \"\"\"\n    Event indicating the broker has accepted an order cancellation.\n\n    Contains the system's order_id for the cancelled order.\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RejectedOrderSubmission","title":"<code>RejectedOrderSubmission</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has rejected an order submission.</p> <p>Contains the system's order_id for the rejected order.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RejectedOrderSubmission(Event):\n    \"\"\"\n    Event indicating the broker has rejected an order submission.\n\n    Contains the system's order_id for the rejected order.\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RejectedOrderModification","title":"<code>RejectedOrderModification</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has rejected an order modification.</p> <p>Contains the system's order_id for the order that could not be modified.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RejectedOrderModification(Event):\n    \"\"\"\n    Event indicating the broker has rejected an order modification.\n\n    Contains the system's order_id for the order that could not be modified.\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.RejectedOrderCancellation","title":"<code>RejectedOrderCancellation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating the broker has rejected an order cancellation.</p> <p>Contains the system's order_id for the order that could not be cancelled.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass RejectedOrderCancellation(Event):\n    \"\"\"\n    Event indicating the broker has rejected an order cancellation.\n\n    Contains the system's order_id for the order that could not be cancelled.\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.OrderFilled","title":"<code>OrderFilled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating an order has been filled (fully or partially).</p> <p>Contains details about the fill including quantity, price, commission, and the associated order. A unique fill_id is automatically generated if not provided. The broker may optionally provide a broker_fill_id.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderFilled(Event):\n    \"\"\"\n    Event indicating an order has been filled (fully or partially).\n\n    Contains details about the fill including quantity, price, commission, and the\n    associated order. A unique fill_id is automatically generated if not provided.\n    The broker may optionally provide a broker_fill_id.\n    \"\"\"\n\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    broker_fill_id: str | None = None\n    associated_order_id: uuid.UUID\n    symbol: str\n    side: OrderSide\n    quantity_filled: float\n    fill_price: float\n    commission: float\n    exchange: str = \"SIMULATED\"\n</code></pre>"},{"location":"api-reference/core/events/#onesecondtrader.core.events.OrderExpired","title":"<code>OrderExpired</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Event indicating an order has expired without being filled.</p> <p>Contains the system's order_id for the expired order. This typically occurs for time-limited orders that were not filled before their expiration time.</p> Source code in <code>src/onesecondtrader/core/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderExpired(Event):\n    \"\"\"\n    Event indicating an order has expired without being filled.\n\n    Contains the system's order_id for the expired order. This typically occurs for\n    time-limited orders that were not filled before their expiration time.\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/models/","title":"Models","text":"<p>This module provides core domain models used throughout the system.</p> <p>Domain models are enumerations that define the vocabulary and valid values for key concepts in the trading system. These models are used across all components to ensure type safety and consistency when representing domain-specific concepts.</p>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.BarPeriod","title":"<code>BarPeriod</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Time period for aggregating market data into bars.</p> <p>Defines the standard time intervals used for OHLCV bar data. Each bar represents market activity aggregated over the specified period.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class BarPeriod(enum.Enum):\n    \"\"\"\n    Time period for aggregating market data into bars.\n\n    Defines the standard time intervals used for OHLCV bar data.\n    Each bar represents market activity aggregated over the specified period.\n    \"\"\"\n\n    SECOND = 32\n    MINUTE = 33\n    HOUR = 34\n    DAY = 35\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of order to submit to the broker.</p> <p>Defines the execution behavior for an order. Market orders execute immediately at current market price. Limit orders execute only at a specified price or better. Stop orders become market orders when a trigger price is reached. Stop-limit orders become limit orders when a trigger price is reached.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"\n    Type of order to submit to the broker.\n\n    Defines the execution behavior for an order.\n    Market orders execute immediately at current market price.\n    Limit orders execute only at a specified price or better.\n    Stop orders become market orders when a trigger price is reached.\n    Stop-limit orders become limit orders when a trigger price is reached.\n    \"\"\"\n\n    MARKET = enum.auto()\n    LIMIT = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderSide","title":"<code>OrderSide</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Direction of an order or position.</p> <p>Indicates whether an order is buying or selling a security.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderSide(enum.Enum):\n    \"\"\"\n    Direction of an order or position.\n\n    Indicates whether an order is buying or selling a security.\n    \"\"\"\n\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.InputSource","title":"<code>InputSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Source field from bar data to use as input for indicators.</p> <p>Specifies which component of OHLCV bar data should be used when calculating technical indicators. For example, many indicators use CLOSE prices per default, but could also be calculated based on other fields.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class InputSource(enum.Enum):\n    \"\"\"\n    Source field from bar data to use as input for indicators.\n\n    Specifies which component of OHLCV bar data should be used when calculating\n    technical indicators.\n    For example, many indicators use CLOSE prices per default, but could also be\n    calculated based on other fields.\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"}]}