{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Step 1: Install package</p> pippoetry <pre><code>pip install onesecondtrader \n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre> <p>Step 2: Define strategy</p> <pre><code>from onesecondtrader.strategies import StrategyBase\nfrom onesecondtrader.indicators import SimpleMovingAverage\nfrom onesecondtrader.models import OrderType, OrderSide\nfrom onesecondtrader.events import BarReceived\n\n\nclass MySMACrossover(StrategyBase):\n    def setup(self) -&gt; None:\n        self.fast_sma = self.add_indicator(SimpleMovingAverage(period=20))\n        self.slow_sma = self.add_indicator(SimpleMovingAverage(period=100))\n\n    def on_bar(self, event: BarReceived) -&gt; None:\n        if (\n            self.fast_sma[-2] &lt;= self.slow_sma[-2]\n            and self.fast_sma.latest &gt; self.slow_sma.latest\n            and self.position &lt;= 0\n        ):\n            self.submit_order(OrderType.MARKET, OrderSide.BUY, 1.0)\n\n        if (\n            self.fast_sma[-2] &gt;= self.slow_sma[-2]\n            and self.fast_sma.latest &lt; self.slow_sma.latest\n            and self.position &gt;= 0\n        ):\n            self.submit_order(OrderType.MARKET, OrderSide.SELL, 1.0)\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"sql_primer/","title":"SQL Primer","text":"<p>SQL (Structured Query Language) is the language used to interact with databases. This page covers the SQL concepts needed to understand the schema of the securities master database.</p>"},{"location":"sql_primer/#tables","title":"Tables","text":"<p>A table is a collection of related data organized into rows and columns. A table is created by using the <code>CREATE TABLE</code> statement:</p> <pre><code>CREATE TABLE publishers (\n    publisher_id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL UNIQUE,\n    dataset TEXT NOT NULL,\n    venue TEXT\n);\n</code></pre> <p>This creates a table called <code>publishers</code> with four columns. Every column has a data type that specifies what kind of values it can hold. <code>NULL</code> is a special value meaning \"no data\" or \"unknown\". <code>NOT NULL</code> is a constraint that specifies that a column must not contain NULL values.</p>"},{"location":"sql_primer/#primary-keys","title":"Primary Keys","text":"<p>A primary key is a column (or combination of columns) that uniquely identifies each row in a table. No two rows can have the same primary key value, and the primary key cannot be NULL.</p> <pre><code>publisher_id INTEGER PRIMARY KEY\n</code></pre> <p>When a column is declared as <code>INTEGER PRIMARY KEY</code> in SQLite, it becomes an auto-incrementing identifier\u2014if no value is specified during insertion, SQLite automatically assigns the next available number. Primary keys guarantee each row can be individually identified, and SQLite automatically creates an efficient lookup structure for primary key columns.</p>"},{"location":"sql_primer/#foreign-keys","title":"Foreign Keys","text":"<p>A foreign key is a column that references the primary key of another table, creating a relationship between the tables.</p> <pre><code>CREATE TABLE instruments (\n    instrument_id INTEGER PRIMARY KEY,\n    publisher_id INTEGER NOT NULL,\n    ...\n    FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id)\n);\n</code></pre> <p>This declaration means the <code>publisher_id</code> column in the <code>instruments</code> table must contain a value that exists in the <code>publisher_id</code> column of the <code>publishers</code> table. Foreign keys enforce referential integrity\u2014preventing the creation of an instrument that references a non-existent publisher, or the deletion of a publisher that still has instruments associated with it.</p>"},{"location":"sql_primer/#constraints","title":"Constraints","text":"<p>Constraints are rules that limit what data can be stored in a column. <code>NOT NULL</code> means the column must have a value. <code>UNIQUE</code> means no two rows can have the same value in this column. <code>DEFAULT</code> specifies a fallback value if none is provided during insertion. Constraints can also span multiple columns:</p> <pre><code>UNIQUE(publisher_id, raw_symbol)\n</code></pre> <p>This means the combination of publisher_id and raw_symbol must be unique. The same symbol (like 'ESH5') can appear multiple times in the table, as long as each occurrence is from a different publisher.</p>"},{"location":"sql_primer/#indexes","title":"Indexes","text":"<p>An index is a data structure that speeds up searches on specific columns\u2014like the index at the back of a book that allows jumping directly to a topic instead of reading every page.</p> <pre><code>CREATE INDEX idx_instruments_symbol ON instruments(raw_symbol);\n</code></pre> <p>This creates an index named <code>idx_instruments_symbol</code> on the <code>raw_symbol</code> column of the <code>instruments</code> table. When searching for instruments by symbol, the database can find them quickly without scanning every row.</p>"},{"location":"sql_primer/#normalization","title":"Normalization","text":"<p>The schema uses separate <code>publishers</code> and <code>instruments</code> tables rather than storing publisher names directly in each instrument row. This design principle is called normalization. Without it, publisher information would be duplicated in every row, wasting storage, creating update anomalies (changing a dataset name requires updating every row), and risking inconsistency from typos. With normalization, publisher information is stored once, and each instrument stores only a reference (the publisher_id) to the publisher.</p>"},{"location":"sql_primer/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<p>The relationship between publishers and instruments is called one-to-many: one publisher can have many instruments, but each instrument belongs to exactly one publisher. This is implemented through the foreign key: <code>instruments.publisher_id</code> references <code>publishers.publisher_id</code>. Similarly, the relationship between instruments and OHLCV bars is one-to-many: one instrument can have millions of bars, but each bar belongs to exactly one instrument.</p> <pre><code>publishers (1) \u2500\u2500\u2500\u2500\u2500\u2500&lt; instruments (many) \u2500\u2500\u2500\u2500\u2500\u2500&lt; ohlcv (many)\n</code></pre>"},{"location":"sql_primer/#composite-primary-keys","title":"Composite Primary Keys","text":"<p>Sometimes a single column isn't enough to uniquely identify a row. The <code>ohlcv</code> table uses a composite primary key\u2014a primary key made up of multiple columns:</p> <pre><code>PRIMARY KEY (instrument_id, rtype, ts_event)\n</code></pre> <p>This means the combination of these three values must be unique\u2014multiple bars for the same instrument with different timestamps, multiple bars at the same timestamp for different instruments, and multiple bar types for the same instrument and time are all allowed, but two rows with the same instrument_id, rtype, AND ts_event would be a duplicate bar.</p>"},{"location":"sql_primer/#b-trees","title":"B-trees","text":"<p>A B-tree (balanced tree) is the data structure that databases use to organize data for fast lookups. It works like searching a phone book\u2014instead of reading every name from page 1, the search opens to the middle, determines which half contains the target, and repeats until the entry is found. Each step eliminates half the remaining possibilities. A B-tree organizes data into a tree structure with a root node at the top, branch nodes that guide the search, and leaf nodes containing the actual data. Finding one row among a billion takes the same number of steps as finding one among a thousand.</p>"},{"location":"sql_primer/#how-indexes-work","title":"How Indexes Work","text":"<p>When a table is created with a primary key, SQLite automatically creates a B-tree index for that key. Additional indexes created with <code>CREATE INDEX</code> are additional B-trees. Each index stores the indexed column value(s) and a pointer to the full row. When searching by an indexed column, the database searches the index B-tree (fast\u2014logarithmic time) and follows the pointer to retrieve the full row. Without an index, the database must perform a full table scan\u2014reading every row to find matches.</p>"},{"location":"sql_primer/#the-leftmost-prefix-rule","title":"The Leftmost Prefix Rule","text":"<p>For composite indexes (indexes on multiple columns), the index can only be used efficiently if the query filters on a leftmost prefix of the indexed columns. The <code>ohlcv</code> table has a primary key of <code>(instrument_id, rtype, ts_event)</code>, creating a B-tree sorted first by instrument_id, then by rtype within each instrument, then by ts_event within each rtype. Queries filtering on <code>instrument_id</code> alone, or <code>instrument_id AND rtype</code>, or all three columns can use this index efficiently. However, queries filtering only on <code>ts_event</code> or only on <code>rtype</code> cannot use the primary key index because they skip the leftmost column(s)\u2014the B-tree is sorted by instrument_id first. This is why the schema includes a separate index on <code>ts_event</code>:</p> <pre><code>CREATE INDEX idx_ohlcv_ts ON ohlcv(ts_event);\n</code></pre> <p>This creates a second B-tree sorted by timestamp, enabling fast time-based queries across all instruments.</p>"},{"location":"sql_primer/#without-rowid-tables","title":"WITHOUT ROWID Tables","text":"<p>In a normal SQLite table, data is stored in a B-tree organized by an internal rowid (a hidden auto-incrementing integer). If a primary key is defined, SQLite creates a second B-tree for that key, which stores the primary key values and their corresponding rowids. Looking up a row by primary key requires searching the primary key B-tree to find the rowid, then searching the rowid B-tree to find the actual data. This double lookup is fine for most tables, but for a table with billions of rows accessed primarily by its composite key (like <code>ohlcv</code>), it's wasteful.</p> <p>The <code>WITHOUT ROWID</code> optimization changes this:</p> <pre><code>CREATE TABLE ohlcv (\n    ...\n    PRIMARY KEY (instrument_id, rtype, ts_event)\n) WITHOUT ROWID;\n</code></pre> <p>Now the table data is stored directly in the primary key B-tree. There's no separate rowid B-tree, no double lookup\u2014resulting in ~50% storage reduction (primary key values aren't stored twice), faster lookups (one B-tree search instead of two), and better locality (data for the same instrument is physically adjacent on disk). The tradeoff is that WITHOUT ROWID tables can't use some SQLite optimizations that depend on rowids, but for time-series data accessed by composite key, this is the right choice.</p>"},{"location":"sql_primer/#index-tradeoffs","title":"Index Tradeoffs","text":"<p>Indexes aren't free\u2014each index consumes storage, slows down writes (every INSERT must update all indexes), and requires maintenance to stay in sync with data. The schema includes only two additional indexes beyond the primary keys: <code>idx_ohlcv_ts</code> on <code>ohlcv(ts_event)</code> to enable time-range queries across instruments, and <code>idx_instruments_symbol</code> on <code>instruments(raw_symbol)</code> to enable symbol lookups. Each was added because the query pattern it supports is common enough to justify the overhead.</p>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Connectors </p> <p> View <code>connectors</code> package API</p> </li> <li> <p>Core </p> <p> View <code>core</code> package API</p> </li> <li> <p>Dashboard </p> <p> View <code>dashboard</code> package API</p> </li> <li> <p>Secmaster </p> <p> View <code>secmaster</code> package API</p> </li> </ul>"},{"location":"api-reference/secmaster/utils/","title":"Utils","text":""},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.init_secmaster","title":"<code>init_secmaster(db_path)</code>","text":"<p>Initialize a new secmaster database at the specified path.</p> <p>Creates the database file with the schema defined in schema.sql (publishers, instruments, and ohlcv tables) but does not populate any data.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>Path where the database file will be created.</p> required <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If a database already exists at the path.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def init_secmaster(db_path: pathlib.Path) -&gt; None:\n    \"\"\"Initialize a new secmaster database at the specified path.\n\n    Creates the database file with the schema defined in schema.sql (publishers, instruments,\n    and ohlcv tables) but does not populate any data.\n\n    Args:\n        db_path: Path where the database file will be created.\n\n    Raises:\n        FileExistsError: If a database already exists at the path.\n    \"\"\"\n    if db_path.exists():\n        raise FileExistsError(f\"Database already exists: {db_path}\")\n    db_path.parent.mkdir(parents=True, exist_ok=True)\n    schema_path = pathlib.Path(__file__).parent / \"schema.sql\"\n    conn = sqlite3.connect(str(db_path))\n    conn.executescript(schema_path.read_text())\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"documentation/overview/","title":"Read the Docs","text":""},{"location":"documentation/overview/#introduction","title":"Introduction","text":"<p>At its core, the OneSecondTrader package enables users to implement a trading strategy and execute it by connecting two interchangeable components: a data feed and a broker. Both components may operate either in simulated mode\u2014using historical market data and a simulated execution layer\u2014or in live or paper-trading mode via a live data feed and a real broker API.</p> <p>A central design principle of the system is that backtesting and live trading follow the same execution flow from market data ingestion to order handling, while differing only in the concrete implementations of the data feed and broker. As a result, transitioning a strategy from historical simulation to live deployment requires no changes to the strategy code itself.</p> <p>This architectural decision ensures that any discrepancy between backtested and live performance can be attributed exclusively to the fidelity of the simulations.  On the data side, this concerns how accurately the imitation of a live datafeed from historical records approximates real-time market behavior. On the execution side, it concerns how well the simulated broker models real-world constraints such as slippage, partial fills, et cetera. </p> <p>By strictly isolating these sources of divergence, OneSecondTrader provides a controlled and transparent environment for strategy development, validation, and deployment, without the risk of structural mismatches between research and production.</p>"},{"location":"documentation/overview/#package-structure","title":"Package Structure","text":"<p>The OneSecondTrader library is organized as a top-level Python package composed of four sub-packages (<code>core</code>, <code>connectors</code>, <code>secmaster</code>, and <code>dashboard</code>), each encapsulating an architecturally distinct set of responsibilities.</p> <ul> <li> <p><code>core</code>: Provides the skeleton of an event-driven trading system. It does include the definition of a set of events which are used to communicate between the different system components, an event bus for routing events to the concerned components, as well as base classes for strategies, brokers, and indicators. It does not include any datafeed component or any actual broker implementation, which are provided by the <code>connectors</code> package to isolate external dependencies from the system's core logic.</p> </li> <li> <p><code>connectors</code> Provides actual implementations of brokers and datafeeds. This includes both the (internally) simulated broker and datafeed as well as connectors to actual live brokers and datafeeds APIs. This makes it possible for the core of the system to stay the same, while the options for connecting to actual live brokers and datafeeds can be expanded as needed.</p> </li> <li> <p><code>secmaster</code>: Povides the skeleton for a securities master database as well as some utilities to actually ingest data from various sources into this database. Simulated datafeeds (see <code>connectors</code> package) will use it as a source of market data.</p> </li> <li> <p><code>dashboard</code>: Provides a web-based dashboard to view and control the runs of the trading system. A run refers to a single execution of the trading system, and is associated with a concrete instance of a strategy (or instances of multiple strategies), as well as the connected broker and datafeed.  The backend of the dashboard is organized around a database that persistently records all run-related activity on a per-run basis. The frontend is implemented as a web application that presents this information in a form suitable for both inspection  and operational decision-making. Backtests differ from live runs only in temporal behavior. Backtests complete quickly, as historical data is replayed at maximum speed, whereas live runs naturally unfold in real time.</p> </li> </ul>"},{"location":"documentation/overview/#system-core-core-package","title":"System Core (<code>core</code> package)","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"},{"location":"documentation/overview/#broker-and-datafeed-connectors-connectors-package","title":"Broker and Datafeed Connectors (<code>connectors</code> package)","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"},{"location":"documentation/overview/#securities-master-database-secmaster-package","title":"Securities Master Database (<code>secmaster</code> package)","text":""},{"location":"documentation/overview/#introduction_1","title":"Introduction","text":"<p>The securities master database stores market data for use by the simulated datafeed when replaying historical data during backtesting. It is implemented as an SQLite database and populated via utilities provided by the <code>secmaster</code> package. SQLite is an embedded database engine that stores the entire database in a single file and requires no server or external configuration, making it well suited for market data storage due to its simplicity, portability, read performance, and reliability.</p> <p>For background on SQL and database concepts used in this schema, see the SQL Primer.</p>"},{"location":"documentation/overview/#schema-design-decisions","title":"Schema Design Decisions","text":"<ul> <li>Prices as integers: Floating-point numbers can't represent all decimal values exactly, so prices are stored as integers using fixed-point arithmetic with a scale factor of \\(10^9\\)\u2014guaranteeing exact representation and fast integer arithmetic.</li> <li>Nanosecond timestamps: Timestamps are stored as integers representing nanoseconds since the Unix epoch, preserving microsecond/nanosecond ordering information, avoiding conversion errors, and matching data vendor formats like Databento.</li> <li>Primary key order: The <code>ohlcv</code> primary key <code>(instrument_id, rtype, ts_event)</code> ensures all bars for the same instrument are contiguous on disk, enabling the common query pattern \"bars for instrument X, timeframe Y, between time A and B\" to become a fast sequential read.</li> </ul>"},{"location":"documentation/overview/#dashboard-dashboard-package","title":"Dashboard (<code>dashboard</code> package)","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"}]}