{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"LocalColab <pre><code>pip install onesecondtrader\npoetry add onesecondtrader # If using Poetry\n</code></pre> <pre><code>from onesecondtrader.messaging import eventbus, events\nfrom onesecondtrader.core import models\n</code></pre> <pre><code>!pip install onesecondtrader\n</code></pre> <pre><code>from onesecondtrader.messaging import eventbus, events\nfrom onesecondtrader.core import models\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Core </p> <p>Contains: <code>models.py</code></p> <p> View <code>core/</code> package API</p> </li> <li> <p>Datafeeds </p> <p>Contains: <code>base_datafeed.py</code>, <code>csv_datafeed.py</code></p> <p> View <code>datafeeds/</code> package API</p> </li> <li> <p>Indicators </p> <p>Contains: <code>base_indicator.py</code>, <code>moving_averages.py</code></p> <p> View <code>indicators/</code> package API</p> </li> <li> <p>Messaging </p> <p>Contains: <code>eventbus.py</code>, <code>events.py</code></p> <p> View <code>messaging/</code> package API</p> </li> <li> <p>Monitoring </p> <p>Contains: <code>console.py</code></p> <p> View <code>monitoring/</code> package API</p> </li> </ul>"},{"location":"api-reference/core/models/","title":"Models","text":""},{"location":"api-reference/core/models/#onesecondtrader.core.models.BrokerType","title":"<code>BrokerType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for broker types.</p> <p>Attributes:</p> Enum Value Description <code>LOCAL_SIMULATED</code> <code>enum.auto()</code> Locally simulated broker <code>IB_SIMULATED</code> <code>enum.auto()</code> Interactive Brokers paper trading account <code>IB_LIVE</code> <code>enum.auto()</code> Interactive Brokers live trading account <code>MT5</code> <code>enum.auto()</code> MetaTrader 5 Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class BrokerType(enum.Enum):\n    \"\"\"\n    Enum for broker types.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `LOCAL_SIMULATED` | `enum.auto()` | Locally simulated broker |\n    | `IB_SIMULATED` | `enum.auto()` | Interactive Brokers paper trading account |\n    | `IB_LIVE` | `enum.auto()` | Interactive Brokers live trading account |\n    | `MT5` | `enum.auto()` | MetaTrader 5 |\n    \"\"\"\n\n    LOCAL_SIMULATED = enum.auto()\n    IB_SIMULATED = enum.auto()\n    IB_LIVE = enum.auto()\n    MT5 = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.Bar","title":"<code>Bar</code>  <code>dataclass</code>","text":"<p>Class for representing a OHLC(V) bar of market data.</p> <p>Attributes:</p> Name Type Description <code>open</code> <code>float</code> <p>Open price</p> <code>high</code> <code>float</code> <p>High price</p> <code>low</code> <code>float</code> <p>Low price</p> <code>close</code> <code>float</code> <p>Close price</p> <code>volume</code> <code>int | None</code> <p>Volume</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Bar:\n    \"\"\"\n    Class for representing a OHLC(V) bar of market data.\n\n    Attributes:\n        open (float): Open price\n        high (float): High price\n        low (float): Low price\n        close (float): Close price\n        volume (int | None): Volume\n    \"\"\"\n\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.Side","title":"<code>Side</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order sides.</p> Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class Side(enum.Enum):\n    \"\"\"\n    Enum for order sides.\n    \"\"\"\n\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.TimeInForce","title":"<code>TimeInForce</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Order time-in-force specifications.</p> <p>Attributes:</p> Enum Value Description <code>DAY</code> <code>enum.auto()</code> Valid until end of trading day <code>FOK</code> <code>enum.auto()</code> Fill entire order immediately or cancel (Fill-or-Kill) <code>GTC</code> <code>enum.auto()</code> Active until explicitly cancelled (Good-Till-Cancelled) <code>GTD</code> <code>enum.auto()</code> Active until specified date (Good-Till-Date) <code>IOC</code> <code>enum.auto()</code> Execute available quantity immediately, cancel rest (Immediate-or-Cancel) Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class TimeInForce(enum.Enum):\n    \"\"\"\n    Order time-in-force specifications.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `DAY` | `enum.auto()` | Valid until end of trading day |\n    | `FOK` | `enum.auto()` | Fill entire order immediately or cancel (Fill-or-Kill) |\n    | `GTC` | `enum.auto()` | Active until explicitly cancelled (Good-Till-Cancelled) |\n    | `GTD` | `enum.auto()` | Active until specified date (Good-Till-Date) |\n    | `IOC` | `enum.auto()` | Execute available quantity immediately, cancel rest (Immediate-or-Cancel) |\n    \"\"\"\n\n    DAY = enum.auto()\n    FOK = enum.auto()\n    GTC = enum.auto()\n    GTD = enum.auto()\n    IOC = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order types.</p> <p>Attributes:</p> Enum Value Description <code>MARKET</code> <code>enum.auto()</code> Market order <code>LIMIT</code> <code>enum.auto()</code> Limit order <code>STOP</code> <code>enum.auto()</code> Stop order <code>STOP_LIMIT</code> <code>enum.auto()</code> Stop-limit order Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"\n    Enum for order types.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `MARKET` | `enum.auto()` | Market order |\n    | `LIMIT` | `enum.auto()` | Limit order |\n    | `STOP` | `enum.auto()` | Stop order |\n    | `STOP_LIMIT` | `enum.auto()` | Stop-limit order |\n    \"\"\"\n\n    MARKET = enum.auto()\n    LIMIT = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderLifecycleState","title":"<code>OrderLifecycleState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order lifecycle states.</p> <p>Attributes:</p> Enum Value Description <code>PENDING</code> <code>enum.auto()</code> Order has been submitted, but not yet acknowledged by the broker <code>OPEN</code> <code>enum.auto()</code> Order has been acknowledged by the broker, but not yet filled or cancelled <code>FILLED</code> <code>enum.auto()</code> Order has been filled <code>CANCELLED</code> <code>enum.auto()</code> Order has been cancelled Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderLifecycleState(enum.Enum):\n    \"\"\"\n    Enum for order lifecycle states.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `PENDING` | `enum.auto()` | Order has been submitted, but not yet acknowledged by the broker |\n    | `OPEN` | `enum.auto()` | Order has been acknowledged by the broker, but not yet filled or cancelled |\n    | `FILLED` | `enum.auto()` | Order has been filled |\n    | `CANCELLED` | `enum.auto()` | Order has been cancelled |\n    \"\"\"\n\n    PENDING = enum.auto()\n    OPEN = enum.auto()\n    PARTIALLY_FILLED = enum.auto()\n    FILLED = enum.auto()\n    CANCELLED = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.OrderRejectionReason","title":"<code>OrderRejectionReason</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for order rejection reasons.</p> <p>Attributes:</p> Enum Value Description <code>UNKNOWN</code> <code>enum.auto()</code> Unknown reason <code>NEGATIVE_QUANTITY</code> <code>enum.auto()</code> Negative quantity Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class OrderRejectionReason(enum.Enum):\n    \"\"\"\n    Enum for order rejection reasons.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `UNKNOWN` | `enum.auto()` | Unknown reason |\n    | `NEGATIVE_QUANTITY` | `enum.auto()` | Negative quantity |\n    \"\"\"\n\n    UNKNOWN = enum.auto()\n    NEGATIVE_QUANTITY = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.RecordType","title":"<code>RecordType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for Databento record types.</p> <p>Attributes:</p> Enum Value Description <code>OHLCV_1S</code> <code>32</code> 1-second bars <code>OHLCV_1M</code> <code>33</code> 1-minute bars <code>OHLCV_1H</code> <code>34</code> 1-hour bars <code>OHLCV_1D</code> <code>35</code> 1-day bars Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class RecordType(enum.Enum):\n    \"\"\"\n    Enum for Databento record types.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `OHLCV_1S` | `32` | 1-second bars |\n    | `OHLCV_1M` | `33` | 1-minute bars |\n    | `OHLCV_1H` | `34` | 1-hour bars |\n    | `OHLCV_1D` | `35` | 1-day bars |\n    \"\"\"\n\n    OHLCV_1S = 32\n    OHLCV_1M = 33\n    OHLCV_1H = 34\n    OHLCV_1D = 35\n\n    @classmethod\n    def to_string(cls, rtype: int) -&gt; str:\n        match rtype:\n            case cls.OHLCV_1S.value:\n                return \"1-second bars\"\n            case cls.OHLCV_1M.value:\n                return \"1-minute bars\"\n            case cls.OHLCV_1H.value:\n                return \"1-hour bars\"\n            case cls.OHLCV_1D.value:\n                return \"daily bars\"\n            case _:\n                return f\"unknown ({rtype})\"\n</code></pre>"},{"location":"api-reference/core/models/#onesecondtrader.core.models.XMAMode","title":"<code>XMAMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for moving average modes.</p> <p>Attributes:</p> Enum Value Description <code>OPEN</code> <code>enum.auto()</code> Open price <code>HIGH</code> <code>enum.auto()</code> High price <code>LOW</code> <code>enum.auto()</code> Low price <code>CLOSE</code> <code>enum.auto()</code> Close price <code>TYPICAL_PRICE</code> <code>enum.auto()</code> Typical price ((H+ L + C) / 3) <code>WEIGHTED_CLOSE</code> <code>enum.auto()</code> Weighted close price ((H + L + 2*C) / 4) Source code in <code>src/onesecondtrader/core/models.py</code> <pre><code>class XMAMode(enum.Enum):\n    \"\"\"\n    Enum for moving average modes.\n\n    **Attributes:**\n\n    | Enum | Value | Description |\n    |------|-------|-------------|\n    | `OPEN` | `enum.auto()` | Open price |\n    | `HIGH` | `enum.auto()` | High price |\n    | `LOW` | `enum.auto()` | Low price |\n    | `CLOSE` | `enum.auto()` | Close price |\n    | `TYPICAL_PRICE` | `enum.auto()` | Typical price ((H+ L + C) / 3) |\n    | `WEIGHTED_CLOSE` | `enum.auto()` | Weighted close price ((H + L + 2*C) / 4) |\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    TYPICAL_PRICE = enum.auto()\n    WEIGHTED_CLOSE = enum.auto()\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/","title":"Base Datafeed","text":"<p>This module provides the base class for all datafeeds.</p>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed","title":"<code>BaseDatafeed</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all datafeeds.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>class BaseDatafeed(abc.ABC):\n    \"\"\"\n    Base class for all datafeeds.\n    \"\"\"\n\n    def __init__(self, event_bus: messaging.EventBus):\n        \"\"\"\n        Initialize the datafeed with an event bus.\n\n        Args:\n            event_bus (messaging.EventBus): Event bus to publish market data events to.\n        \"\"\"\n        self.event_bus: messaging.EventBus = event_bus\n\n    @abc.abstractmethod\n    def connect(self):\n        \"\"\"\n        Connect to the datafeed.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def watch(self, symbols: list[tuple[str, models.RecordType]]):\n        \"\"\"\n        Start watching symbols.\n\n        Args:\n            symbols (list[tuple[str, models.TimeFrame]]): List of symbols to watch with\n                their respective timeframes.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def unwatch(self, symbols: list[tuple[str, models.RecordType]]):\n        \"\"\"\n        Stop watching symbols.\n\n        Args:\n            symbols (list[tuple[str, models.TimeFrame]]): List of symbols to stop\n                watching with their respective timeframes.\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def disconnect(self):\n        \"\"\"\n        Disconnect from the datafeed.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.__init__","title":"<code>__init__(event_bus)</code>","text":"<p>Initialize the datafeed with an event bus.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus to publish market data events to.</p> required Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus):\n    \"\"\"\n    Initialize the datafeed with an event bus.\n\n    Args:\n        event_bus (messaging.EventBus): Event bus to publish market data events to.\n    \"\"\"\n    self.event_bus: messaging.EventBus = event_bus\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Connect to the datafeed.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef connect(self):\n    \"\"\"\n    Connect to the datafeed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.watch","title":"<code>watch(symbols)</code>  <code>abstractmethod</code>","text":"<p>Start watching symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of symbols to watch with their respective timeframes.</p> required Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef watch(self, symbols: list[tuple[str, models.RecordType]]):\n    \"\"\"\n    Start watching symbols.\n\n    Args:\n        symbols (list[tuple[str, models.TimeFrame]]): List of symbols to watch with\n            their respective timeframes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.unwatch","title":"<code>unwatch(symbols)</code>  <code>abstractmethod</code>","text":"<p>Stop watching symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, TimeFrame]]</code> <p>List of symbols to stop watching with their respective timeframes.</p> required Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef unwatch(self, symbols: list[tuple[str, models.RecordType]]):\n    \"\"\"\n    Stop watching symbols.\n\n    Args:\n        symbols (list[tuple[str, models.TimeFrame]]): List of symbols to stop\n            watching with their respective timeframes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/base_datafeed/#onesecondtrader.datafeeds.base_datafeed.BaseDatafeed.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Disconnect from the datafeed.</p> Source code in <code>src/onesecondtrader/datafeeds/base_datafeed.py</code> <pre><code>@abc.abstractmethod\ndef disconnect(self):\n    \"\"\"\n    Disconnect from the datafeed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/","title":"CSV Datafeed","text":"<p>This module provides a CSV-based simulated live datafeed.</p>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed","title":"<code>CSVDatafeed</code>","text":"<p>               Bases: <code>BaseDatafeed</code></p> <p>CSV-based simulated live datafeed.</p> <p>Only one instance of any BaseDatafeed subclass can exist at a time.</p> Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>class CSVDatafeed(base_datafeed.BaseDatafeed):\n    \"\"\"\n    CSV-based simulated live datafeed.\n\n    Only one instance of any BaseDatafeed subclass can exist at a time.\n    \"\"\"\n\n    _instance = None\n\n    def __init__(\n        self,\n        event_bus: eventbus.EventBus,\n        csv_path: str | Path | None = None,\n        streaming_delay: float | None = None,\n    ):\n        \"\"\"\n        Initialize CSV datafeed.\n\n        Args:\n            event_bus: Event bus used to publish market data events.\n            csv_path: Optional path to CSV file. Overrides CSV_PATH env var.\n            streaming_delay: Optional delay in seconds between processing rows.\n                Overrides CSV_STREAMING_DELAY env var.\n\n        Attributes:\n            self.csv_path (Path | None): Path to CSV file.\n            self.data_iterator (TextFileReader | None): Iterator for reading CSV.\n            self._watched_symbols (set[tuple[str, models.RecordType]]): Set of\n                symbols and record types currently being watched.\n            self._streaming_thread (threading.Thread | None): Background thread\n                for streaming data.\n            self._symbols_lock (threading.Lock): Lock to protect _watched_symbols\n                from concurrent access.\n            self._streaming_delay (float): Delay in seconds between processing\n                CSV rows (from CSV_STREAMING_DELAY env var, set in connect()).\n            self._init_csv_path (str | Path | None): CSV path provided during\n                initialization.\n            self._init_streaming_delay (float | None): Streaming delay provided\n                during initialization.\n        \"\"\"\n        if CSVDatafeed._instance is not None:\n            console.logger.warning(\n                f\"Only one BaseDatafeed instance allowed. \"\n                f\"Current: {type(CSVDatafeed._instance).__name__}. \"\n                f\"Initialization failed.\"\n            )\n            return\n\n        super().__init__(event_bus)\n        CSVDatafeed._instance = self\n\n        self.csv_path: Path | None = None\n        self.data_iterator: TextFileReader | None = None\n        self._watched_symbols: set[tuple[str, models.RecordType]] = set()\n        self._stop_event = threading.Event()\n        self._streaming_thread: threading.Thread | None = None\n        self._symbols_lock: threading.Lock = threading.Lock()\n        self._streaming_delay: float = 0.0\n\n        self._init_csv_path: str | Path | None = csv_path\n        self._init_streaming_delay: float | None = streaming_delay\n\n    def connect(self):\n        \"\"\"\n        Connect to CSV file specified in .env file (CSV_PATH variable) and\n        create data iterator.\n        \"\"\"\n        load_dotenv()\n\n        if self._init_csv_path is not None:\n            csv_path_str = str(self._init_csv_path)\n            console.logger.info(f\"Using CSV path from initialization: {csv_path_str}\")\n        else:\n            csv_path_str = os.getenv(\"CSV_PATH\")\n            if not csv_path_str:\n                console.logger.error(\n                    \"CSV_PATH not found in environment variables and not \"\n                    \"provided in __init__. Either set CSV_PATH in .env file \"\n                    \"or pass csv_path to CSVDatafeed()\"\n                )\n                return False\n\n        if self._init_streaming_delay is not None:\n            self._streaming_delay = self._init_streaming_delay\n            if self._streaming_delay &lt; 0:\n                console.logger.warning(\n                    f\"Streaming delay cannot be negative \"\n                    f\"({self._streaming_delay}), using default 0.0\"\n                )\n                self._streaming_delay = 0.0\n            else:\n                console.logger.info(\n                    f\"CSV streaming delay set from initialization: \"\n                    f\"{self._streaming_delay} seconds\"\n                )\n        else:\n            streaming_delay_str = os.getenv(\"CSV_STREAMING_DELAY\", \"0.0\")\n            try:\n                self._streaming_delay = float(streaming_delay_str)\n                if self._streaming_delay &lt; 0:\n                    console.logger.warning(\n                        f\"CSV_STREAMING_DELAY cannot be negative \"\n                        f\"({self._streaming_delay}), using default 0.0\"\n                    )\n                    self._streaming_delay = 0.0\n                else:\n                    console.logger.info(\n                        f\"CSV streaming delay set from environment: \"\n                        f\"{self._streaming_delay} seconds\"\n                    )\n            except ValueError:\n                console.logger.error(\n                    f\"Invalid CSV_STREAMING_DELAY value \"\n                    f\"'{streaming_delay_str}', must be a number. \"\n                    f\"Using default 0.0\"\n                )\n                self._streaming_delay = 0.0\n\n        self.csv_path = Path(csv_path_str)\n\n        try:\n            self.data_iterator = pd.read_csv(\n                self.csv_path,\n                usecols=[\n                    \"ts_event\",\n                    \"rtype\",\n                    \"open\",\n                    \"high\",\n                    \"low\",\n                    \"close\",\n                    \"volume\",\n                    \"symbol\",\n                ],\n                dtype={\n                    \"ts_event\": int,\n                    \"rtype\": int,\n                    \"open\": int,\n                    \"high\": int,\n                    \"low\": int,\n                    \"close\": int,\n                    \"volume\": int,\n                    \"symbol\": str,\n                },\n                iterator=True,\n                chunksize=1,\n            )\n            console.logger.info(f\"CSV datafeed connected to: {self.csv_path}\")\n            self._stop_event.clear()\n            return True\n\n        except Exception as e:\n            console.logger.error(f\"Failed to connect to CSV file {self.csv_path}: {e}\")\n            return False\n\n    def watch(self, symbols):\n        \"\"\"\n        Start streaming data for specified symbols.\n        Can be called multiple times to add more symbols.\n\n        Args:\n            symbols (list[tuple[str, models.RecordType]]): List of symbols to\n                watch with their respective record types.\n        \"\"\"\n        if not self.data_iterator:\n            console.logger.error(\"Not connected. Call connect() first.\")\n            return\n\n        with self._symbols_lock:\n            new_symbols = set(symbols) - self._watched_symbols\n            already_watched = set(symbols) &amp; self._watched_symbols\n\n            self._watched_symbols.update(new_symbols)\n\n            if new_symbols:\n                console.logger.info(f\"Added new symbols: {new_symbols}\")\n            if already_watched:\n                console.logger.info(f\"Already watching: {already_watched}\")\n            console.logger.info(\n                f\"Currently watching: {len(self._watched_symbols)} symbols\"\n            )\n\n        if self._streaming_thread is None or not self._streaming_thread.is_alive():\n            self._streaming_thread = threading.Thread(\n                target=self._stream, name=\"CSVDatafeedStreaming\", daemon=True\n            )\n            self._streaming_thread.start()\n            console.logger.info(\"Started CSV streaming thread\")\n\n    def _stream(self):\n        \"\"\"Internal method that runs in background thread to stream CSV data.\"\"\"\n        console.logger.info(\"CSV streaming thread started\")\n\n        should_delay = self._streaming_delay &gt; 0\n        delay_time = self._streaming_delay\n\n        while not self._stop_event.is_set():\n            try:\n                chunk = next(self.data_iterator)\n                row = chunk.iloc[0]\n\n                symbol = row[\"symbol\"]\n                rtype = row[\"rtype\"]\n\n                with self._symbols_lock:\n                    symbol_key = (symbol, models.RecordType(rtype))\n                    if symbol_key not in self._watched_symbols:\n                        continue\n\n                bar_event = events.Market.IncomingBar(\n                    ts_event=pd.Timestamp(row[\"ts_event\"], unit=\"ns\", tz=\"UTC\"),\n                    symbol=symbol,\n                    bar=models.Bar(\n                        open=row[\"open\"] / 1e9,\n                        high=row[\"high\"] / 1e9,\n                        low=row[\"low\"] / 1e9,\n                        close=row[\"close\"] / 1e9,\n                        volume=int(row[\"volume\"]),\n                    ),\n                )\n\n                self.event_bus.publish(bar_event)\n\n                if should_delay:\n                    time.sleep(delay_time)\n\n            except StopIteration:\n                console.logger.info(\"CSV datafeed reached end of file\")\n                break\n            except ValueError as e:\n                console.logger.warning(f\"Invalid rtype {row['rtype']} in CSV data: {e}\")\n                continue\n            except Exception as e:\n                console.logger.error(f\"CSV datafeed error reading data: {e}\")\n                break\n\n        console.logger.info(\"CSV streaming thread stopped\")\n\n    def unwatch(self, symbols):\n        \"\"\"\n        Stop watching specific symbols.\n\n        Args:\n            symbols (list[tuple[str, models.RecordType]]): List of symbols to\n                stop watching.\n        \"\"\"\n        with self._symbols_lock:\n            for symbol in symbols:\n                self._watched_symbols.discard(symbol)\n\n            console.logger.info(f\"Stopped watching symbols: {symbols}\")\n            console.logger.info(f\"Still watching: {self._watched_symbols}\")\n\n    def disconnect(self):\n        \"\"\"\n        Disconnect from CSV datafeed.\n        \"\"\"\n        self._stop_event.set()\n\n        if self._streaming_thread and self._streaming_thread.is_alive():\n            console.logger.info(\"Waiting for streaming thread to stop...\")\n            self._streaming_thread.join(timeout=5.0)\n            if self._streaming_thread.is_alive():\n                console.logger.warning(\"Streaming thread did not stop within timeout\")\n\n        with self._symbols_lock:\n            self._watched_symbols.clear()\n\n        if self.data_iterator is not None:\n            try:\n                self.data_iterator.close()\n                console.logger.info(\"CSV iterator closed successfully\")\n            except Exception as e:\n                console.logger.warning(f\"Error closing CSV iterator: {e}\")\n            finally:\n                self.data_iterator = None\n\n        self.csv_path = None\n        self._streaming_thread = None\n\n        CSVDatafeed._instance = None\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed.__init__","title":"<code>__init__(event_bus, csv_path=None, streaming_delay=None)</code>","text":"<p>Initialize CSV datafeed.</p> <p>Parameters:</p> Name Type Description Default <code>event_bus</code> <code>EventBus</code> <p>Event bus used to publish market data events.</p> required <code>csv_path</code> <code>str | Path | None</code> <p>Optional path to CSV file. Overrides CSV_PATH env var.</p> <code>None</code> <code>streaming_delay</code> <code>float | None</code> <p>Optional delay in seconds between processing rows. Overrides CSV_STREAMING_DELAY env var.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>self.csv_path</code> <code>Path | None</code> <p>Path to CSV file.</p> <code>self.data_iterator</code> <code>TextFileReader | None</code> <p>Iterator for reading CSV.</p> <code>self._watched_symbols</code> <code>set[tuple[str, RecordType]]</code> <p>Set of symbols and record types currently being watched.</p> <code>self._streaming_thread</code> <code>Thread | None</code> <p>Background thread for streaming data.</p> <code>self._symbols_lock</code> <code>Lock</code> <p>Lock to protect _watched_symbols from concurrent access.</p> <code>self._streaming_delay</code> <code>float</code> <p>Delay in seconds between processing CSV rows (from CSV_STREAMING_DELAY env var, set in connect()).</p> <code>self._init_csv_path</code> <code>str | Path | None</code> <p>CSV path provided during initialization.</p> <code>self._init_streaming_delay</code> <code>float | None</code> <p>Streaming delay provided during initialization.</p> Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def __init__(\n    self,\n    event_bus: eventbus.EventBus,\n    csv_path: str | Path | None = None,\n    streaming_delay: float | None = None,\n):\n    \"\"\"\n    Initialize CSV datafeed.\n\n    Args:\n        event_bus: Event bus used to publish market data events.\n        csv_path: Optional path to CSV file. Overrides CSV_PATH env var.\n        streaming_delay: Optional delay in seconds between processing rows.\n            Overrides CSV_STREAMING_DELAY env var.\n\n    Attributes:\n        self.csv_path (Path | None): Path to CSV file.\n        self.data_iterator (TextFileReader | None): Iterator for reading CSV.\n        self._watched_symbols (set[tuple[str, models.RecordType]]): Set of\n            symbols and record types currently being watched.\n        self._streaming_thread (threading.Thread | None): Background thread\n            for streaming data.\n        self._symbols_lock (threading.Lock): Lock to protect _watched_symbols\n            from concurrent access.\n        self._streaming_delay (float): Delay in seconds between processing\n            CSV rows (from CSV_STREAMING_DELAY env var, set in connect()).\n        self._init_csv_path (str | Path | None): CSV path provided during\n            initialization.\n        self._init_streaming_delay (float | None): Streaming delay provided\n            during initialization.\n    \"\"\"\n    if CSVDatafeed._instance is not None:\n        console.logger.warning(\n            f\"Only one BaseDatafeed instance allowed. \"\n            f\"Current: {type(CSVDatafeed._instance).__name__}. \"\n            f\"Initialization failed.\"\n        )\n        return\n\n    super().__init__(event_bus)\n    CSVDatafeed._instance = self\n\n    self.csv_path: Path | None = None\n    self.data_iterator: TextFileReader | None = None\n    self._watched_symbols: set[tuple[str, models.RecordType]] = set()\n    self._stop_event = threading.Event()\n    self._streaming_thread: threading.Thread | None = None\n    self._symbols_lock: threading.Lock = threading.Lock()\n    self._streaming_delay: float = 0.0\n\n    self._init_csv_path: str | Path | None = csv_path\n    self._init_streaming_delay: float | None = streaming_delay\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed.connect","title":"<code>connect()</code>","text":"<p>Connect to CSV file specified in .env file (CSV_PATH variable) and create data iterator.</p> Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to CSV file specified in .env file (CSV_PATH variable) and\n    create data iterator.\n    \"\"\"\n    load_dotenv()\n\n    if self._init_csv_path is not None:\n        csv_path_str = str(self._init_csv_path)\n        console.logger.info(f\"Using CSV path from initialization: {csv_path_str}\")\n    else:\n        csv_path_str = os.getenv(\"CSV_PATH\")\n        if not csv_path_str:\n            console.logger.error(\n                \"CSV_PATH not found in environment variables and not \"\n                \"provided in __init__. Either set CSV_PATH in .env file \"\n                \"or pass csv_path to CSVDatafeed()\"\n            )\n            return False\n\n    if self._init_streaming_delay is not None:\n        self._streaming_delay = self._init_streaming_delay\n        if self._streaming_delay &lt; 0:\n            console.logger.warning(\n                f\"Streaming delay cannot be negative \"\n                f\"({self._streaming_delay}), using default 0.0\"\n            )\n            self._streaming_delay = 0.0\n        else:\n            console.logger.info(\n                f\"CSV streaming delay set from initialization: \"\n                f\"{self._streaming_delay} seconds\"\n            )\n    else:\n        streaming_delay_str = os.getenv(\"CSV_STREAMING_DELAY\", \"0.0\")\n        try:\n            self._streaming_delay = float(streaming_delay_str)\n            if self._streaming_delay &lt; 0:\n                console.logger.warning(\n                    f\"CSV_STREAMING_DELAY cannot be negative \"\n                    f\"({self._streaming_delay}), using default 0.0\"\n                )\n                self._streaming_delay = 0.0\n            else:\n                console.logger.info(\n                    f\"CSV streaming delay set from environment: \"\n                    f\"{self._streaming_delay} seconds\"\n                )\n        except ValueError:\n            console.logger.error(\n                f\"Invalid CSV_STREAMING_DELAY value \"\n                f\"'{streaming_delay_str}', must be a number. \"\n                f\"Using default 0.0\"\n            )\n            self._streaming_delay = 0.0\n\n    self.csv_path = Path(csv_path_str)\n\n    try:\n        self.data_iterator = pd.read_csv(\n            self.csv_path,\n            usecols=[\n                \"ts_event\",\n                \"rtype\",\n                \"open\",\n                \"high\",\n                \"low\",\n                \"close\",\n                \"volume\",\n                \"symbol\",\n            ],\n            dtype={\n                \"ts_event\": int,\n                \"rtype\": int,\n                \"open\": int,\n                \"high\": int,\n                \"low\": int,\n                \"close\": int,\n                \"volume\": int,\n                \"symbol\": str,\n            },\n            iterator=True,\n            chunksize=1,\n        )\n        console.logger.info(f\"CSV datafeed connected to: {self.csv_path}\")\n        self._stop_event.clear()\n        return True\n\n    except Exception as e:\n        console.logger.error(f\"Failed to connect to CSV file {self.csv_path}: {e}\")\n        return False\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed.watch","title":"<code>watch(symbols)</code>","text":"<p>Start streaming data for specified symbols. Can be called multiple times to add more symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, RecordType]]</code> <p>List of symbols to watch with their respective record types.</p> required Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def watch(self, symbols):\n    \"\"\"\n    Start streaming data for specified symbols.\n    Can be called multiple times to add more symbols.\n\n    Args:\n        symbols (list[tuple[str, models.RecordType]]): List of symbols to\n            watch with their respective record types.\n    \"\"\"\n    if not self.data_iterator:\n        console.logger.error(\"Not connected. Call connect() first.\")\n        return\n\n    with self._symbols_lock:\n        new_symbols = set(symbols) - self._watched_symbols\n        already_watched = set(symbols) &amp; self._watched_symbols\n\n        self._watched_symbols.update(new_symbols)\n\n        if new_symbols:\n            console.logger.info(f\"Added new symbols: {new_symbols}\")\n        if already_watched:\n            console.logger.info(f\"Already watching: {already_watched}\")\n        console.logger.info(\n            f\"Currently watching: {len(self._watched_symbols)} symbols\"\n        )\n\n    if self._streaming_thread is None or not self._streaming_thread.is_alive():\n        self._streaming_thread = threading.Thread(\n            target=self._stream, name=\"CSVDatafeedStreaming\", daemon=True\n        )\n        self._streaming_thread.start()\n        console.logger.info(\"Started CSV streaming thread\")\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed._stream","title":"<code>_stream()</code>","text":"<p>Internal method that runs in background thread to stream CSV data.</p> Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def _stream(self):\n    \"\"\"Internal method that runs in background thread to stream CSV data.\"\"\"\n    console.logger.info(\"CSV streaming thread started\")\n\n    should_delay = self._streaming_delay &gt; 0\n    delay_time = self._streaming_delay\n\n    while not self._stop_event.is_set():\n        try:\n            chunk = next(self.data_iterator)\n            row = chunk.iloc[0]\n\n            symbol = row[\"symbol\"]\n            rtype = row[\"rtype\"]\n\n            with self._symbols_lock:\n                symbol_key = (symbol, models.RecordType(rtype))\n                if symbol_key not in self._watched_symbols:\n                    continue\n\n            bar_event = events.Market.IncomingBar(\n                ts_event=pd.Timestamp(row[\"ts_event\"], unit=\"ns\", tz=\"UTC\"),\n                symbol=symbol,\n                bar=models.Bar(\n                    open=row[\"open\"] / 1e9,\n                    high=row[\"high\"] / 1e9,\n                    low=row[\"low\"] / 1e9,\n                    close=row[\"close\"] / 1e9,\n                    volume=int(row[\"volume\"]),\n                ),\n            )\n\n            self.event_bus.publish(bar_event)\n\n            if should_delay:\n                time.sleep(delay_time)\n\n        except StopIteration:\n            console.logger.info(\"CSV datafeed reached end of file\")\n            break\n        except ValueError as e:\n            console.logger.warning(f\"Invalid rtype {row['rtype']} in CSV data: {e}\")\n            continue\n        except Exception as e:\n            console.logger.error(f\"CSV datafeed error reading data: {e}\")\n            break\n\n    console.logger.info(\"CSV streaming thread stopped\")\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed.unwatch","title":"<code>unwatch(symbols)</code>","text":"<p>Stop watching specific symbols.</p> <p>Parameters:</p> Name Type Description Default <code>symbols</code> <code>list[tuple[str, RecordType]]</code> <p>List of symbols to stop watching.</p> required Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def unwatch(self, symbols):\n    \"\"\"\n    Stop watching specific symbols.\n\n    Args:\n        symbols (list[tuple[str, models.RecordType]]): List of symbols to\n            stop watching.\n    \"\"\"\n    with self._symbols_lock:\n        for symbol in symbols:\n            self._watched_symbols.discard(symbol)\n\n        console.logger.info(f\"Stopped watching symbols: {symbols}\")\n        console.logger.info(f\"Still watching: {self._watched_symbols}\")\n</code></pre>"},{"location":"api-reference/datafeeds/csv_datafeed/#onesecondtrader.datafeeds.csv_datafeed.CSVDatafeed.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from CSV datafeed.</p> Source code in <code>src/onesecondtrader/datafeeds/csv_datafeed.py</code> <pre><code>def disconnect(self):\n    \"\"\"\n    Disconnect from CSV datafeed.\n    \"\"\"\n    self._stop_event.set()\n\n    if self._streaming_thread and self._streaming_thread.is_alive():\n        console.logger.info(\"Waiting for streaming thread to stop...\")\n        self._streaming_thread.join(timeout=5.0)\n        if self._streaming_thread.is_alive():\n            console.logger.warning(\"Streaming thread did not stop within timeout\")\n\n    with self._symbols_lock:\n        self._watched_symbols.clear()\n\n    if self.data_iterator is not None:\n        try:\n            self.data_iterator.close()\n            console.logger.info(\"CSV iterator closed successfully\")\n        except Exception as e:\n            console.logger.warning(f\"Error closing CSV iterator: {e}\")\n        finally:\n            self.data_iterator = None\n\n    self.csv_path = None\n    self._streaming_thread = None\n\n    CSVDatafeed._instance = None\n</code></pre>"},{"location":"api-reference/indicators/base_indicator/","title":"Base Indicator","text":"<p>This module provides the base class for all indicators.</p>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator","title":"<code>BaseIndicator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all indicators.</p> <p>If new market data is received, the indicator is updated by calling the <code>update(incoming_bar)</code> method. When programming a new indicator, only the <code>name</code> property and the <code>_compute_indicator()</code> method need to be implemented.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.indicators import base_indicator\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; class DummyCloseIndicator(base_indicator.BaseIndicator):\n...     @property\n...     def name(self) -&gt; str:\n...         return \"dummy_close_indicator\"\n...     def _compute_indicator(self, incoming_bar: models.Bar):\n...         return incoming_bar.close\n...\n&gt;&gt;&gt; dummy_close_indicator = DummyCloseIndicator(max_history=10)\n&gt;&gt;&gt; incoming_bar = models.Bar(\n...     open=100.0, high=101.0, low=99.0, close=100.5, volume=10000\n... )\n&gt;&gt;&gt; dummy_close_indicator.update(incoming_bar)\n&gt;&gt;&gt; dummy_close_indicator[0]\n100.5\n&gt;&gt;&gt; dummy_close_indicator[-1]\nnan\n&gt;&gt;&gt; next_incoming_bar = models.Bar(\n...     open=100.0, high=101.0, low=99.0, close=101.0, volume=10000\n... )\n&gt;&gt;&gt; dummy_close_indicator.update(next_incoming_bar)\n&gt;&gt;&gt; dummy_close_indicator[0]\n101.0\n&gt;&gt;&gt; dummy_close_indicator[-1]\n100.5\n</code></pre> Source code in <code>src/onesecondtrader/indicators/base_indicator.py</code> <pre><code>class BaseIndicator(abc.ABC):\n    \"\"\"\n    Base class for all indicators.\n\n    If new market data is received, the indicator is updated by calling the\n    `update(incoming_bar)` method.\n    When programming a new indicator, only the `name` property and the\n    `_compute_indicator()` method need to be implemented.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.indicators import base_indicator\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; class DummyCloseIndicator(base_indicator.BaseIndicator):\n        ...     @property\n        ...     def name(self) -&gt; str:\n        ...         return \"dummy_close_indicator\"\n        ...     def _compute_indicator(self, incoming_bar: models.Bar):\n        ...         return incoming_bar.close\n        ...\n        &gt;&gt;&gt; dummy_close_indicator = DummyCloseIndicator(max_history=10)\n        &gt;&gt;&gt; incoming_bar = models.Bar(\n        ...     open=100.0, high=101.0, low=99.0, close=100.5, volume=10000\n        ... )\n        &gt;&gt;&gt; dummy_close_indicator.update(incoming_bar)\n        &gt;&gt;&gt; dummy_close_indicator[0]\n        100.5\n        &gt;&gt;&gt; dummy_close_indicator[-1]\n        nan\n        &gt;&gt;&gt; next_incoming_bar = models.Bar(\n        ...     open=100.0, high=101.0, low=99.0, close=101.0, volume=10000\n        ... )\n        &gt;&gt;&gt; dummy_close_indicator.update(next_incoming_bar)\n        &gt;&gt;&gt; dummy_close_indicator[0]\n        101.0\n        &gt;&gt;&gt; dummy_close_indicator[-1]\n        100.5\n    \"\"\"\n\n    def __init__(self, max_history: int = 100) -&gt; None:\n        \"\"\"\n        Initialize the indicator with a maximum lookback history length.\n\n        Args:\n            max_history (int): Maximum lookback history length as number of periods.\n            Defaults to 100.\n\n        Attributes:\n            self._lock (threading.Lock): Lock to protect concurrent access to the\n                indicator's state.\n            self._history (collections.deque): Deque to store the lookback history.\n        \"\"\"\n        if max_history &lt; 1:\n            console.logger.warning(\n                f\"max_history must be &gt;= 1, got {max_history}; defaulting to 1\"\n            )\n            max_history = 1\n        self._lock: threading.Lock = threading.Lock()\n\n        self._history: collections.deque[float] = collections.deque(maxlen=max_history)\n\n    @property\n    @abc.abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Name of the indicator.\n        This property must be implemented by subclasses.\n\n        Returns:\n            str: Name of the indicator.\n        \"\"\"\n        pass\n\n    @property\n    def latest(self) -&gt; float:\n        \"\"\"\n        The latest (most recent) indicator value.\n\n        Equivalent to self[0]. Returns numpy.nan when no value is available yet.\n        \"\"\"\n        return self[0]\n\n    def update(self, incoming_bar: models.Bar) -&gt; None:\n        \"\"\"\n        Updates the indicator based on an incoming closed bar by calling\n        `self._compute_indicator()`.\n        \"\"\"\n        new_value = self._compute_indicator(incoming_bar)\n        with self._lock:\n            self._history.append(new_value)\n\n    @abc.abstractmethod\n    def _compute_indicator(self, incoming_bar: models.Bar) -&gt; float:\n        \"\"\"\n        Computes the new indicator value based on an incoming closed bar.\n        This method must be implemented by subclasses.\n        \"\"\"\n        pass\n\n    def __getitem__(self, index: int) -&gt; float:\n        \"\"\"\n        Return the indicator value at the given index with tolerant indexing.\n\n        Indexing rules:\n\n        - `0` returns the current (most recent) value\n        - `-1` returns the previous value, `-2` two periods back, and so on\n        - For convenience, a positive `k` behaves like `-k` (e.g., `1 == -1`,\n          `2 == -2`)\n        - Out-of-range indices return `np.nan` instead of raising an `IndexError`.\n        \"\"\"\n        normalized: int\n        if index == 0:\n            normalized = -1\n        elif index &gt; 0:\n            normalized = -(index + 1)\n        else:\n            normalized = index - 1\n\n        with self._lock:\n            try:\n                return self._history[normalized]\n            except IndexError:\n                return np.nan\n</code></pre>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Name of the indicator. This property must be implemented by subclasses.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name of the indicator.</p>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator.latest","title":"<code>latest</code>  <code>property</code>","text":"<p>The latest (most recent) indicator value.</p> <p>Equivalent to self[0]. Returns numpy.nan when no value is available yet.</p>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator.__init__","title":"<code>__init__(max_history=100)</code>","text":"<p>Initialize the indicator with a maximum lookback history length.</p> <p>Parameters:</p> Name Type Description Default <code>max_history</code> <code>int</code> <p>Maximum lookback history length as number of periods.</p> <code>100</code> <p>Attributes:</p> Name Type Description <code>self._lock</code> <code>Lock</code> <p>Lock to protect concurrent access to the indicator's state.</p> <code>self._history</code> <code>deque</code> <p>Deque to store the lookback history.</p> Source code in <code>src/onesecondtrader/indicators/base_indicator.py</code> <pre><code>def __init__(self, max_history: int = 100) -&gt; None:\n    \"\"\"\n    Initialize the indicator with a maximum lookback history length.\n\n    Args:\n        max_history (int): Maximum lookback history length as number of periods.\n        Defaults to 100.\n\n    Attributes:\n        self._lock (threading.Lock): Lock to protect concurrent access to the\n            indicator's state.\n        self._history (collections.deque): Deque to store the lookback history.\n    \"\"\"\n    if max_history &lt; 1:\n        console.logger.warning(\n            f\"max_history must be &gt;= 1, got {max_history}; defaulting to 1\"\n        )\n        max_history = 1\n    self._lock: threading.Lock = threading.Lock()\n\n    self._history: collections.deque[float] = collections.deque(maxlen=max_history)\n</code></pre>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator.update","title":"<code>update(incoming_bar)</code>","text":"<p>Updates the indicator based on an incoming closed bar by calling <code>self._compute_indicator()</code>.</p> Source code in <code>src/onesecondtrader/indicators/base_indicator.py</code> <pre><code>def update(self, incoming_bar: models.Bar) -&gt; None:\n    \"\"\"\n    Updates the indicator based on an incoming closed bar by calling\n    `self._compute_indicator()`.\n    \"\"\"\n    new_value = self._compute_indicator(incoming_bar)\n    with self._lock:\n        self._history.append(new_value)\n</code></pre>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>  <code>abstractmethod</code>","text":"<p>Computes the new indicator value based on an incoming closed bar. This method must be implemented by subclasses.</p> Source code in <code>src/onesecondtrader/indicators/base_indicator.py</code> <pre><code>@abc.abstractmethod\ndef _compute_indicator(self, incoming_bar: models.Bar) -&gt; float:\n    \"\"\"\n    Computes the new indicator value based on an incoming closed bar.\n    This method must be implemented by subclasses.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/indicators/base_indicator/#onesecondtrader.indicators.base_indicator.BaseIndicator.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Return the indicator value at the given index with tolerant indexing.</p> <p>Indexing rules:</p> <ul> <li><code>0</code> returns the current (most recent) value</li> <li><code>-1</code> returns the previous value, <code>-2</code> two periods back, and so on</li> <li>For convenience, a positive <code>k</code> behaves like <code>-k</code> (e.g., <code>1 == -1</code>,   <code>2 == -2</code>)</li> <li>Out-of-range indices return <code>np.nan</code> instead of raising an <code>IndexError</code>.</li> </ul> Source code in <code>src/onesecondtrader/indicators/base_indicator.py</code> <pre><code>def __getitem__(self, index: int) -&gt; float:\n    \"\"\"\n    Return the indicator value at the given index with tolerant indexing.\n\n    Indexing rules:\n\n    - `0` returns the current (most recent) value\n    - `-1` returns the previous value, `-2` two periods back, and so on\n    - For convenience, a positive `k` behaves like `-k` (e.g., `1 == -1`,\n      `2 == -2`)\n    - Out-of-range indices return `np.nan` instead of raising an `IndexError`.\n    \"\"\"\n    normalized: int\n    if index == 0:\n        normalized = -1\n    elif index &gt; 0:\n        normalized = -(index + 1)\n    else:\n        normalized = index - 1\n\n    with self._lock:\n        try:\n            return self._history[normalized]\n        except IndexError:\n            return np.nan\n</code></pre>"},{"location":"api-reference/indicators/moving_averages/","title":"Moving Averages","text":"<p>This module provides various moving average indicators.</p>"},{"location":"api-reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>BaseIndicator</code></p> <p>Simple Moving Average (SMA) indicator for different OHLC-data related time series,  the possible modes for the SMA calculation are indicated in the  <code>core.models.XMAMode</code> enum (currently: <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>,  <code>typical_price</code>, <code>weighted close</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.indicators import moving_averages\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; sma = moving_averages.SimpleMovingAverage(\n...     period=3, mode=models.XMAMode.CLOSE\n... )\n&gt;&gt;&gt; bar1 = models.Bar(\n...     open=100.0, high=101.0, low=99.0, close=100.0, volume=1000\n... )\n&gt;&gt;&gt; sma.update(bar1)\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.isnan(sma.latest)\nTrue\n&gt;&gt;&gt; bar2 = models.Bar(\n...     open=100.0, high=102.0, low=100.0, close=101.0, volume=1500\n... )\n&gt;&gt;&gt; sma.update(bar2)\n&gt;&gt;&gt; np.isnan(sma.latest)\nTrue\n&gt;&gt;&gt; bar3 = models.Bar(\n...     open=101.0, high=103.0, low=101.0, close=102.0, volume=2000\n... )\n&gt;&gt;&gt; sma.update(bar3)\n&gt;&gt;&gt; np.isnan(sma.latest)\nFalse\n&gt;&gt;&gt; sma.latest\n101.0\n</code></pre> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>class SimpleMovingAverage(base_indicator.BaseIndicator):\n    \"\"\"\n    Simple Moving Average (SMA) indicator for different OHLC-data related time series,\n     the possible modes for the SMA calculation are indicated in the\n     `core.models.XMAMode` enum (currently: `open`, `high`, `low`, `close`,\n     `typical_price`, `weighted close`).\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.indicators import moving_averages\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; sma = moving_averages.SimpleMovingAverage(\n        ...     period=3, mode=models.XMAMode.CLOSE\n        ... )\n        &gt;&gt;&gt; bar1 = models.Bar(\n        ...     open=100.0, high=101.0, low=99.0, close=100.0, volume=1000\n        ... )\n        &gt;&gt;&gt; sma.update(bar1)\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; np.isnan(sma.latest)\n        True\n        &gt;&gt;&gt; bar2 = models.Bar(\n        ...     open=100.0, high=102.0, low=100.0, close=101.0, volume=1500\n        ... )\n        &gt;&gt;&gt; sma.update(bar2)\n        &gt;&gt;&gt; np.isnan(sma.latest)\n        True\n        &gt;&gt;&gt; bar3 = models.Bar(\n        ...     open=101.0, high=103.0, low=101.0, close=102.0, volume=2000\n        ... )\n        &gt;&gt;&gt; sma.update(bar3)\n        &gt;&gt;&gt; np.isnan(sma.latest)\n        False\n        &gt;&gt;&gt; sma.latest\n        101.0\n    \"\"\"\n\n    def __init__(\n        self,\n        period: int,\n        mode: models.XMAMode = models.XMAMode.CLOSE,\n        max_history: int = 100,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the indicator with a period and a mode.\n\n        Args:\n            period (int): Period of the moving average. Will be set to 1 if &lt; 1.\n            mode (models.XMAMode): Mode of the moving average. Defaults to `CLOSE`.\n            max_history (int): Maximum lookback history length. Defaults to 100.\n\n        Attributes:\n            self.period (int): Period of the moving average.\n            self.mode (models.XMAMode): Mode of the moving average.\n        \"\"\"\n        if period &lt; 1:\n            console.logger.warning(\n                f\"Period must be &gt;= 1, got {period}; defaulting to 1\"\n            )\n            period = 1\n\n        super().__init__(max_history=max_history)\n        self.period: int = period\n        self.mode: models.XMAMode = mode\n        self._window: collections.deque[float] = collections.deque(maxlen=self.period)\n\n    @property\n    def name(self) -&gt; str:\n        return f\"SMA_{self.period}_{self.mode.name}\"\n\n    def _compute_indicator(self, incoming_bar: models.Bar) -&gt; float:\n        \"\"\"\n        Compute the specified simple moving average based on the incoming bar.\n\n        Args:\n            incoming_bar (models.Bar): Incoming bar with OHLCV data.\n\n        Returns:\n            float: Simple moving average value, or np.nan if insufficient data or\n            errors occur.\n        \"\"\"\n        try:\n            mode = self.mode\n            if mode is models.XMAMode.OPEN:\n                current_value = incoming_bar.open\n            elif mode is models.XMAMode.HIGH:\n                current_value = incoming_bar.high\n            elif mode is models.XMAMode.LOW:\n                current_value = incoming_bar.low\n            elif mode is models.XMAMode.CLOSE:\n                current_value = incoming_bar.close\n            elif mode is models.XMAMode.TYPICAL_PRICE:\n                current_value = (\n                    incoming_bar.high + incoming_bar.low + incoming_bar.close\n                ) / 3.0\n            elif mode is models.XMAMode.WEIGHTED_CLOSE:\n                current_value = (\n                    incoming_bar.high + incoming_bar.low + 2.0 * incoming_bar.close\n                ) / 4.0\n            else:\n                console.logger.warning(\n                    f\"Unsupported XMAMode: {mode}; using close price\"\n                )\n                current_value = incoming_bar.close\n\n            if not np.isfinite(current_value):\n                console.logger.warning(\n                    f\"Invalid value extracted: {current_value} (mode={mode.name}); \"\n                    f\"using np.nan\"\n                )\n                return np.nan\n\n            with self._lock:\n                self._window.append(current_value)\n                if len(self._window) &lt; self.period:\n                    return np.nan\n                sma_value = sum(self._window) / self.period\n            return sma_value\n\n        except Exception as e:\n            console.logger.warning(f\"SMA calculation failed: {e}; returning np.nan\")\n            return np.nan\n</code></pre>"},{"location":"api-reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage.__init__","title":"<code>__init__(period, mode=models.XMAMode.CLOSE, max_history=100)</code>","text":"<p>Initialize the indicator with a period and a mode.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Period of the moving average. Will be set to 1 if &lt; 1.</p> required <code>mode</code> <code>XMAMode</code> <p>Mode of the moving average. Defaults to <code>CLOSE</code>.</p> <code>CLOSE</code> <code>max_history</code> <code>int</code> <p>Maximum lookback history length. Defaults to 100.</p> <code>100</code> <p>Attributes:</p> Name Type Description <code>self.period</code> <code>int</code> <p>Period of the moving average.</p> <code>self.mode</code> <code>XMAMode</code> <p>Mode of the moving average.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def __init__(\n    self,\n    period: int,\n    mode: models.XMAMode = models.XMAMode.CLOSE,\n    max_history: int = 100,\n) -&gt; None:\n    \"\"\"\n    Initialize the indicator with a period and a mode.\n\n    Args:\n        period (int): Period of the moving average. Will be set to 1 if &lt; 1.\n        mode (models.XMAMode): Mode of the moving average. Defaults to `CLOSE`.\n        max_history (int): Maximum lookback history length. Defaults to 100.\n\n    Attributes:\n        self.period (int): Period of the moving average.\n        self.mode (models.XMAMode): Mode of the moving average.\n    \"\"\"\n    if period &lt; 1:\n        console.logger.warning(\n            f\"Period must be &gt;= 1, got {period}; defaulting to 1\"\n        )\n        period = 1\n\n    super().__init__(max_history=max_history)\n    self.period: int = period\n    self.mode: models.XMAMode = mode\n    self._window: collections.deque[float] = collections.deque(maxlen=self.period)\n</code></pre>"},{"location":"api-reference/indicators/moving_averages/#onesecondtrader.indicators.moving_averages.SimpleMovingAverage._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"<p>Compute the specified simple moving average based on the incoming bar.</p> <p>Parameters:</p> Name Type Description Default <code>incoming_bar</code> <code>Bar</code> <p>Incoming bar with OHLCV data.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Simple moving average value, or np.nan if insufficient data or</p> <code>float</code> <p>errors occur.</p> Source code in <code>src/onesecondtrader/indicators/moving_averages.py</code> <pre><code>def _compute_indicator(self, incoming_bar: models.Bar) -&gt; float:\n    \"\"\"\n    Compute the specified simple moving average based on the incoming bar.\n\n    Args:\n        incoming_bar (models.Bar): Incoming bar with OHLCV data.\n\n    Returns:\n        float: Simple moving average value, or np.nan if insufficient data or\n        errors occur.\n    \"\"\"\n    try:\n        mode = self.mode\n        if mode is models.XMAMode.OPEN:\n            current_value = incoming_bar.open\n        elif mode is models.XMAMode.HIGH:\n            current_value = incoming_bar.high\n        elif mode is models.XMAMode.LOW:\n            current_value = incoming_bar.low\n        elif mode is models.XMAMode.CLOSE:\n            current_value = incoming_bar.close\n        elif mode is models.XMAMode.TYPICAL_PRICE:\n            current_value = (\n                incoming_bar.high + incoming_bar.low + incoming_bar.close\n            ) / 3.0\n        elif mode is models.XMAMode.WEIGHTED_CLOSE:\n            current_value = (\n                incoming_bar.high + incoming_bar.low + 2.0 * incoming_bar.close\n            ) / 4.0\n        else:\n            console.logger.warning(\n                f\"Unsupported XMAMode: {mode}; using close price\"\n            )\n            current_value = incoming_bar.close\n\n        if not np.isfinite(current_value):\n            console.logger.warning(\n                f\"Invalid value extracted: {current_value} (mode={mode.name}); \"\n                f\"using np.nan\"\n            )\n            return np.nan\n\n        with self._lock:\n            self._window.append(current_value)\n            if len(self._window) &lt; self.period:\n                return np.nan\n            sma_value = sum(self._window) / self.period\n        return sma_value\n\n    except Exception as e:\n        console.logger.warning(f\"SMA calculation failed: {e}; returning np.nan\")\n        return np.nan\n</code></pre>"},{"location":"api-reference/messaging/eventbus/","title":"Eventbus","text":"<p>This module provides the event bus for managing event-driven communication between  the trading infrastructure's components via a publish-subscribe messaging pattern.</p>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus for managing event-driven communication between the trading  infrastructure's components via a publish-subscribe messaging pattern. Supports inheritance-based subscriptions where handlers subscribed to a parent event  type will receive events of child types. Each subscription can include an optional filter function to receive only specific  events of a given type (e.g. filtering <code>IncomingBar</code> events for a specific symbol).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Import necessary modules\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from onesecondtrader.messaging.eventbus import EventBus\n&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n</code></pre> <pre><code>&gt;&gt;&gt; # Instantiate event bus\n&gt;&gt;&gt; event_bus = EventBus()\n</code></pre> <pre><code>&gt;&gt;&gt; # Create a dummy handler that simply prints the symbol of the received event\n&gt;&gt;&gt; def dummy_handler(incoming_bar_event: events.Market.IncomingBar):\n...     print(f\"Received: {incoming_bar_event.symbol}\")\n</code></pre> <pre><code>&gt;&gt;&gt; # Subscribe to IncomingBar events whose symbol is AAPL\n&gt;&gt;&gt; event_bus.subscribe(\n...     events.Market.IncomingBar,\n...     dummy_handler,\n...     lambda event: event.symbol == \"AAPL\" # Lambda filter function\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Create events to publish\n&gt;&gt;&gt; aapl_event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n...     symbol=\"AAPL\",\n...     bar=models.Bar(\n...         open=100.0, high=101.0, low=99.0,\n...         close=100.5, volume=1000\n...     )\n... )\n&gt;&gt;&gt; googl_event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n...     symbol=\"GOOGL\",\n...     bar=models.Bar(\n...         open=2800.0, high=2801.0, low=2799.0,\n...         close=2800.5, volume=500\n...     )\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Publish events - only AAPL passes filter and will be printed\n&gt;&gt;&gt; event_bus.publish(aapl_event)\nReceived: AAPL\n&gt;&gt;&gt; event_bus.publish(googl_event)\n</code></pre> <pre><code>&gt;&gt;&gt; # Unsubscribe the dummy handler\n&gt;&gt;&gt; event_bus.unsubscribe(events.Market.IncomingBar, dummy_handler)\n</code></pre> <pre><code>&gt;&gt;&gt; # Publish again - no handler receives it (warning will be logged)\n&gt;&gt;&gt; event_bus.publish(aapl_event)\nWARNING:root:Published IncomingBar but no subscribers exist - check event wiring\n</code></pre> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>class EventBus:\n    # noinspection PyTypeChecker\n    \"\"\"\n    Event bus for managing event-driven communication between the trading\n     infrastructure's components via a publish-subscribe messaging pattern.\n    Supports inheritance-based subscriptions where handlers subscribed to a parent event\n     type will receive events of child types.\n    Each subscription can include an optional filter function to receive only specific\n     events of a given type (e.g. filtering `IncomingBar` events for a specific symbol).\n\n    Examples:\n        &gt;&gt;&gt; # Import necessary modules\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; from onesecondtrader.messaging.eventbus import EventBus\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n\n        &gt;&gt;&gt; # Instantiate event bus\n        &gt;&gt;&gt; event_bus = EventBus()\n\n        &gt;&gt;&gt; # Create a dummy handler that simply prints the symbol of the received event\n        &gt;&gt;&gt; def dummy_handler(incoming_bar_event: events.Market.IncomingBar):\n        ...     print(f\"Received: {incoming_bar_event.symbol}\")\n\n        &gt;&gt;&gt; # Subscribe to IncomingBar events whose symbol is AAPL\n        &gt;&gt;&gt; event_bus.subscribe(\n        ...     events.Market.IncomingBar,\n        ...     dummy_handler,\n        ...     lambda event: event.symbol == \"AAPL\" # Lambda filter function\n        ... )\n\n        &gt;&gt;&gt; # Create events to publish\n        &gt;&gt;&gt; aapl_event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n        ...     symbol=\"AAPL\",\n        ...     bar=models.Bar(\n        ...         open=100.0, high=101.0, low=99.0,\n        ...         close=100.5, volume=1000\n        ...     )\n        ... )\n        &gt;&gt;&gt; googl_event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01\", tz=\"UTC\"),\n        ...     symbol=\"GOOGL\",\n        ...     bar=models.Bar(\n        ...         open=2800.0, high=2801.0, low=2799.0,\n        ...         close=2800.5, volume=500\n        ...     )\n        ... )\n\n        &gt;&gt;&gt; # Publish events - only AAPL passes filter and will be printed\n        &gt;&gt;&gt; event_bus.publish(aapl_event)\n        Received: AAPL\n        &gt;&gt;&gt; event_bus.publish(googl_event)\n\n        &gt;&gt;&gt; # Unsubscribe the dummy handler\n        &gt;&gt;&gt; event_bus.unsubscribe(events.Market.IncomingBar, dummy_handler)\n\n        &gt;&gt;&gt; # Publish again - no handler receives it (warning will be logged)\n        &gt;&gt;&gt; event_bus.publish(aapl_event)  # doctest: +SKIP\n        WARNING:root:Published IncomingBar but no subscribers exist - check event wiring\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initializes the event bus with optimized data structures for high-performance\n        event publishing.\n\n        Attributes:\n            self._handlers (collections.defaultdict): Direct storage mapping event types\n                 to handler lists\n            self._publish_cache (dict): Pre-computed cache for O(1) publish operations\n            self._lock (threading.Lock): Single lock for all operations\n                (subscribe/unsubscribe are rare)\n            self._sequence_number (int): Sequence number counter for events\n        \"\"\"\n        self._handlers: dict[\n            type[events.Base.Event],\n            list[\n                tuple[\n                    Callable[[events.Base.Event], None],\n                    Callable[[events.Base.Event], bool],\n                ]\n            ],\n        ] = collections.defaultdict(list)\n\n        self._publish_cache: dict[\n            type[events.Base.Event],\n            list[\n                tuple[\n                    Callable[[events.Base.Event], None],\n                    Callable[[events.Base.Event], bool],\n                ]\n            ],\n        ] = {}\n\n        self._lock: threading.Lock = threading.Lock()\n        self._sequence_number: int = -1\n\n        self._rebuild_cache()\n\n    def subscribe(\n        self,\n        event_type: type[events.Base.Event],\n        event_handler: Callable[[events.Base.Event], None],\n        event_filter: Callable[[events.Base.Event], bool] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        The `subscribe` method registers an event handler for event messages of a\n         specified type and all its subtypes (expressed as subclasses in the event\n          dataclass hierarchy, so-called inheritance-based subscription).\n        When an event of that type or any subtype is published, the handler will be\n         invoked if the associated `event_filter` returns `True` for that event\n         instance.\n        A given handler can only be subscribed once per event type.\n        If the handler is already subscribed to the given event type\n         \u2014regardless of the filter function\u2014\n        the subscription attempt is ignored and a warning is logged.\n\n        Arguments:\n            event_type (type[events.Base.Event]): Type of the event to subscribe to,\n             must be a subclass of `events.Base.Event`.\n            event_handler (Callable[events.Base.Event, None]): Function to call when an\n                 event of the given type is published.\n                This callable must accept a single argument of type `events.Base.Event`\n                 (or its subclass).\n            event_filter (Callable[[events.Base.Event], bool] | None): Function to\n                 determine whether to call the event handler for a given event.\n                Should accept one event and return `True` to handle or `False` to\n                 ignore.\n                Defaults to `None`, which creates a filter that always returns `True`\n                 (i.e. always call the event handler).\n        \"\"\"\n\n        if not issubclass(event_type, events.Base.Event):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_type must be a subclass of \"\n                f\"Event, got {type(event_type).__name__}\"\n            )\n            return\n\n        if not callable(event_handler):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_handler must be callable, \"\n                f\"got {type(event_handler).__name__}\"\n            )\n            return\n\n        if event_filter is None:\n\n            def event_filter(event: events.Base.Event) -&gt; bool:\n                return True\n\n        if not callable(event_filter):\n            console.logger.error(\n                f\"Invalid subscription attempt: event_filter must be callable, \"\n                f\"got {type(event_filter).__name__}\"\n            )\n            return\n\n        is_valid, error_msg = self._validate_filter_signature(event_filter)\n        if not is_valid:\n            console.logger.error(f\"Invalid subscription attempt: {error_msg}\")\n            return\n\n        with self._lock:\n            if any(\n                event_handler == existing_handler\n                for existing_handler, _ in self._handlers[event_type]\n            ):\n                console.logger.warning(\n                    f\"Duplicate subscription attempt: event_handler was already \"\n                    f\"subscribed to {event_type.__name__}\"\n                )\n                return\n\n            self._handlers[event_type].append((event_handler, event_filter))\n\n            self._rebuild_cache()\n\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.info(f\"Subscribed {handler_name} to {event_type.__name__}.\")\n\n    def unsubscribe(\n        self,\n        event_type: type[events.Base.Event],\n        event_handler: Callable[[events.Base.Event], None],\n    ) -&gt; None:\n        \"\"\"\n        The `unsubscribe` method removes an event handler from the subscribers list for\n         the specified event type.\n        If the event handler is not subscribed to the given event type, the\n         unsubscription attempt is ignored and a warning is logged.\n        After removing the event handler, the event type may have an empty subscribers\n         list but remains in the `subscribers` dictionary.\n\n        Arguments:\n            event_type (type[events.Base.Event]): Type of the event to unsubscribe from,\n                 must be a subclass of `events.Base.Event`.\n            event_handler (Callable[events.Base.Event, None]): Event handler to remove\n                 from the subscribers list (this will also remove the associated filter\n                 function).\n        \"\"\"\n        if not issubclass(event_type, events.Base.Event):\n            console.logger.error(\n                f\"Invalid unsubscription attempt: event_type must be a subclass of \"\n                f\"Event, got {type(event_type).__name__}\"\n            )\n            return\n\n        if not callable(event_handler):\n            console.logger.error(\n                f\"Invalid unsubscription attempt: callback must be callable, \"\n                f\"got {type(event_handler).__name__}\"\n            )\n            return\n\n        with self._lock:\n            if event_type not in self._handlers:\n                console.logger.warning(\n                    f\"Attempted to unsubscribe from {event_type.__name__}, \"\n                    f\"but no subscribers exist\"\n                )\n                return\n\n            current_handlers = self._handlers[event_type]\n            new_handlers = [\n                (existing_handler, existing_filter)\n                for existing_handler, existing_filter in current_handlers\n                if existing_handler != event_handler\n            ]\n\n            removed_count = len(current_handlers) - len(new_handlers)\n            if removed_count == 0:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.warning(\n                    f\"Attempted to unsubscribe {handler_name} from \"\n                    f\"{event_type.__name__}, but it was not subscribed\"\n                )\n                return\n\n            if new_handlers:\n                self._handlers[event_type] = new_handlers\n            else:\n                # Clean up empty lists\n                del self._handlers[event_type]\n\n            self._rebuild_cache()\n\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.info(\n                f\"Unsubscribed {handler_name} from \"\n                f\"{event_type.__name__} (removed {removed_count} subscription(s))\"\n            )\n\n    def publish(self, event: events.Base.Event) -&gt; None:\n        \"\"\"\n        The `publish` method delivers the event to all handlers subscribed to the\n         event's type or any of its parent types (inheritance-based subscription).\n        Handlers are only called if their filter function returns True for this event.\n        Handlers are called synchronously in the order they were subscribed.\n\n        This method uses a pre-computed handler cache for O(1) lookup performance\n        and runs without locks for maximum concurrency.\n\n        Arguments:\n            event (events.Base.Event): Event to publish. Must be an instance of\n                 `events.Base.Event` or one of its subclasses.\n        \"\"\"\n        if not isinstance(event, events.Base.Event):\n            console.logger.error(\n                f\"Invalid publish attempt: event must be an instance of Event, \"\n                f\"got {type(event).__name__}\"\n            )\n            return\n\n        object.__setattr__(\n            event, \"event_bus_sequence_number\", self._set_sequence_number()\n        )\n\n        event_type: type[events.Base.Event] = type(event)\n\n        handlers = self._publish_cache.get(event_type, [])\n\n        if not handlers:\n            console.logger.warning(\n                f\"Published {event_type.__name__} but no subscribers exist - \"\n                f\"check event wiring\"\n            )\n            return\n\n        delivered_count = 0\n        for event_handler, event_filter in handlers:\n            try:\n                should_handle = event_filter(event)\n\n                if not isinstance(should_handle, bool):\n                    handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                    console.logger.warning(\n                        f\"Filter for handler {handler_name} returned \"\n                        f\"{type(should_handle).__name__}, expected bool. \"\n                        f\"Treating as False.\"\n                    )\n                    should_handle = False\n\n            except TypeError as type_error:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                if \"takes\" in str(type_error) and \"positional argument\" in str(\n                    type_error\n                ):\n                    console.logger.error(\n                        f\"Filter for handler {handler_name} has wrong signature: \"\n                        f\"{type_error}\"\n                    )\n                else:\n                    console.logger.exception(\n                        f\"Filter function for handler {handler_name} failed \"\n                        f\"processing {event_type.__name__}: {type_error}\"\n                    )\n                continue\n            except Exception as filter_exception:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.exception(\n                    f\"Filter function for handler {handler_name} failed \"\n                    f\"processing {event_type.__name__}: {filter_exception}\"\n                )\n                continue\n\n            if should_handle:\n                try:\n                    event_handler(event)\n                    delivered_count += 1\n                except Exception as handler_exception:\n                    handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                    console.logger.exception(\n                        f\"Handler {handler_name} failed processing \"\n                        f\"{event_type.__name__}: {handler_exception}\"\n                    )\n\n        if delivered_count == 0:\n            console.logger.warning(\n                f\"Published {event_type.__name__} but no handlers received it - \"\n                f\"all {len(handlers)} handler(s) filtered out the event\"\n            )\n        else:\n            # Conditional debug logging to avoid string formatting overhead\n            if console.logger.isEnabledFor(logging.DEBUG):\n                console.logger.debug(\n                    f\"Published {event_type.__name__} to {delivered_count} handler(s)\"\n                )\n\n    @staticmethod\n    def _validate_filter_signature(\n        event_filter: Callable[[events.Base.Event], bool],\n    ) -&gt; tuple[bool, str | None]:\n        \"\"\"\n        Validate that filter function has the correct signature.\n\n        A valid filter function must:\n        - Accept exactly 1 parameter (the event)\n        - Not use *args or **kwargs\n        - Optionally return bool (if type annotated)\n\n        Arguments:\n            event_filter (Callable): The filter function to validate\n\n        Returns:\n            tuple[bool, str | None]: (is_valid, error_message)\n                is_valid: True if signature is valid, False otherwise\n                error_message: Description of the issue if invalid, None if valid\n        \"\"\"\n        try:\n            sig = inspect.signature(event_filter)\n            params = list(sig.parameters.values())\n\n            if len(params) != 1:\n                return (\n                    False,\n                    f\"Filter must accept exactly 1 parameter, got {len(params)}\",\n                )\n\n            param = params[0]\n            if param.kind == inspect.Parameter.VAR_POSITIONAL:\n                return (\n                    False,\n                    \"Filter cannot use *args - must accept exactly 1 event parameter\",\n                )\n            if param.kind == inspect.Parameter.VAR_KEYWORD:\n                return (\n                    False,\n                    \"Filter cannot use **kwargs - must accept exactly 1 event \"\n                    \"parameter\",\n                )\n\n            if sig.return_annotation is not inspect.Parameter.empty:\n                if sig.return_annotation is not bool:\n                    return (\n                        False,\n                        f\"Filter return type should be bool, got \"\n                        f\"{sig.return_annotation}\",\n                    )\n\n            return True, None\n\n        except Exception as e:\n            return False, f\"Could not inspect filter signature: {e}\"\n\n    def _set_sequence_number(self) -&gt; int:\n        \"\"\"\n        Increment and return the event bus sequence number in a thread-safe manner.\n        \"\"\"\n        with self._lock:\n            self._sequence_number += 1\n            return self._sequence_number\n\n    @staticmethod\n    def _get_all_concrete_event_types() -&gt; list[type[events.Base.Event]]:\n        \"\"\"\n        Dynamically discover all concrete event types from the events module.\n        Automatically adapts to namespace changes without code modifications.\n\n        Returns:\n            list[type[events.Base.Event]]: List of concrete event classes that can be\n                instantiated and published.\n        \"\"\"\n        concrete_types = []\n\n        for attr_name in dir(events):\n            if attr_name.startswith(\"_\"):\n                continue\n\n            attr = getattr(events, attr_name)\n\n            if not inspect.isclass(attr) or attr_name == \"Base\":\n                continue\n\n            for member_name, member_obj in inspect.getmembers(attr, inspect.isclass):\n                if (\n                    issubclass(member_obj, events.Base.Event)\n                    and member_obj != events.Base.Event\n                    and not inspect.isabstract(member_obj)\n                ):\n                    concrete_types.append(member_obj)\n\n        return concrete_types\n\n    def _rebuild_cache(self) -&gt; None:\n        \"\"\"\n        Rebuild the pre-computed publish cache for all concrete event types.\n        This method should be called whenever subscriptions change.\n        \"\"\"\n        new_cache = {}\n        concrete_event_types = self._get_all_concrete_event_types()\n\n        for concrete_event_type in concrete_event_types:\n            handlers = []\n            seen_handler_ids = set()\n\n            for handler_type, handler_list in self._handlers.items():\n                if issubclass(concrete_event_type, handler_type):\n                    for handler, filter_func in handler_list:\n                        handler_id = id(handler)\n                        if handler_id not in seen_handler_ids:\n                            handlers.append((handler, filter_func))\n                            seen_handler_ids.add(handler_id)\n\n            if handlers:\n                new_cache[concrete_event_type] = handlers\n\n        self._publish_cache = new_cache\n\n        if console.logger.isEnabledFor(logging.DEBUG):\n            console.logger.debug(\n                f\"Publish cache rebuilt: {len(new_cache)} event types cached, \"\n                f\"total handlers: \"\n                f\"{sum(len(handlers) for handlers in new_cache.values())}\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the event bus with optimized data structures for high-performance event publishing.</p> <p>Attributes:</p> Name Type Description <code>self._handlers</code> <code>defaultdict</code> <p>Direct storage mapping event types  to handler lists</p> <code>self._publish_cache</code> <code>dict</code> <p>Pre-computed cache for O(1) publish operations</p> <code>self._lock</code> <code>Lock</code> <p>Single lock for all operations (subscribe/unsubscribe are rare)</p> <code>self._sequence_number</code> <code>int</code> <p>Sequence number counter for events</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initializes the event bus with optimized data structures for high-performance\n    event publishing.\n\n    Attributes:\n        self._handlers (collections.defaultdict): Direct storage mapping event types\n             to handler lists\n        self._publish_cache (dict): Pre-computed cache for O(1) publish operations\n        self._lock (threading.Lock): Single lock for all operations\n            (subscribe/unsubscribe are rare)\n        self._sequence_number (int): Sequence number counter for events\n    \"\"\"\n    self._handlers: dict[\n        type[events.Base.Event],\n        list[\n            tuple[\n                Callable[[events.Base.Event], None],\n                Callable[[events.Base.Event], bool],\n            ]\n        ],\n    ] = collections.defaultdict(list)\n\n    self._publish_cache: dict[\n        type[events.Base.Event],\n        list[\n            tuple[\n                Callable[[events.Base.Event], None],\n                Callable[[events.Base.Event], bool],\n            ]\n        ],\n    ] = {}\n\n    self._lock: threading.Lock = threading.Lock()\n    self._sequence_number: int = -1\n\n    self._rebuild_cache()\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.subscribe","title":"<code>subscribe(event_type, event_handler, event_filter=None)</code>","text":"<p>The <code>subscribe</code> method registers an event handler for event messages of a  specified type and all its subtypes (expressed as subclasses in the event   dataclass hierarchy, so-called inheritance-based subscription). When an event of that type or any subtype is published, the handler will be  invoked if the associated <code>event_filter</code> returns <code>True</code> for that event  instance. A given handler can only be subscribed once per event type. If the handler is already subscribed to the given event type  \u2014regardless of the filter function\u2014 the subscription attempt is ignored and a warning is logged.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>type[Event]</code> <p>Type of the event to subscribe to, must be a subclass of <code>events.Base.Event</code>.</p> required <code>event_handler</code> <code>Callable[Event, None]</code> <p>Function to call when an  event of the given type is published. This callable must accept a single argument of type <code>events.Base.Event</code>  (or its subclass).</p> required <code>event_filter</code> <code>Callable[[Event], bool] | None</code> <p>Function to  determine whether to call the event handler for a given event. Should accept one event and return <code>True</code> to handle or <code>False</code> to  ignore. Defaults to <code>None</code>, which creates a filter that always returns <code>True</code>  (i.e. always call the event handler).</p> <code>None</code> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def subscribe(\n    self,\n    event_type: type[events.Base.Event],\n    event_handler: Callable[[events.Base.Event], None],\n    event_filter: Callable[[events.Base.Event], bool] | None = None,\n) -&gt; None:\n    \"\"\"\n    The `subscribe` method registers an event handler for event messages of a\n     specified type and all its subtypes (expressed as subclasses in the event\n      dataclass hierarchy, so-called inheritance-based subscription).\n    When an event of that type or any subtype is published, the handler will be\n     invoked if the associated `event_filter` returns `True` for that event\n     instance.\n    A given handler can only be subscribed once per event type.\n    If the handler is already subscribed to the given event type\n     \u2014regardless of the filter function\u2014\n    the subscription attempt is ignored and a warning is logged.\n\n    Arguments:\n        event_type (type[events.Base.Event]): Type of the event to subscribe to,\n         must be a subclass of `events.Base.Event`.\n        event_handler (Callable[events.Base.Event, None]): Function to call when an\n             event of the given type is published.\n            This callable must accept a single argument of type `events.Base.Event`\n             (or its subclass).\n        event_filter (Callable[[events.Base.Event], bool] | None): Function to\n             determine whether to call the event handler for a given event.\n            Should accept one event and return `True` to handle or `False` to\n             ignore.\n            Defaults to `None`, which creates a filter that always returns `True`\n             (i.e. always call the event handler).\n    \"\"\"\n\n    if not issubclass(event_type, events.Base.Event):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_type must be a subclass of \"\n            f\"Event, got {type(event_type).__name__}\"\n        )\n        return\n\n    if not callable(event_handler):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_handler must be callable, \"\n            f\"got {type(event_handler).__name__}\"\n        )\n        return\n\n    if event_filter is None:\n\n        def event_filter(event: events.Base.Event) -&gt; bool:\n            return True\n\n    if not callable(event_filter):\n        console.logger.error(\n            f\"Invalid subscription attempt: event_filter must be callable, \"\n            f\"got {type(event_filter).__name__}\"\n        )\n        return\n\n    is_valid, error_msg = self._validate_filter_signature(event_filter)\n    if not is_valid:\n        console.logger.error(f\"Invalid subscription attempt: {error_msg}\")\n        return\n\n    with self._lock:\n        if any(\n            event_handler == existing_handler\n            for existing_handler, _ in self._handlers[event_type]\n        ):\n            console.logger.warning(\n                f\"Duplicate subscription attempt: event_handler was already \"\n                f\"subscribed to {event_type.__name__}\"\n            )\n            return\n\n        self._handlers[event_type].append((event_handler, event_filter))\n\n        self._rebuild_cache()\n\n        handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n        console.logger.info(f\"Subscribed {handler_name} to {event_type.__name__}.\")\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(event_type, event_handler)</code>","text":"<p>The <code>unsubscribe</code> method removes an event handler from the subscribers list for  the specified event type. If the event handler is not subscribed to the given event type, the  unsubscription attempt is ignored and a warning is logged. After removing the event handler, the event type may have an empty subscribers  list but remains in the <code>subscribers</code> dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>type[Event]</code> <p>Type of the event to unsubscribe from,  must be a subclass of <code>events.Base.Event</code>.</p> required <code>event_handler</code> <code>Callable[Event, None]</code> <p>Event handler to remove  from the subscribers list (this will also remove the associated filter  function).</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def unsubscribe(\n    self,\n    event_type: type[events.Base.Event],\n    event_handler: Callable[[events.Base.Event], None],\n) -&gt; None:\n    \"\"\"\n    The `unsubscribe` method removes an event handler from the subscribers list for\n     the specified event type.\n    If the event handler is not subscribed to the given event type, the\n     unsubscription attempt is ignored and a warning is logged.\n    After removing the event handler, the event type may have an empty subscribers\n     list but remains in the `subscribers` dictionary.\n\n    Arguments:\n        event_type (type[events.Base.Event]): Type of the event to unsubscribe from,\n             must be a subclass of `events.Base.Event`.\n        event_handler (Callable[events.Base.Event, None]): Event handler to remove\n             from the subscribers list (this will also remove the associated filter\n             function).\n    \"\"\"\n    if not issubclass(event_type, events.Base.Event):\n        console.logger.error(\n            f\"Invalid unsubscription attempt: event_type must be a subclass of \"\n            f\"Event, got {type(event_type).__name__}\"\n        )\n        return\n\n    if not callable(event_handler):\n        console.logger.error(\n            f\"Invalid unsubscription attempt: callback must be callable, \"\n            f\"got {type(event_handler).__name__}\"\n        )\n        return\n\n    with self._lock:\n        if event_type not in self._handlers:\n            console.logger.warning(\n                f\"Attempted to unsubscribe from {event_type.__name__}, \"\n                f\"but no subscribers exist\"\n            )\n            return\n\n        current_handlers = self._handlers[event_type]\n        new_handlers = [\n            (existing_handler, existing_filter)\n            for existing_handler, existing_filter in current_handlers\n            if existing_handler != event_handler\n        ]\n\n        removed_count = len(current_handlers) - len(new_handlers)\n        if removed_count == 0:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.warning(\n                f\"Attempted to unsubscribe {handler_name} from \"\n                f\"{event_type.__name__}, but it was not subscribed\"\n            )\n            return\n\n        if new_handlers:\n            self._handlers[event_type] = new_handlers\n        else:\n            # Clean up empty lists\n            del self._handlers[event_type]\n\n        self._rebuild_cache()\n\n        handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n        console.logger.info(\n            f\"Unsubscribed {handler_name} from \"\n            f\"{event_type.__name__} (removed {removed_count} subscription(s))\"\n        )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"<p>The <code>publish</code> method delivers the event to all handlers subscribed to the  event's type or any of its parent types (inheritance-based subscription). Handlers are only called if their filter function returns True for this event. Handlers are called synchronously in the order they were subscribed.</p> <p>This method uses a pre-computed handler cache for O(1) lookup performance and runs without locks for maximum concurrency.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>Event to publish. Must be an instance of  <code>events.Base.Event</code> or one of its subclasses.</p> required Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def publish(self, event: events.Base.Event) -&gt; None:\n    \"\"\"\n    The `publish` method delivers the event to all handlers subscribed to the\n     event's type or any of its parent types (inheritance-based subscription).\n    Handlers are only called if their filter function returns True for this event.\n    Handlers are called synchronously in the order they were subscribed.\n\n    This method uses a pre-computed handler cache for O(1) lookup performance\n    and runs without locks for maximum concurrency.\n\n    Arguments:\n        event (events.Base.Event): Event to publish. Must be an instance of\n             `events.Base.Event` or one of its subclasses.\n    \"\"\"\n    if not isinstance(event, events.Base.Event):\n        console.logger.error(\n            f\"Invalid publish attempt: event must be an instance of Event, \"\n            f\"got {type(event).__name__}\"\n        )\n        return\n\n    object.__setattr__(\n        event, \"event_bus_sequence_number\", self._set_sequence_number()\n    )\n\n    event_type: type[events.Base.Event] = type(event)\n\n    handlers = self._publish_cache.get(event_type, [])\n\n    if not handlers:\n        console.logger.warning(\n            f\"Published {event_type.__name__} but no subscribers exist - \"\n            f\"check event wiring\"\n        )\n        return\n\n    delivered_count = 0\n    for event_handler, event_filter in handlers:\n        try:\n            should_handle = event_filter(event)\n\n            if not isinstance(should_handle, bool):\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.warning(\n                    f\"Filter for handler {handler_name} returned \"\n                    f\"{type(should_handle).__name__}, expected bool. \"\n                    f\"Treating as False.\"\n                )\n                should_handle = False\n\n        except TypeError as type_error:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            if \"takes\" in str(type_error) and \"positional argument\" in str(\n                type_error\n            ):\n                console.logger.error(\n                    f\"Filter for handler {handler_name} has wrong signature: \"\n                    f\"{type_error}\"\n                )\n            else:\n                console.logger.exception(\n                    f\"Filter function for handler {handler_name} failed \"\n                    f\"processing {event_type.__name__}: {type_error}\"\n                )\n            continue\n        except Exception as filter_exception:\n            handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n            console.logger.exception(\n                f\"Filter function for handler {handler_name} failed \"\n                f\"processing {event_type.__name__}: {filter_exception}\"\n            )\n            continue\n\n        if should_handle:\n            try:\n                event_handler(event)\n                delivered_count += 1\n            except Exception as handler_exception:\n                handler_name = getattr(event_handler, \"__name__\", \"&lt;lambda&gt;\")\n                console.logger.exception(\n                    f\"Handler {handler_name} failed processing \"\n                    f\"{event_type.__name__}: {handler_exception}\"\n                )\n\n    if delivered_count == 0:\n        console.logger.warning(\n            f\"Published {event_type.__name__} but no handlers received it - \"\n            f\"all {len(handlers)} handler(s) filtered out the event\"\n        )\n    else:\n        # Conditional debug logging to avoid string formatting overhead\n        if console.logger.isEnabledFor(logging.DEBUG):\n            console.logger.debug(\n                f\"Published {event_type.__name__} to {delivered_count} handler(s)\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._validate_filter_signature","title":"<code>_validate_filter_signature(event_filter)</code>  <code>staticmethod</code>","text":"<p>Validate that filter function has the correct signature.</p> <p>A valid filter function must: - Accept exactly 1 parameter (the event) - Not use args or *kwargs - Optionally return bool (if type annotated)</p> <p>Parameters:</p> Name Type Description Default <code>event_filter</code> <code>Callable</code> <p>The filter function to validate</p> required <p>Returns:</p> Type Description <code>tuple[bool, str | None]</code> <p>tuple[bool, str | None]: (is_valid, error_message) is_valid: True if signature is valid, False otherwise error_message: Description of the issue if invalid, None if valid</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>@staticmethod\ndef _validate_filter_signature(\n    event_filter: Callable[[events.Base.Event], bool],\n) -&gt; tuple[bool, str | None]:\n    \"\"\"\n    Validate that filter function has the correct signature.\n\n    A valid filter function must:\n    - Accept exactly 1 parameter (the event)\n    - Not use *args or **kwargs\n    - Optionally return bool (if type annotated)\n\n    Arguments:\n        event_filter (Callable): The filter function to validate\n\n    Returns:\n        tuple[bool, str | None]: (is_valid, error_message)\n            is_valid: True if signature is valid, False otherwise\n            error_message: Description of the issue if invalid, None if valid\n    \"\"\"\n    try:\n        sig = inspect.signature(event_filter)\n        params = list(sig.parameters.values())\n\n        if len(params) != 1:\n            return (\n                False,\n                f\"Filter must accept exactly 1 parameter, got {len(params)}\",\n            )\n\n        param = params[0]\n        if param.kind == inspect.Parameter.VAR_POSITIONAL:\n            return (\n                False,\n                \"Filter cannot use *args - must accept exactly 1 event parameter\",\n            )\n        if param.kind == inspect.Parameter.VAR_KEYWORD:\n            return (\n                False,\n                \"Filter cannot use **kwargs - must accept exactly 1 event \"\n                \"parameter\",\n            )\n\n        if sig.return_annotation is not inspect.Parameter.empty:\n            if sig.return_annotation is not bool:\n                return (\n                    False,\n                    f\"Filter return type should be bool, got \"\n                    f\"{sig.return_annotation}\",\n                )\n\n        return True, None\n\n    except Exception as e:\n        return False, f\"Could not inspect filter signature: {e}\"\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._set_sequence_number","title":"<code>_set_sequence_number()</code>","text":"<p>Increment and return the event bus sequence number in a thread-safe manner.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def _set_sequence_number(self) -&gt; int:\n    \"\"\"\n    Increment and return the event bus sequence number in a thread-safe manner.\n    \"\"\"\n    with self._lock:\n        self._sequence_number += 1\n        return self._sequence_number\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._get_all_concrete_event_types","title":"<code>_get_all_concrete_event_types()</code>  <code>staticmethod</code>","text":"<p>Dynamically discover all concrete event types from the events module. Automatically adapts to namespace changes without code modifications.</p> <p>Returns:</p> Type Description <code>list[type[Event]]</code> <p>list[type[events.Base.Event]]: List of concrete event classes that can be instantiated and published.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>@staticmethod\ndef _get_all_concrete_event_types() -&gt; list[type[events.Base.Event]]:\n    \"\"\"\n    Dynamically discover all concrete event types from the events module.\n    Automatically adapts to namespace changes without code modifications.\n\n    Returns:\n        list[type[events.Base.Event]]: List of concrete event classes that can be\n            instantiated and published.\n    \"\"\"\n    concrete_types = []\n\n    for attr_name in dir(events):\n        if attr_name.startswith(\"_\"):\n            continue\n\n        attr = getattr(events, attr_name)\n\n        if not inspect.isclass(attr) or attr_name == \"Base\":\n            continue\n\n        for member_name, member_obj in inspect.getmembers(attr, inspect.isclass):\n            if (\n                issubclass(member_obj, events.Base.Event)\n                and member_obj != events.Base.Event\n                and not inspect.isabstract(member_obj)\n            ):\n                concrete_types.append(member_obj)\n\n    return concrete_types\n</code></pre>"},{"location":"api-reference/messaging/eventbus/#onesecondtrader.messaging.eventbus.EventBus._rebuild_cache","title":"<code>_rebuild_cache()</code>","text":"<p>Rebuild the pre-computed publish cache for all concrete event types. This method should be called whenever subscriptions change.</p> Source code in <code>src/onesecondtrader/messaging/eventbus.py</code> <pre><code>def _rebuild_cache(self) -&gt; None:\n    \"\"\"\n    Rebuild the pre-computed publish cache for all concrete event types.\n    This method should be called whenever subscriptions change.\n    \"\"\"\n    new_cache = {}\n    concrete_event_types = self._get_all_concrete_event_types()\n\n    for concrete_event_type in concrete_event_types:\n        handlers = []\n        seen_handler_ids = set()\n\n        for handler_type, handler_list in self._handlers.items():\n            if issubclass(concrete_event_type, handler_type):\n                for handler, filter_func in handler_list:\n                    handler_id = id(handler)\n                    if handler_id not in seen_handler_ids:\n                        handlers.append((handler, filter_func))\n                        seen_handler_ids.add(handler_id)\n\n        if handlers:\n            new_cache[concrete_event_type] = handlers\n\n    self._publish_cache = new_cache\n\n    if console.logger.isEnabledFor(logging.DEBUG):\n        console.logger.debug(\n            f\"Publish cache rebuilt: {len(new_cache)} event types cached, \"\n            f\"total handlers: \"\n            f\"{sum(len(handlers) for handlers in new_cache.values())}\"\n        )\n</code></pre>"},{"location":"api-reference/messaging/events/","title":"Events","text":"<p>This module provides the event messages used for decoupled communication between the  trading infrastructure's components. Events are organized into namespaces (<code>Market</code>, <code>Request</code>, <code>Response</code>, and <code>System</code>)  to provide clear semantic groupings. Base event messages used for structure inheritance are grouped under the  <code>Base</code> namespace. Dataclass field validation logic is grouped under the <code>_Validate</code> namespace.</p> Module Overview: <code>events.py</code> <pre><code>---\nconfig:\n  themeVariables:\n    fontSize: \"11px\"\n---\ngraph LR\n\nR[events.Base.Event]\nR1[events.Base.Market]\nR2[events.Base.Request]\nR21[events.Base.OrderRequest]\nR22[events.Base.CancelRequest]\nR3[events.Base.Response]\nR4[events.Base.System]\n\nR --&gt; R1\nR --&gt; R2\nR --&gt; R3\nR --&gt; R4\n\nR2 --&gt; R21\nR2 --&gt; R22\n\nA1[events.Market.IncomingBar]\n\nR1 --&gt; A1\n\nstyle A1 fill:#6F42C1,fill-opacity:0.3\n\nB1[events.Request.MarketOrder]\nB2[events.Request.LimitOrder]\nB3[events.Request.StopOrder]\nB4[events.Request.StopLimitOrder]\nB5[events.Request.CancelOrder]\nB6[events.Request.FlushSymbol]\nB7[events.Request.FlushAll]\n\nR21 --&gt; B1\nR21 --&gt; B2\nR21 --&gt; B3\nR21 --&gt; B4\nR22 --&gt; B5\nR22 --&gt; B6\nR22 --&gt; B7\n\nstyle B1 fill:#6F42C1,fill-opacity:0.3\nstyle B2 fill:#6F42C1,fill-opacity:0.3\nstyle B3 fill:#6F42C1,fill-opacity:0.3\nstyle B4 fill:#6F42C1,fill-opacity:0.3\nstyle B5 fill:#6F42C1,fill-opacity:0.3\nstyle B6 fill:#6F42C1,fill-opacity:0.3\nstyle B7 fill:#6F42C1,fill-opacity:0.3\n\nC1[events.Response.OrderSubmitted]\nC2[events.Response.OrderFilled]\nC3[events.Response.OrderCancelled]\nC4[events.Response.OrderRejected]\n\nR3 --&gt; C1\nR3 --&gt; C2\nR3 --&gt; C3\nR3 --&gt; C4\n\nstyle C1 fill:#6F42C1,fill-opacity:0.3\nstyle C2 fill:#6F42C1,fill-opacity:0.3\nstyle C3 fill:#6F42C1,fill-opacity:0.3\nstyle C4 fill:#6F42C1,fill-opacity:0.3\n\nD1[events.System.Shutdown]\n\nR4 --&gt; D1\n\nstyle D1 fill:#6F42C1,fill-opacity:0.3\n\n\nsubgraph Market [\"Market Update Event Messages\"]\n    R1\n    A1\n\n    subgraph MarketNamespace [\"events.Market Namespace\"]\n        A1\n    end\n\nend\n\n\nsubgraph Request [\"Broker Request Event Messages\"]\n    R2\n    R21\n    R22\n    B1\n    B2\n    B3\n    B4\n    B5\n    B6\n    B7\n\n    subgraph RequestNamespace [\"events.Request Namespace\"]\n        B1\n        B2\n        B3\n        B4\n        B5\n        B6\n        B7\n    end\n\nend\n\nsubgraph Response [\"Broker Response Event Messages\"]\n    R3\n    C1\n    C2\n    C3\n    C4\n\n    subgraph ResponseNamespace [\"events.Response Namespace\"]\n        C1\n        C2\n        C3\n        C4\n    end\n\nend\n\nsubgraph System [\"System-Internal Event Messages\"]\n    R4\n    D1\n\n    subgraph SystemNamespace [\"events.System Namespace\"]\n        D1\n    end\n\nend</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base","title":"<code>Base</code>","text":"<p>Namespace for event base dataclasses.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Base:\n    \"\"\"\n    Namespace for event base dataclasses.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Event:\n        \"\"\"\n        Base event message dataclass.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            ts_event (pd.Timestamp): Timestamp of the event in pandas Timestamp format.\n                (Must be timezone-aware.)\n            event_bus_sequence_number (int | None): Auto-generated Sequence number of\n                 the event.\n                This will be assigned as soon as the event enters the event bus via\n                 `messaging.EventBus.publish(&lt;event&gt;)`.\n        \"\"\"\n\n        ts_event: pd.Timestamp\n        event_bus_sequence_number: int | None = dataclasses.field(\n            default=None, init=False\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Event:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            _Validate.timezone_aware(self.ts_event, \"ts_event\", \"Event\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Market(Event):\n        \"\"\"\n        Base event message dataclass for market events.\n        Inherits from `Base.Event`.\n        Each market event message is associated with a specific financial instrument via\n         the `symbol` field.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            symbol (str): Symbol of the financial instrument.\n        \"\"\"\n\n        symbol: str\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Market:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, \"Market event\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Request(Event):\n        \"\"\"\n        Base event message dataclass for broker requests.\n        This dataclass cannot be instantiated directly.\n        `ts_event` is auto-generated by default.\n\n        Attributes:\n            ts_event: Timestamp of the event. (defaults to current UTC time;\n                auto-generated)\n        \"\"\"\n\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Request:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderRequest(Request):\n        \"\"\"\n        Base event message dataclass for order requests.\n        Inherits from `Base.Request`.\n        This dataclass cannot be instantiated directly.\n\n        Attributes:\n            symbol (str): Symbol of the financial instrument.\n            side (models.Side): Side of the order.\n            quantity (float): Quantity of the order.\n            time_in_force (models.TimeInForce): Time in force of the order.\n            order_expiration (pd.Timestamp | None): Expiration timestamp of the order\n                (optional).\n                Only relevant if `time_in_force` is `models.TimeInForce.GTD`.\n            order_id (uuid.UUID): Unique ID of the order. (auto-generated)\n        \"\"\"\n\n        symbol: str\n        side: models.Side\n        quantity: float\n        time_in_force: models.TimeInForce\n        order_expiration: pd.Timestamp | None = None\n        order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.OrderRequest:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, f\"Order {self.order_id}\")\n\n            _Validate.timezone_aware(\n                self.order_expiration, \"order_expiration\", f\"Order {self.order_id}\"\n            )\n            _Validate.quantity(self.quantity, f\"Order {self.order_id}\")\n\n            if self.time_in_force.value == 4:\n                if self.order_expiration is None:\n                    console.logger.error(\n                        f\"Order {self.order_id}: GTD order missing expiration \"\n                        f\"timestamp.\"\n                    )\n                elif self.order_expiration &lt;= self.ts_event:\n                    console.logger.error(\n                        f\"Order {self.order_id}: GTD expiration \"\n                        f\"{self.order_expiration} \"\n                        f\"is not after event timestamp {self.ts_event}.\"\n                    )\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelRequest(Request):\n        \"\"\"\n        Base event message dataclass for order cancellation requests.\n        Inherits from `Base.Request`.\n        This dataclass cannot be instantiated directly.\n        \"\"\"\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.CancelRequest:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Response(Event):\n        \"\"\"\n        Base event message dataclass for broker responses.\n        This dataclass cannot be instantiated directly.\n        \"\"\"\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.Response:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class System(Event):\n        \"\"\"\n        Base event message dataclass for system-internal messages.\n        This dataclass cannot be instantiated directly.\n        `ts_event` is auto-generated by default.\n\n        Attributes:\n            ts_event: Timestamp of the event. (defaults to current UTC time;\n                auto-generated)\n        \"\"\"\n\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n        def __new__(cls, *args, **kwargs):\n            if cls is Base.System:\n                console.logger.error(\n                    f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n                )\n            return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>Base event message dataclass. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event in pandas Timestamp format. (Must be timezone-aware.)</p> <code>event_bus_sequence_number</code> <code>int | None</code> <p>Auto-generated Sequence number of  the event. This will be assigned as soon as the event enters the event bus via  <code>messaging.EventBus.publish(&lt;event&gt;)</code>.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Event:\n    \"\"\"\n    Base event message dataclass.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        ts_event (pd.Timestamp): Timestamp of the event in pandas Timestamp format.\n            (Must be timezone-aware.)\n        event_bus_sequence_number (int | None): Auto-generated Sequence number of\n             the event.\n            This will be assigned as soon as the event enters the event bus via\n             `messaging.EventBus.publish(&lt;event&gt;)`.\n    \"\"\"\n\n    ts_event: pd.Timestamp\n    event_bus_sequence_number: int | None = dataclasses.field(\n        default=None, init=False\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Event:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        _Validate.timezone_aware(self.ts_event, \"ts_event\", \"Event\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Market","title":"<code>Market</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for market events. Inherits from <code>Base.Event</code>. Each market event message is associated with a specific financial instrument via  the <code>symbol</code> field. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol of the financial instrument.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Market(Event):\n    \"\"\"\n    Base event message dataclass for market events.\n    Inherits from `Base.Event`.\n    Each market event message is associated with a specific financial instrument via\n     the `symbol` field.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        symbol (str): Symbol of the financial instrument.\n    \"\"\"\n\n    symbol: str\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Market:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, \"Market event\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for broker requests. This dataclass cannot be instantiated directly. <code>ts_event</code> is auto-generated by default.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event. (defaults to current UTC time; auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Request(Event):\n    \"\"\"\n    Base event message dataclass for broker requests.\n    This dataclass cannot be instantiated directly.\n    `ts_event` is auto-generated by default.\n\n    Attributes:\n        ts_event: Timestamp of the event. (defaults to current UTC time;\n            auto-generated)\n    \"\"\"\n\n    ts_event: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Request:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.OrderRequest","title":"<code>OrderRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Base event message dataclass for order requests. Inherits from <code>Base.Request</code>. This dataclass cannot be instantiated directly.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol of the financial instrument.</p> <code>side</code> <code>Side</code> <p>Side of the order.</p> <code>quantity</code> <code>float</code> <p>Quantity of the order.</p> <code>time_in_force</code> <code>TimeInForce</code> <p>Time in force of the order.</p> <code>order_expiration</code> <code>Timestamp | None</code> <p>Expiration timestamp of the order (optional). Only relevant if <code>time_in_force</code> is <code>models.TimeInForce.GTD</code>.</p> <code>order_id</code> <code>UUID</code> <p>Unique ID of the order. (auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderRequest(Request):\n    \"\"\"\n    Base event message dataclass for order requests.\n    Inherits from `Base.Request`.\n    This dataclass cannot be instantiated directly.\n\n    Attributes:\n        symbol (str): Symbol of the financial instrument.\n        side (models.Side): Side of the order.\n        quantity (float): Quantity of the order.\n        time_in_force (models.TimeInForce): Time in force of the order.\n        order_expiration (pd.Timestamp | None): Expiration timestamp of the order\n            (optional).\n            Only relevant if `time_in_force` is `models.TimeInForce.GTD`.\n        order_id (uuid.UUID): Unique ID of the order. (auto-generated)\n    \"\"\"\n\n    symbol: str\n    side: models.Side\n    quantity: float\n    time_in_force: models.TimeInForce\n    order_expiration: pd.Timestamp | None = None\n    order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.OrderRequest:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, f\"Order {self.order_id}\")\n\n        _Validate.timezone_aware(\n            self.order_expiration, \"order_expiration\", f\"Order {self.order_id}\"\n        )\n        _Validate.quantity(self.quantity, f\"Order {self.order_id}\")\n\n        if self.time_in_force.value == 4:\n            if self.order_expiration is None:\n                console.logger.error(\n                    f\"Order {self.order_id}: GTD order missing expiration \"\n                    f\"timestamp.\"\n                )\n            elif self.order_expiration &lt;= self.ts_event:\n                console.logger.error(\n                    f\"Order {self.order_id}: GTD expiration \"\n                    f\"{self.order_expiration} \"\n                    f\"is not after event timestamp {self.ts_event}.\"\n                )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.CancelRequest","title":"<code>CancelRequest</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Base event message dataclass for order cancellation requests. Inherits from <code>Base.Request</code>. This dataclass cannot be instantiated directly.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass CancelRequest(Request):\n    \"\"\"\n    Base event message dataclass for order cancellation requests.\n    Inherits from `Base.Request`.\n    This dataclass cannot be instantiated directly.\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.CancelRequest:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.Response","title":"<code>Response</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for broker responses. This dataclass cannot be instantiated directly.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Response(Event):\n    \"\"\"\n    Base event message dataclass for broker responses.\n    This dataclass cannot be instantiated directly.\n    \"\"\"\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.Response:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Base.System","title":"<code>System</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Event</code></p> <p>Base event message dataclass for system-internal messages. This dataclass cannot be instantiated directly. <code>ts_event</code> is auto-generated by default.</p> <p>Attributes:</p> Name Type Description <code>ts_event</code> <code>Timestamp</code> <p>Timestamp of the event. (defaults to current UTC time; auto-generated)</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass System(Event):\n    \"\"\"\n    Base event message dataclass for system-internal messages.\n    This dataclass cannot be instantiated directly.\n    `ts_event` is auto-generated by default.\n\n    Attributes:\n        ts_event: Timestamp of the event. (defaults to current UTC time;\n            auto-generated)\n    \"\"\"\n\n    ts_event: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n\n    def __new__(cls, *args, **kwargs):\n        if cls is Base.System:\n            console.logger.error(\n                f\"Cannot instantiate abstract class '{cls.__name__}' directly\"\n            )\n        return super().__new__(cls)\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Market","title":"<code>Market</code>","text":"<p>Namespace for market update event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Market:\n    \"\"\"\n    Namespace for market update event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class IncomingBar(Base.Market):\n        \"\"\"\n        Event message dataclass for incoming market data bars.\n        Inherits from `Base.Market`.\n\n        Attributes:\n            bar (models.Bar): Bar of market data.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; event = events.Market.IncomingBar(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     symbol=\"AAPL\",\n            ...     bar=models.Bar(\n            ...         open=100.0,\n            ...         high=101.0,\n            ...         low=99.0,\n            ...         close=100.5,\n            ...         volume=10000,\n            ...     ),\n            ... )\n            ```\n        \"\"\"\n\n        bar: models.Bar\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Market.IncomingBar","title":"<code>IncomingBar</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Market</code></p> <p>Event message dataclass for incoming market data bars. Inherits from <code>Base.Market</code>.</p> <p>Attributes:</p> Name Type Description <code>bar</code> <code>Bar</code> <p>Bar of market data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; event = events.Market.IncomingBar(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     symbol=\"AAPL\",\n...     bar=models.Bar(\n...         open=100.0,\n...         high=101.0,\n...         low=99.0,\n...         close=100.5,\n...         volume=10000,\n...     ),\n... )\n```\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass IncomingBar(Base.Market):\n    \"\"\"\n    Event message dataclass for incoming market data bars.\n    Inherits from `Base.Market`.\n\n    Attributes:\n        bar (models.Bar): Bar of market data.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; event = events.Market.IncomingBar(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     symbol=\"AAPL\",\n        ...     bar=models.Bar(\n        ...         open=100.0,\n        ...         high=101.0,\n        ...         low=99.0,\n        ...         close=100.5,\n        ...         volume=10000,\n        ...     ),\n        ... )\n        ```\n    \"\"\"\n\n    bar: models.Bar\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request","title":"<code>Request</code>","text":"<p>Namespace for broker request event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Request:\n    \"\"\"\n    Namespace for broker request event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class MarketOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a market order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.MARKET).\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.MarketOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.MARKET\n        )\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class LimitOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a limit order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.LIMIT).\n            limit_price (float): Limit price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.LimitOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     limit_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.LIMIT\n        )\n        limit_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class StopOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a stop order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.STOP).\n            stop_price (float): Stop price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.StopOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     stop_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.STOP\n        )\n        stop_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class StopLimitOrder(Base.OrderRequest):\n        \"\"\"\n        Event message dataclass for submitting a stop-limit order to the broker.\n\n        Attributes:\n            order_type (models.OrderType): Type of the order (automatically set to\n            models.OrderType.STOP_LIMIT).\n            stop_price (float): Stop price of the order.\n            limit_price (float): Limit price of the order.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.StopLimitOrder(\n            ...     symbol=\"AAPL\",\n            ...     side=models.Side.BUY,\n            ...     quantity=100.0,\n            ...     time_in_force=models.TimeInForce.DAY,\n            ...     stop_price=100.0,\n            ...     limit_price=100.0,\n            ... )\n        \"\"\"\n\n        order_type: models.OrderType = dataclasses.field(\n            init=False, default=models.OrderType.STOP_LIMIT\n        )\n        stop_price: float\n        limit_price: float\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelOrder(Base.CancelRequest):\n        \"\"\"\n        Event message dataclass for cancelling an order.\n\n        Attributes:\n            order_id (uuid.UUID): Unique ID of the order to cancel.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.CancelOrder(\n            ...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n            ... )\n        \"\"\"\n\n        order_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class FlushSymbol(Base.Request):\n        \"\"\"\n        Event message dataclass for flushing all orders for a symbol.\n\n        Attributes:\n            symbol (str): Symbol to flush.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.FlushSymbol(\n            ...     symbol=\"AAPL\",\n            ... )\n        \"\"\"\n\n        symbol: str\n\n        def __post_init__(self) -&gt; None:\n            super().__post_init__()\n            _Validate.symbol(self.symbol, \"Flush request\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class FlushAll(Base.Request):\n        \"\"\"\n        Event message dataclass for flushing all orders for all symbols.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.Request.FlushAll()\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.MarketOrder","title":"<code>MarketOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a market order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.MarketOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass MarketOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a market order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.MARKET).\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.MarketOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.MARKET\n    )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.LimitOrder","title":"<code>LimitOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a limit order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>limit_price</code> <code>float</code> <p>Limit price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.LimitOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     limit_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass LimitOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a limit order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.LIMIT).\n        limit_price (float): Limit price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.LimitOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     limit_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.LIMIT\n    )\n    limit_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.StopOrder","title":"<code>StopOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a stop order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>stop_price</code> <code>float</code> <p>Stop price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.StopOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     stop_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass StopOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a stop order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.STOP).\n        stop_price (float): Stop price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.StopOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     stop_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.STOP\n    )\n    stop_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.StopLimitOrder","title":"<code>StopLimitOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>OrderRequest</code></p> <p>Event message dataclass for submitting a stop-limit order to the broker.</p> <p>Attributes:</p> Name Type Description <code>order_type</code> <code>OrderType</code> <p>Type of the order (automatically set to</p> <code>stop_price</code> <code>float</code> <p>Stop price of the order.</p> <code>limit_price</code> <code>float</code> <p>Limit price of the order.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.StopLimitOrder(\n...     symbol=\"AAPL\",\n...     side=models.Side.BUY,\n...     quantity=100.0,\n...     time_in_force=models.TimeInForce.DAY,\n...     stop_price=100.0,\n...     limit_price=100.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass StopLimitOrder(Base.OrderRequest):\n    \"\"\"\n    Event message dataclass for submitting a stop-limit order to the broker.\n\n    Attributes:\n        order_type (models.OrderType): Type of the order (automatically set to\n        models.OrderType.STOP_LIMIT).\n        stop_price (float): Stop price of the order.\n        limit_price (float): Limit price of the order.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.StopLimitOrder(\n        ...     symbol=\"AAPL\",\n        ...     side=models.Side.BUY,\n        ...     quantity=100.0,\n        ...     time_in_force=models.TimeInForce.DAY,\n        ...     stop_price=100.0,\n        ...     limit_price=100.0,\n        ... )\n    \"\"\"\n\n    order_type: models.OrderType = dataclasses.field(\n        init=False, default=models.OrderType.STOP_LIMIT\n    )\n    stop_price: float\n    limit_price: float\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.CancelOrder","title":"<code>CancelOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CancelRequest</code></p> <p>Event message dataclass for cancelling an order.</p> <p>Attributes:</p> Name Type Description <code>order_id</code> <code>UUID</code> <p>Unique ID of the order to cancel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.CancelOrder(\n...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass CancelOrder(Base.CancelRequest):\n    \"\"\"\n    Event message dataclass for cancelling an order.\n\n    Attributes:\n        order_id (uuid.UUID): Unique ID of the order to cancel.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.CancelOrder(\n        ...     order_id=uuid.UUID(\"12345678-1234-5678-1234-567812345678\"),\n        ... )\n    \"\"\"\n\n    order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.FlushSymbol","title":"<code>FlushSymbol</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Event message dataclass for flushing all orders for a symbol.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>Symbol to flush.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.FlushSymbol(\n...     symbol=\"AAPL\",\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass FlushSymbol(Base.Request):\n    \"\"\"\n    Event message dataclass for flushing all orders for a symbol.\n\n    Attributes:\n        symbol (str): Symbol to flush.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.FlushSymbol(\n        ...     symbol=\"AAPL\",\n        ... )\n    \"\"\"\n\n    symbol: str\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        _Validate.symbol(self.symbol, \"Flush request\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Request.FlushAll","title":"<code>FlushAll</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Request</code></p> <p>Event message dataclass for flushing all orders for all symbols.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.Request.FlushAll()\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass FlushAll(Base.Request):\n    \"\"\"\n    Event message dataclass for flushing all orders for all symbols.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.Request.FlushAll()\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response","title":"<code>Response</code>","text":"<p>Namespace for broker response event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class Response:\n    \"\"\"\n    Namespace for broker response event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderSubmitted(Base.Response):\n        \"\"\"\n        Event message dataclass for order submission confirmation from the broker.\n\n        Attributes:\n            order_submitted_id (uuid.UUID): Unique ID of the submitted order.\n            associated_request_id (uuid.UUID): Unique ID of the request that triggered\n                the order submission.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderSubmitted(\n            ...     ts_event=pd.Timestamp(\n            ...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"),\n            ...     associated_request_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ... )\n        \"\"\"\n\n        order_submitted_id: uuid.UUID\n        associated_request_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderFilled(Base.Response):\n        \"\"\"\n        Event message dataclass for order fill confirmation from the broker.\n\n        Attributes:\n            fill_id (uuid.UUID): Unique ID of the fill. (auto-generated)\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that triggered the fill.\n            side (models.Side): Side of the fill.\n            quantity_filled (float): Quantity filled.\n            filled_at_price (float): Price at which the fill was executed.\n            commission_and_fees (float): Commission and fees for the fill.\n            net_fill_value (float): Net fill value (auto-generated).\n            exchange (str | None): Exchange on which the fill was executed. (optional;\n                defaults to \"SIMULATED\")\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderFilled(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ...     side=models.Side.BUY,\n            ...     quantity_filled=100.0,\n            ...     filled_at_price=100.0,\n            ...     commission_and_fees=1.0,\n            ... )\n        \"\"\"\n\n        fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n        associated_order_submitted_id: uuid.UUID\n        side: models.Side\n        quantity_filled: float\n        filled_at_price: float\n        commission_and_fees: float\n        net_fill_value: float = dataclasses.field(init=False)\n        exchange: str | None = None\n\n        def __post_init__(self):\n            object.__setattr__(self, \"fill_id\", self.fill_id or uuid.uuid4())\n\n            gross_value = self.filled_at_price * self.quantity_filled\n\n            if self.side.value == 1:\n                net_value = gross_value + self.commission_and_fees\n            else:\n                net_value = gross_value - self.commission_and_fees\n\n            object.__setattr__(self, \"net_fill_value\", net_value)\n\n            object.__setattr__(self, \"exchange\", self.exchange or \"SIMULATED\")\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderCancelled(Base.Response):\n        \"\"\"\n        Event message dataclass for order cancellation confirmation from the broker.\n\n        Attributes:\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that was cancelled.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderCancelled(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ... )\n        \"\"\"\n\n        associated_order_submitted_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderRejected(Base.Response):\n        \"\"\"\n        Event message dataclass for order rejection confirmation from the broker.\n\n        Attributes:\n            associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n                that was rejected.\n            reason (models.OrderRejectionReason): Reason for the rejection.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; from onesecondtrader.core import models\n            &gt;&gt;&gt; import pandas as pd\n            &gt;&gt;&gt; import uuid\n            &gt;&gt;&gt; event = events.Response.OrderRejected(\n            ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n            ...     associated_order_submitted_id=uuid.UUID(\n            ...         \"12345678-1234-5678-1234-567812345678\"\n            ...     ),\n            ...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n            ... )\n        \"\"\"\n\n        associated_order_submitted_id: uuid.UUID\n        reason: models.OrderRejectionReason\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderSubmitted","title":"<code>OrderSubmitted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order submission confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order.</p> <code>associated_request_id</code> <code>UUID</code> <p>Unique ID of the request that triggered the order submission.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderSubmitted(\n...     ts_event=pd.Timestamp(\n...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"),\n...     associated_request_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderSubmitted(Base.Response):\n    \"\"\"\n    Event message dataclass for order submission confirmation from the broker.\n\n    Attributes:\n        order_submitted_id (uuid.UUID): Unique ID of the submitted order.\n        associated_request_id (uuid.UUID): Unique ID of the request that triggered\n            the order submission.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderSubmitted(\n        ...     ts_event=pd.Timestamp(\n        ...         \"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"),\n        ...     associated_request_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ... )\n    \"\"\"\n\n    order_submitted_id: uuid.UUID\n    associated_request_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderFilled","title":"<code>OrderFilled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order fill confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>fill_id</code> <code>UUID</code> <p>Unique ID of the fill. (auto-generated)</p> <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that triggered the fill.</p> <code>side</code> <code>Side</code> <p>Side of the fill.</p> <code>quantity_filled</code> <code>float</code> <p>Quantity filled.</p> <code>filled_at_price</code> <code>float</code> <p>Price at which the fill was executed.</p> <code>commission_and_fees</code> <code>float</code> <p>Commission and fees for the fill.</p> <code>net_fill_value</code> <code>float</code> <p>Net fill value (auto-generated).</p> <code>exchange</code> <code>str | None</code> <p>Exchange on which the fill was executed. (optional; defaults to \"SIMULATED\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderFilled(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n...     side=models.Side.BUY,\n...     quantity_filled=100.0,\n...     filled_at_price=100.0,\n...     commission_and_fees=1.0,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderFilled(Base.Response):\n    \"\"\"\n    Event message dataclass for order fill confirmation from the broker.\n\n    Attributes:\n        fill_id (uuid.UUID): Unique ID of the fill. (auto-generated)\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that triggered the fill.\n        side (models.Side): Side of the fill.\n        quantity_filled (float): Quantity filled.\n        filled_at_price (float): Price at which the fill was executed.\n        commission_and_fees (float): Commission and fees for the fill.\n        net_fill_value (float): Net fill value (auto-generated).\n        exchange (str | None): Exchange on which the fill was executed. (optional;\n            defaults to \"SIMULATED\")\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderFilled(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ...     side=models.Side.BUY,\n        ...     quantity_filled=100.0,\n        ...     filled_at_price=100.0,\n        ...     commission_and_fees=1.0,\n        ... )\n    \"\"\"\n\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    associated_order_submitted_id: uuid.UUID\n    side: models.Side\n    quantity_filled: float\n    filled_at_price: float\n    commission_and_fees: float\n    net_fill_value: float = dataclasses.field(init=False)\n    exchange: str | None = None\n\n    def __post_init__(self):\n        object.__setattr__(self, \"fill_id\", self.fill_id or uuid.uuid4())\n\n        gross_value = self.filled_at_price * self.quantity_filled\n\n        if self.side.value == 1:\n            net_value = gross_value + self.commission_and_fees\n        else:\n            net_value = gross_value - self.commission_and_fees\n\n        object.__setattr__(self, \"net_fill_value\", net_value)\n\n        object.__setattr__(self, \"exchange\", self.exchange or \"SIMULATED\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderCancelled","title":"<code>OrderCancelled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order cancellation confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that was cancelled.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderCancelled(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderCancelled(Base.Response):\n    \"\"\"\n    Event message dataclass for order cancellation confirmation from the broker.\n\n    Attributes:\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that was cancelled.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderCancelled(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ... )\n    \"\"\"\n\n    associated_order_submitted_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.Response.OrderRejected","title":"<code>OrderRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code></p> <p>Event message dataclass for order rejection confirmation from the broker.</p> <p>Attributes:</p> Name Type Description <code>associated_order_submitted_id</code> <code>UUID</code> <p>Unique ID of the submitted order that was rejected.</p> <code>reason</code> <code>OrderRejectionReason</code> <p>Reason for the rejection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; from onesecondtrader.core import models\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; event = events.Response.OrderRejected(\n...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n...     associated_order_submitted_id=uuid.UUID(\n...         \"12345678-1234-5678-1234-567812345678\"\n...     ),\n...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n... )\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderRejected(Base.Response):\n    \"\"\"\n    Event message dataclass for order rejection confirmation from the broker.\n\n    Attributes:\n        associated_order_submitted_id (uuid.UUID): Unique ID of the submitted order\n            that was rejected.\n        reason (models.OrderRejectionReason): Reason for the rejection.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; from onesecondtrader.core import models\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; event = events.Response.OrderRejected(\n        ...     ts_event=pd.Timestamp(\"2023-01-01 00:00:00\", tz=\"UTC\"),\n        ...     associated_order_submitted_id=uuid.UUID(\n        ...         \"12345678-1234-5678-1234-567812345678\"\n        ...     ),\n        ...     reason=models.OrderRejectionReason.NEGATIVE_QUANTITY,\n        ... )\n    \"\"\"\n\n    associated_order_submitted_id: uuid.UUID\n    reason: models.OrderRejectionReason\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.System","title":"<code>System</code>","text":"<p>Namespace for system-internal event messages.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class System:\n    \"\"\"\n    Namespace for system-internal event messages.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Shutdown(Base.System):\n        \"\"\"\n        Event message dataclass for system shutdown.\n\n        Examples:\n            &gt;&gt;&gt; from onesecondtrader.messaging import events\n            &gt;&gt;&gt; event = events.System.Shutdown()\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events.System.Shutdown","title":"<code>Shutdown</code>  <code>dataclass</code>","text":"<p>               Bases: <code>System</code></p> <p>Event message dataclass for system shutdown.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from onesecondtrader.messaging import events\n&gt;&gt;&gt; event = events.System.Shutdown()\n</code></pre> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass Shutdown(Base.System):\n    \"\"\"\n    Event message dataclass for system shutdown.\n\n    Examples:\n        &gt;&gt;&gt; from onesecondtrader.messaging import events\n        &gt;&gt;&gt; event = events.System.Shutdown()\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate","title":"<code>_Validate</code>","text":"<p>Internal validation utilities for events.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>class _Validate:\n    \"\"\"Internal validation utilities for events.\"\"\"\n\n    @staticmethod\n    def symbol(symbol: str, context: str = \"\") -&gt; None:\n        \"\"\"Validate symbol format and log errors.\"\"\"\n        if not symbol or not symbol.strip():\n            console.logger.error(f\"{context}: Symbol cannot be empty or whitespace\")\n            return\n\n        if not re.fullmatch(r\"[A-Z0-9._-]+\", symbol):\n            console.logger.error(f\"{context}: Invalid symbol format: {symbol}\")\n\n    @staticmethod\n    def quantity(quantity: float, context: str = \"\") -&gt; None:\n        \"\"\"Validate quantity values and log errors.\"\"\"\n        if (\n            quantity != quantity\n            or quantity == float(\"inf\")\n            or quantity == float(\"-inf\")\n        ):\n            console.logger.error(f\"{context}: quantity cannot be NaN or infinite\")\n            return\n\n        if quantity &lt;= 0:\n            console.logger.error(\n                f\"{context}: quantity must be positive, got {quantity}\"\n            )\n\n        if quantity &gt; 1e9:\n            console.logger.error(f\"{context}: quantity too large: {quantity}\")\n\n    @staticmethod\n    def timezone_aware(\n        timestamp: pd.Timestamp | None, field_name: str, context: str = \"\"\n    ) -&gt; None:\n        \"\"\"Validate that timestamp is timezone-aware and log errors.\"\"\"\n        if timestamp is not None and timestamp.tz is None:\n            console.logger.error(\n                f\"{context}: {field_name} must be timezone-aware, got {timestamp}\"\n            )\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.symbol","title":"<code>symbol(symbol, context='')</code>  <code>staticmethod</code>","text":"<p>Validate symbol format and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef symbol(symbol: str, context: str = \"\") -&gt; None:\n    \"\"\"Validate symbol format and log errors.\"\"\"\n    if not symbol or not symbol.strip():\n        console.logger.error(f\"{context}: Symbol cannot be empty or whitespace\")\n        return\n\n    if not re.fullmatch(r\"[A-Z0-9._-]+\", symbol):\n        console.logger.error(f\"{context}: Invalid symbol format: {symbol}\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.quantity","title":"<code>quantity(quantity, context='')</code>  <code>staticmethod</code>","text":"<p>Validate quantity values and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef quantity(quantity: float, context: str = \"\") -&gt; None:\n    \"\"\"Validate quantity values and log errors.\"\"\"\n    if (\n        quantity != quantity\n        or quantity == float(\"inf\")\n        or quantity == float(\"-inf\")\n    ):\n        console.logger.error(f\"{context}: quantity cannot be NaN or infinite\")\n        return\n\n    if quantity &lt;= 0:\n        console.logger.error(\n            f\"{context}: quantity must be positive, got {quantity}\"\n        )\n\n    if quantity &gt; 1e9:\n        console.logger.error(f\"{context}: quantity too large: {quantity}\")\n</code></pre>"},{"location":"api-reference/messaging/events/#onesecondtrader.messaging.events._Validate.timezone_aware","title":"<code>timezone_aware(timestamp, field_name, context='')</code>  <code>staticmethod</code>","text":"<p>Validate that timestamp is timezone-aware and log errors.</p> Source code in <code>src/onesecondtrader/messaging/events.py</code> <pre><code>@staticmethod\ndef timezone_aware(\n    timestamp: pd.Timestamp | None, field_name: str, context: str = \"\"\n) -&gt; None:\n    \"\"\"Validate that timestamp is timezone-aware and log errors.\"\"\"\n    if timestamp is not None and timestamp.tz is None:\n        console.logger.error(\n            f\"{context}: {field_name} must be timezone-aware, got {timestamp}\"\n        )\n</code></pre>"},{"location":"api-reference/monitoring/console/","title":"Console","text":"<p>Console logging utilities for OneSecondTrader.</p> <p>Simple console logging configuration for terminal output.</p> Source code in <code>console.py</code> <pre><code>\"\"\"Console logging utilities for OneSecondTrader.\n\nSimple console logging configuration for terminal output.\n\"\"\"\n\nimport logging\n\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format=\"%(asctime)s - %(levelname)s - %(threadName)s - %(message)s\",\n)\n\nlogger = logging.getLogger(\"onesecondtrader\")\n</code></pre>"},{"location":"documentation/architecture/","title":"Package Architecture","text":""},{"location":"documentation/architecture/#event-driven-paradigm","title":"Event-Driven Paradigm","text":"<p>OneSecondTrader is designed as an event-driven system, with an event bus managing  communication between decoupled system components via a publish-subscribe messaging  pattern based on standardized event messages.</p>"},{"location":"documentation/backtesting/","title":"Strategy Backtesting","text":""},{"location":"documentation/overview/","title":"Package Documentation","text":"<ul> <li> <p> Package Architecture </p> <p> Read Architecture Documentation Page</p> </li> </ul>"},{"location":"documentation/trading/","title":"Live Trading","text":""}]}