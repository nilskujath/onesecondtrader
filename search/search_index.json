{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Step 1: Install package</p> pippoetry <pre><code>pip install onesecondtrader \n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre> <p>Step 2: Define strategy</p> <pre><code>from onesecondtrader.strategies import StrategyBase\nfrom onesecondtrader.indicators import SimpleMovingAverage\nfrom onesecondtrader.models import OrderType, OrderSide\nfrom onesecondtrader.events import BarReceived\n\n\nclass MySMACrossover(StrategyBase):\n    def setup(self) -&gt; None:\n        self.fast_sma = self.add_indicator(SimpleMovingAverage(period=20))\n        self.slow_sma = self.add_indicator(SimpleMovingAverage(period=100))\n\n    def on_bar(self, event: BarReceived) -&gt; None:\n        if (\n            self.fast_sma[-2] &lt;= self.slow_sma[-2]\n            and self.fast_sma.latest &gt; self.slow_sma.latest\n            and self.position &lt;= 0\n        ):\n            self.submit_order(OrderType.MARKET, OrderSide.BUY, 1.0)\n\n        if (\n            self.fast_sma[-2] &gt;= self.slow_sma[-2]\n            and self.fast_sma.latest &lt; self.slow_sma.latest\n            and self.position &gt;= 0\n        ):\n            self.submit_order(OrderType.MARKET, OrderSide.SELL, 1.0)\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Connectors </p> <p> View <code>connectors</code> package API</p> </li> <li> <p>Core </p> <p> View <code>core</code> package API</p> </li> <li> <p>Secmaster </p> <p> View <code>secmaster</code> package API</p> </li> </ul>"},{"location":"api-reference/connectors/brokers/simulated/","title":"Simulated","text":""},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated._PendingOrder","title":"<code>_PendingOrder</code>  <code>dataclass</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>@dataclasses.dataclass\nclass _PendingOrder:\n    # Order state tracked by the broker, distinct from the OrderSubmission event\n    order_id: uuid.UUID\n    symbol: str\n    order_type: models.OrderType\n    side: models.OrderSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker","title":"<code>SimulatedBroker</code>","text":"<p>               Bases: <code>BrokerBase</code></p>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    self._pending_market_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_orders: dict[uuid.UUID, _PendingOrder] = {}\n    self._pending_stop_limit_orders: dict[uuid.UUID, _PendingOrder] = {}\n\n    super().__init__(event_bus)\n    self._subscribe(events.BarReceived)\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._on_event","title":"<code>_on_event(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    match event:\n        case events.BarReceived() as bar:\n            self._on_bar(bar)\n        case _:\n            super()._on_event(event)\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._on_bar","title":"<code>_on_bar(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _on_bar(self, event: events.BarReceived) -&gt; None:\n    self._process_market_orders(event)\n    self._process_stop_orders(event)\n    self._process_stop_limit_orders(event)\n    self._process_limit_orders(event)\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._process_market_orders","title":"<code>_process_market_orders(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _process_market_orders(self, event: events.BarReceived) -&gt; None:\n    for order_id, order in list(self._pending_market_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        self._publish(\n            events.OrderFilled(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=event.open,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_market_orders[order_id]\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._process_stop_orders","title":"<code>_process_stop_orders(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _process_stop_orders(self, event: events.BarReceived) -&gt; None:\n    for order_id, order in list(self._pending_stop_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        # This is for mypy, it has already been validated on submission\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.OrderSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.OrderSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.OrderSide.BUY:\n                fill_price = max(order.stop_price, event.open)\n            case models.OrderSide.SELL:\n                fill_price = min(order.stop_price, event.open)\n\n        self._publish(\n            events.OrderFilled(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_stop_orders[order_id]\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._process_stop_limit_orders","title":"<code>_process_stop_limit_orders(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _process_stop_limit_orders(self, event: events.BarReceived) -&gt; None:\n    for order_id, order in list(self._pending_stop_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        # This is for mypy, it has already been validated on submission\n        assert order.stop_price is not None\n\n        triggered = False\n        match order.side:\n            case models.OrderSide.BUY:\n                triggered = event.high &gt;= order.stop_price\n            case models.OrderSide.SELL:\n                triggered = event.low &lt;= order.stop_price\n\n        if not triggered:\n            continue\n\n        limit_order = dataclasses.replace(order, order_type=models.OrderType.LIMIT)\n        self._pending_limit_orders[order_id] = limit_order\n        del self._pending_stop_limit_orders[order_id]\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._process_limit_orders","title":"<code>_process_limit_orders(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _process_limit_orders(self, event: events.BarReceived) -&gt; None:\n    for order_id, order in list(self._pending_limit_orders.items()):\n        if order.symbol != event.symbol:\n            continue\n\n        # This is for mypy, it has already been validated on submission\n        assert order.limit_price is not None\n\n        triggered = False\n        match order.side:\n            case models.OrderSide.BUY:\n                triggered = event.low &lt;= order.limit_price\n            case models.OrderSide.SELL:\n                triggered = event.high &gt;= order.limit_price\n\n        if not triggered:\n            continue\n\n        fill_price = 0.0\n        match order.side:\n            case models.OrderSide.BUY:\n                fill_price = min(order.limit_price, event.open)\n            case models.OrderSide.SELL:\n                fill_price = max(order.limit_price, event.open)\n\n        self._publish(\n            events.OrderFilled(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=order.order_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity_filled=order.quantity,\n                fill_price=fill_price,\n                commission=max(\n                    order.quantity * self.commission_per_unit,\n                    self.minimum_commission_per_order,\n                ),\n            )\n        )\n        del self._pending_limit_orders[order_id]\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._reject_if_invalid_submission","title":"<code>_reject_if_invalid_submission(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_submission(self, event: events.OrderSubmission) -&gt; bool:\n    is_invalid = event.quantity &lt;= 0\n\n    match event.order_type:\n        case models.OrderType.LIMIT:\n            is_invalid = (\n                is_invalid or event.limit_price is None or event.limit_price &lt;= 0\n            )\n        case models.OrderType.STOP:\n            is_invalid = (\n                is_invalid or event.stop_price is None or event.stop_price &lt;= 0\n            )\n        case models.OrderType.STOP_LIMIT:\n            is_invalid = is_invalid or (\n                event.limit_price is None\n                or event.limit_price &lt;= 0\n                or event.stop_price is None\n                or event.stop_price &lt;= 0\n            )\n\n    if is_invalid:\n        # Use event timestamp to maintain simulated time consistency in backtesting\n        self._publish(\n            events.OrderSubmissionRejected(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=event.system_order_id,\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._on_submit_order","title":"<code>_on_submit_order(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _on_submit_order(self, event: events.OrderSubmission) -&gt; None:\n    if self._reject_if_invalid_submission(event):\n        return\n\n    order = _PendingOrder(\n        order_id=event.system_order_id,\n        symbol=event.symbol,\n        order_type=event.order_type,\n        side=event.side,\n        quantity=event.quantity,\n        limit_price=event.limit_price,\n        stop_price=event.stop_price,\n    )\n\n    match order.order_type:\n        case models.OrderType.MARKET:\n            self._pending_market_orders[order.order_id] = order\n        case models.OrderType.LIMIT:\n            self._pending_limit_orders[order.order_id] = order\n        case models.OrderType.STOP:\n            self._pending_stop_orders[order.order_id] = order\n        case models.OrderType.STOP_LIMIT:\n            self._pending_stop_limit_orders[order.order_id] = order\n\n    # Use event timestamp to maintain simulated time consistency in backtesting\n    self._publish(\n        events.OrderSubmissionAccepted(\n            ts_event=event.ts_event,\n            ts_broker=event.ts_event,\n            associated_order_id=order.order_id,\n        )\n    )\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._on_cancel_order","title":"<code>_on_cancel_order(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _on_cancel_order(self, event: events.OrderCancellation) -&gt; None:\n    order_id = event.system_order_id\n\n    removed = False\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            del pending_orders[order_id]\n            removed = True\n            break\n\n    # Use event timestamp to maintain simulated time consistency in backtesting\n    if removed:\n        self._publish(\n            events.OrderCancellationAccepted(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=order_id,\n            )\n        )\n    else:\n        self._publish(\n            events.OrderCancellationRejected(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=order_id,\n            )\n        )\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._reject_if_invalid_modification","title":"<code>_reject_if_invalid_modification(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _reject_if_invalid_modification(self, event: events.OrderModification) -&gt; bool:\n    is_invalid = (\n        (event.quantity is not None and event.quantity &lt;= 0)\n        or (event.limit_price is not None and event.limit_price &lt;= 0)\n        or (event.stop_price is not None and event.stop_price &lt;= 0)\n    )\n\n    if is_invalid:\n        # Use event timestamp to maintain simulated time consistency in backtesting\n        self._publish(\n            events.OrderModificationRejected(\n                ts_event=event.ts_event,\n                ts_broker=event.ts_event,\n                associated_order_id=event.system_order_id,\n            )\n        )\n\n    return is_invalid\n</code></pre>"},{"location":"api-reference/connectors/brokers/simulated/#onesecondtrader.connectors.brokers.simulated.SimulatedBroker._on_modify_order","title":"<code>_on_modify_order(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/brokers/simulated.py</code> <pre><code>def _on_modify_order(self, event: events.OrderModification) -&gt; None:\n    if self._reject_if_invalid_modification(event):\n        return\n\n    order_id = event.system_order_id\n\n    for pending_orders in (\n        self._pending_market_orders,\n        self._pending_limit_orders,\n        self._pending_stop_orders,\n        self._pending_stop_limit_orders,\n    ):\n        if order_id in pending_orders:\n            order = pending_orders[order_id]\n\n            new_quantity = (\n                event.quantity if event.quantity is not None else order.quantity\n            )\n            new_limit_price = (\n                event.limit_price\n                if event.limit_price is not None\n                else order.limit_price\n            )\n            new_stop_price = (\n                event.stop_price\n                if event.stop_price is not None\n                else order.stop_price\n            )\n\n            pending_orders[order_id] = dataclasses.replace(\n                order,\n                quantity=new_quantity,\n                limit_price=new_limit_price,\n                stop_price=new_stop_price,\n            )\n\n            # Use event timestamp to maintain simulated time consistency in backtesting\n            self._publish(\n                events.OrderModificationAccepted(\n                    ts_event=event.ts_event,\n                    ts_broker=event.ts_event,\n                    associated_order_id=order_id,\n                )\n            )\n            return\n\n    # Use event timestamp to maintain simulated time consistency in backtesting\n    self._publish(\n        events.OrderModificationRejected(\n            ts_event=event.ts_event,\n            ts_broker=event.ts_event,\n            associated_order_id=order_id,\n        )\n    )\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/base/","title":"Base","text":""},{"location":"api-reference/connectors/datafeeds/base/#onesecondtrader.connectors.datafeeds.base.Datafeed","title":"<code>Datafeed</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api-reference/connectors/datafeeds/base/#onesecondtrader.connectors.datafeeds.base.Datafeed.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    self._event_bus = event_bus\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/base/#onesecondtrader.connectors.datafeeds.base.Datafeed._publish","title":"<code>_publish(event)</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/base.py</code> <pre><code>def _publish(self, event: events.EventBase) -&gt; None:\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/base/#onesecondtrader.connectors.datafeeds.base.Datafeed.stream","title":"<code>stream(symbols, bar_period)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef stream(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/base/#onesecondtrader.connectors.datafeeds.base.Datafeed.shutdown","title":"<code>shutdown()</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/base.py</code> <pre><code>@abc.abstractmethod\ndef shutdown(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/simulated/","title":"Simulated","text":""},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated._RTYPE_MAP","title":"<code>_RTYPE_MAP = {models.BarPeriod.SECOND: 32, models.BarPeriod.MINUTE: 33, models.BarPeriod.HOUR: 34, models.BarPeriod.DAY: 35}</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed","title":"<code>SimulatedDatafeed</code>","text":"<p>               Bases: <code>Datafeed</code></p>"},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/simulated.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    super().__init__(event_bus)\n    self._thread: threading.Thread | None = None\n    self._stop_event = threading.Event()\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed.stream","title":"<code>stream(symbols, bar_period)</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/simulated.py</code> <pre><code>def stream(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    csv_path = pathlib.Path(self.csv_path)\n    if self._thread and self._thread.is_alive():\n        raise RuntimeError(\"Already streaming\")\n    if not csv_path.exists():\n        raise FileNotFoundError(f\"CSV file not found: {csv_path}\")\n    if not symbols:\n        raise ValueError(\"symbols list cannot be empty\")\n\n    self._stop_event.clear()\n    self._thread = threading.Thread(\n        target=self._stream,\n        args=(symbols, bar_period),\n        name=self.__class__.__name__,\n        daemon=False,\n    )\n    self._thread.start()\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed.wait","title":"<code>wait()</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/simulated.py</code> <pre><code>def wait(self) -&gt; None:\n    if self._thread:\n        self._thread.join()\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed.shutdown","title":"<code>shutdown()</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/simulated.py</code> <pre><code>def shutdown(self) -&gt; None:\n    self._stop_event.set()\n    if self._thread and self._thread.is_alive():\n        self._thread.join()\n</code></pre>"},{"location":"api-reference/connectors/datafeeds/simulated/#onesecondtrader.connectors.datafeeds.simulated.SimulatedDatafeed._stream","title":"<code>_stream(symbols, bar_period)</code>","text":"Source code in <code>src/onesecondtrader/connectors/datafeeds/simulated.py</code> <pre><code>def _stream(self, symbols: list[str], bar_period: models.BarPeriod) -&gt; None:\n    symbols_set = set(symbols)\n    rtype = _RTYPE_MAP[bar_period]\n\n    for chunk in pd.read_csv(\n        self.csv_path,\n        usecols=[\n            \"ts_event\",\n            \"rtype\",\n            \"open\",\n            \"high\",\n            \"low\",\n            \"close\",\n            \"volume\",\n            \"symbol\",\n        ],\n        dtype={\n            \"ts_event\": int,\n            \"rtype\": int,\n            \"open\": int,\n            \"high\": int,\n            \"low\": int,\n            \"close\": int,\n            \"volume\": int,\n            \"symbol\": str,\n        },\n        chunksize=10_000,\n    ):\n        for row in chunk.itertuples():\n            if self._stop_event.is_set():\n                return\n\n            if row.symbol not in symbols_set or row.rtype != rtype:\n                continue\n\n            self._publish(\n                events.BarReceived(\n                    ts_event=pd.Timestamp(row.ts_event, unit=\"ns\", tz=\"UTC\"),\n                    symbol=row.symbol,\n                    bar_period=bar_period,\n                    open=row.open / 1e9,\n                    high=row.high / 1e9,\n                    low=row.low / 1e9,\n                    close=row.close / 1e9,\n                    volume=row.volume,\n                )\n            )\n            self._event_bus.wait_until_system_idle()\n</code></pre>"},{"location":"api-reference/core/brokers/base/","title":"Base","text":""},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase","title":"<code>BrokerBase</code>","text":"<p>               Bases: <code>Subscriber</code></p>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    super().__init__(event_bus)\n    self._subscribe(\n        events.requests.OrderSubmission,\n        events.requests.OrderCancellation,\n        events.requests.OrderModification,\n    )\n</code></pre>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase._on_event","title":"<code>_on_event(event)</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>def _on_event(self, event: events.bases.EventBase) -&gt; None:\n    match event:\n        case events.requests.OrderSubmission() as submit_order:\n            self._on_submit_order(submit_order)\n        case events.requests.OrderCancellation() as cancel_order:\n            self._on_cancel_order(cancel_order)\n        case events.requests.OrderModification() as modify_order:\n            self._on_modify_order(modify_order)\n        case _:\n            return\n</code></pre>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase._on_submit_order","title":"<code>_on_submit_order(event)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_submit_order(self, event: events.requests.OrderSubmission) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase._on_cancel_order","title":"<code>_on_cancel_order(event)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_cancel_order(self, event: events.requests.OrderCancellation) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase._on_modify_order","title":"<code>_on_modify_order(event)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>@abc.abstractmethod\ndef _on_modify_order(self, event: events.requests.OrderModification) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/brokers/base/#onesecondtrader.core.brokers.base.BrokerBase._respond","title":"<code>_respond(response_event)</code>","text":"Source code in <code>src/onesecondtrader/core/brokers/base.py</code> <pre><code>def _respond(self, response_event: events.bases.BrokerResponseEvent) -&gt; None:\n    self._publish(response_event)\n</code></pre>"},{"location":"api-reference/core/events/bases/","title":"Bases","text":""},{"location":"api-reference/core/events/bases/#onesecondtrader.core.events.bases.EventBase","title":"<code>EventBase</code>  <code>dataclass</code>","text":"Source code in <code>src/onesecondtrader/core/events/bases.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass EventBase:\n    ts_event: pd.Timestamp\n    ts_created: pd.Timestamp = dataclasses.field(\n        default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n    )\n</code></pre>"},{"location":"api-reference/core/events/bases/#onesecondtrader.core.events.bases.MarketEvent","title":"<code>MarketEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> Source code in <code>src/onesecondtrader/core/events/bases.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass MarketEvent(EventBase):\n    pass\n</code></pre>"},{"location":"api-reference/core/events/bases/#onesecondtrader.core.events.bases.BrokerRequestEvent","title":"<code>BrokerRequestEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> Source code in <code>src/onesecondtrader/core/events/bases.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BrokerRequestEvent(EventBase):\n    system_order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/bases/#onesecondtrader.core.events.bases.BrokerResponseEvent","title":"<code>BrokerResponseEvent</code>  <code>dataclass</code>","text":"<p>               Bases: <code>EventBase</code></p> Source code in <code>src/onesecondtrader/core/events/bases.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BrokerResponseEvent(EventBase):\n    ts_broker: pd.Timestamp\n    associated_order_id: uuid.UUID\n</code></pre>"},{"location":"api-reference/core/events/market/","title":"Market","text":""},{"location":"api-reference/core/events/market/#onesecondtrader.core.events.market.BarReceived","title":"<code>BarReceived</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MarketEvent</code></p> Source code in <code>src/onesecondtrader/core/events/market.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarReceived(bases.MarketEvent):\n    symbol: str\n    bar_period: models.data.BarPeriod\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: int | None = None\n</code></pre>"},{"location":"api-reference/core/events/market/#onesecondtrader.core.events.market.BarProcessed","title":"<code>BarProcessed</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BarReceived</code></p> Source code in <code>src/onesecondtrader/core/events/market.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass BarProcessed(BarReceived):\n    indicators: dict[str, float] = dataclasses.field(default_factory=dict)\n</code></pre>"},{"location":"api-reference/core/events/requests/","title":"Requests","text":""},{"location":"api-reference/core/events/requests/#onesecondtrader.core.events.requests.OrderSubmission","title":"<code>OrderSubmission</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerRequestEvent</code></p> Source code in <code>src/onesecondtrader/core/events/requests.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderSubmission(bases.BrokerRequestEvent):\n    system_order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    symbol: str\n    order_type: models.orders.OrderType\n    side: models.orders.OrderSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"api-reference/core/events/requests/#onesecondtrader.core.events.requests.OrderCancellation","title":"<code>OrderCancellation</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerRequestEvent</code></p> Source code in <code>src/onesecondtrader/core/events/requests.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderCancellation(bases.BrokerRequestEvent):\n    symbol: str\n</code></pre>"},{"location":"api-reference/core/events/requests/#onesecondtrader.core.events.requests.OrderModification","title":"<code>OrderModification</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerRequestEvent</code></p> Source code in <code>src/onesecondtrader/core/events/requests.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderModification(bases.BrokerRequestEvent):\n    symbol: str\n    quantity: float | None = None\n    limit_price: float | None = None\n    stop_price: float | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/","title":"Responses","text":""},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderSubmissionAccepted","title":"<code>OrderSubmissionAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderSubmissionAccepted(bases.BrokerResponseEvent):\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderSubmissionRejected","title":"<code>OrderSubmissionRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderSubmissionRejected(bases.BrokerResponseEvent):\n    reason: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderModificationAccepted","title":"<code>OrderModificationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderModificationAccepted(bases.BrokerResponseEvent):\n    broker_order_id: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderModificationRejected","title":"<code>OrderModificationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderModificationRejected(bases.BrokerResponseEvent):\n    reason: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderCancellationAccepted","title":"<code>OrderCancellationAccepted</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderCancellationAccepted(bases.BrokerResponseEvent):\n    pass\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderCancellationRejected","title":"<code>OrderCancellationRejected</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderCancellationRejected(bases.BrokerResponseEvent):\n    reason: str | None = None\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderFilled","title":"<code>OrderFilled</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderFilled(bases.BrokerResponseEvent):\n    fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n    broker_fill_id: str | None = None\n    symbol: str\n    side: models.orders.OrderSide\n    quantity_filled: float\n    fill_price: float\n    commission: float\n    exchange: str = \"SIMULATED\"\n</code></pre>"},{"location":"api-reference/core/events/responses/#onesecondtrader.core.events.responses.OrderExpired","title":"<code>OrderExpired</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BrokerResponseEvent</code></p> Source code in <code>src/onesecondtrader/core/events/responses.py</code> <pre><code>@dataclasses.dataclass(kw_only=True, frozen=True)\nclass OrderExpired(bases.BrokerResponseEvent):\n    pass\n</code></pre>"},{"location":"api-reference/core/indicators/averages/","title":"Averages","text":""},{"location":"api-reference/core/indicators/averages/#onesecondtrader.core.indicators.averages.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/averages.py</code> <pre><code>def name(self) -&gt; str:\n    return f\"SMA_{self.period}_{self.input_source.name}\"\n</code></pre>"},{"location":"api-reference/core/indicators/averages/#onesecondtrader.core.indicators.averages.SimpleMovingAverage.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/averages/#onesecondtrader.core.indicators.averages.SimpleMovingAverage.__init__","title":"<code>__init__(period=200, max_history=100, input_source=models.InputSource.CLOSE, plot_at=0)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/averages.py</code> <pre><code>def __init__(\n    self,\n    period: int = 200,\n    max_history: int = 100,\n    input_source: models.InputSource = models.InputSource.CLOSE,\n    plot_at: int = 0,\n) -&gt; None:\n    super().__init__(max_history=max_history, plot_at=plot_at)\n    self.period: int = max(1, int(period))\n    self.input_source: models.InputSource = input_source\n    self._window: dict[str, collections.deque[float]] = {}\n</code></pre>"},{"location":"api-reference/core/indicators/averages/#onesecondtrader.core.indicators.averages.SimpleMovingAverage._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/averages.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    symbol = incoming_bar.symbol\n    if symbol not in self._window:\n        self._window[symbol] = collections.deque(maxlen=self.period)\n    window = self._window[symbol]\n    value = self._extract_input(incoming_bar)\n    window.append(value)\n    if len(window) &lt; self.period:\n        return np.nan\n    return sum(window) / self.period\n</code></pre>"},{"location":"api-reference/core/indicators/averages/#onesecondtrader.core.indicators.averages.SimpleMovingAverage._extract_input","title":"<code>_extract_input(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/averages.py</code> <pre><code>def _extract_input(self, incoming_bar: events.BarReceived) -&gt; float:\n    match self.input_source:\n        case models.InputSource.OPEN:\n            return incoming_bar.open\n        case models.InputSource.HIGH:\n            return incoming_bar.high\n        case models.InputSource.LOW:\n            return incoming_bar.low\n        case models.InputSource.CLOSE:\n            return incoming_bar.close\n        case models.InputSource.VOLUME:\n            return (\n                float(incoming_bar.volume)\n                if incoming_bar.volume is not None\n                else np.nan\n            )\n        case _:\n            return incoming_bar.close\n</code></pre>"},{"location":"api-reference/core/indicators/bar/","title":"Bar","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Open","title":"<code>Open</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def name(self) -&gt; str:\n    return \"OPEN\"\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Open.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Open._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    return incoming_bar.open\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.High","title":"<code>High</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def name(self) -&gt; str:\n    return \"HIGH\"\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.High.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.High._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    return incoming_bar.high\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Low","title":"<code>Low</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def name(self) -&gt; str:\n    return \"LOW\"\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Low.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Low._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    return incoming_bar.low\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Close","title":"<code>Close</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def name(self) -&gt; str:\n    return \"CLOSE\"\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Close.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Close._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    return incoming_bar.close\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Volume","title":"<code>Volume</code>","text":"<p>               Bases: <code>Indicator</code></p> Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def name(self) -&gt; str:\n    return \"VOLUME\"\n</code></pre>"},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Volume.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/bar/#onesecondtrader.core.indicators.bar.Volume._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/bar.py</code> <pre><code>def _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    return float(incoming_bar.volume) if incoming_bar.volume is not None else 0.0\n</code></pre>"},{"location":"api-reference/core/indicators/base/","title":"Base","text":""},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator","title":"<code>Indicator</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def name(self) -&gt; str:\n    pass\n</code></pre> Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def latest(self) -&gt; float:\n    with self._lock:\n        h = self._history_data.get(self._current_symbol, collections.deque())\n        return h[-1] if h else np.nan\n</code></pre> Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def history(self) -&gt; collections.deque[float]:\n    with self._lock:\n        h = self._history_data.get(self._current_symbol, collections.deque())\n        return collections.deque(h, maxlen=self._max_history)\n</code></pre> Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def plot_at(self) -&gt; int:\n    return self._plot_at\n</code></pre>"},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":""},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.latest","title":"<code>latest</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.history","title":"<code>history</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.plot_at","title":"<code>plot_at</code>  <code>property</code>","text":""},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.__init__","title":"<code>__init__(max_history=100, plot_at=99)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def __init__(self, max_history: int = 100, plot_at: int = 99) -&gt; None:\n    self._lock = threading.Lock()\n    self._max_history = max(1, int(max_history))\n    self._current_symbol: str = \"\"\n    self._history_data: dict[str, collections.deque[float]] = {}\n    self._plot_at = plot_at\n</code></pre>"},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator._compute_indicator","title":"<code>_compute_indicator(incoming_bar)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>@abc.abstractmethod\ndef _compute_indicator(self, incoming_bar: events.BarReceived) -&gt; float:\n    pass\n</code></pre>"},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.update","title":"<code>update(incoming_bar)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def update(self, incoming_bar: events.BarReceived) -&gt; None:\n    symbol = incoming_bar.symbol\n    self._current_symbol = symbol\n    value = self._compute_indicator(incoming_bar)\n    with self._lock:\n        if symbol not in self._history_data:\n            self._history_data[symbol] = collections.deque(maxlen=self._max_history)\n        self._history_data[symbol].append(value)\n</code></pre>"},{"location":"api-reference/core/indicators/base/#onesecondtrader.core.indicators.base.Indicator.__getitem__","title":"<code>__getitem__(index)</code>","text":"Source code in <code>src/onesecondtrader/core/indicators/base.py</code> <pre><code>def __getitem__(self, index: int) -&gt; float:\n    # Returns np.nan on out-of-bounds access. Since np.nan comparisons always\n    # return False, strategies can skip explicit length checks.\n    try:\n        return self.history[index]\n    except IndexError:\n        return np.nan\n</code></pre>"},{"location":"api-reference/core/messaging/eventbus/","title":"Eventbus","text":""},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus","title":"<code>EventBus</code>","text":""},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus.__init__","title":"<code>__init__()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/eventbus.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._per_event_subscriptions: collections.defaultdict[\n        type[events.bases.EventBase], set[Subscriber]\n    ] = collections.defaultdict(set)\n    self._subscribers: set[Subscriber] = set()\n    self._lock: threading.Lock = threading.Lock()\n</code></pre>"},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus.subscribe","title":"<code>subscribe(subscriber, event_type)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/eventbus.py</code> <pre><code>def subscribe(\n    self,\n    subscriber: Subscriber,\n    event_type: type[events.bases.EventBase],\n) -&gt; None:\n    with self._lock:\n        self._subscribers.add(subscriber)\n        self._per_event_subscriptions[event_type].add(subscriber)\n</code></pre>"},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus.unsubscribe","title":"<code>unsubscribe(subscriber)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/eventbus.py</code> <pre><code>def unsubscribe(self, subscriber: Subscriber) -&gt; None:\n    with self._lock:\n        for set_of_event_subscribers in self._per_event_subscriptions.values():\n            set_of_event_subscribers.discard(subscriber)\n        self._subscribers.discard(subscriber)\n</code></pre>"},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus.publish","title":"<code>publish(event)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/eventbus.py</code> <pre><code>def publish(self, event: events.bases.EventBase) -&gt; None:\n    # Intentionally matches exact event types only, not parent classes\n    with self._lock:\n        subscribers = self._per_event_subscriptions[type(event)].copy()\n    for subscriber in subscribers:\n        subscriber.receive(event)\n</code></pre>"},{"location":"api-reference/core/messaging/eventbus/#onesecondtrader.core.messaging.eventbus.EventBus.wait_until_system_idle","title":"<code>wait_until_system_idle()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/eventbus.py</code> <pre><code>def wait_until_system_idle(self) -&gt; None:\n    with self._lock:\n        subscribers = self._subscribers.copy()\n    for subscriber in subscribers:\n        subscriber.wait_until_idle()\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/","title":"Subscriber","text":""},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber","title":"<code>Subscriber</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def __init__(self, event_bus: EventBus) -&gt; None:\n    self._event_bus = event_bus\n    self._queue: queue.Queue[events.bases.EventBase | None] = queue.Queue()\n    self._running: threading.Event = threading.Event()\n    self._running.set()\n    self._thread = threading.Thread(\n        target=self._event_loop, name=self.__class__.__name__\n    )\n    self._thread.start()\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber.receive","title":"<code>receive(event)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def receive(self, event: events.bases.EventBase) -&gt; None:\n    if self._running.is_set():\n        self._queue.put(event)\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber.wait_until_idle","title":"<code>wait_until_idle()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def wait_until_idle(self) -&gt; None:\n    if not self._running.is_set():\n        return\n    self._queue.join()\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber.shutdown","title":"<code>shutdown()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def shutdown(self) -&gt; None:\n    if not self._running.is_set():\n        return\n    self._event_bus.unsubscribe(self)\n    self._running.clear()\n    self._queue.put(None)\n    if threading.current_thread() is not self._thread:\n        self._thread.join()\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._subscribe","title":"<code>_subscribe(*event_types)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def _subscribe(self, *event_types: type[events.bases.EventBase]) -&gt; None:\n    for event_type in event_types:\n        self._event_bus.subscribe(self, event_type)\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._publish","title":"<code>_publish(event)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def _publish(self, event: events.bases.EventBase) -&gt; None:\n    self._event_bus.publish(event)\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._event_loop","title":"<code>_event_loop()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def _event_loop(self) -&gt; None:\n    while True:\n        event = self._queue.get()\n        if event is None:\n            self._queue.task_done()\n            break\n        try:\n            self._on_event(event)\n        except Exception as exc:\n            self._on_exception(exc)\n        finally:\n            self._queue.task_done()\n    self._cleanup()\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._on_exception","title":"<code>_on_exception(exc)</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def _on_exception(self, exc: Exception) -&gt; None:\n    # Override in subclass to log or handle exceptions\n    pass\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._cleanup","title":"<code>_cleanup()</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>def _cleanup(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/messaging/subscriber/#onesecondtrader.core.messaging.subscriber.Subscriber._on_event","title":"<code>_on_event(event)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/messaging/subscriber.py</code> <pre><code>@abc.abstractmethod\ndef _on_event(self, event: events.bases.EventBase) -&gt; None:\n    # Must not block indefinitely; wait_until_idle() has no timeout\n    ...\n</code></pre>"},{"location":"api-reference/core/models/data/","title":"Data","text":""},{"location":"api-reference/core/models/data/#onesecondtrader.core.models.data.BarPeriod","title":"<code>BarPeriod</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/onesecondtrader/core/models/data.py</code> <pre><code>class BarPeriod(enum.Enum):\n    SECOND = enum.auto()\n    MINUTE = enum.auto()\n    HOUR = enum.auto()\n    DAY = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/data/#onesecondtrader.core.models.data.InputSource","title":"<code>InputSource</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/onesecondtrader/core/models/data.py</code> <pre><code>class InputSource(enum.Enum):\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/orders/","title":"Orders","text":""},{"location":"api-reference/core/models/orders/#onesecondtrader.core.models.orders.OrderType","title":"<code>OrderType</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/onesecondtrader/core/models/orders.py</code> <pre><code>class OrderType(enum.Enum):\n    LIMIT = enum.auto()\n    MARKET = enum.auto()\n    STOP = enum.auto()\n    STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/orders/#onesecondtrader.core.models.orders.OrderSide","title":"<code>OrderSide</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>src/onesecondtrader/core/models/orders.py</code> <pre><code>class OrderSide(enum.Enum):\n    BUY = enum.auto()\n    SELL = enum.auto()\n</code></pre>"},{"location":"api-reference/core/models/records/","title":"Records","text":""},{"location":"api-reference/core/models/records/#onesecondtrader.core.models.records.OrderRecord","title":"<code>OrderRecord</code>  <code>dataclass</code>","text":"Source code in <code>src/onesecondtrader/core/models/records.py</code> <pre><code>@dataclasses.dataclass\nclass OrderRecord:\n    order_id: uuid.UUID\n    symbol: str\n    order_type: orders.OrderType\n    side: orders.OrderSide\n    quantity: float\n    limit_price: float | None = None\n    stop_price: float | None = None\n    filled_quantity: float = 0.0\n</code></pre>"},{"location":"api-reference/core/models/records/#onesecondtrader.core.models.records.FillRecord","title":"<code>FillRecord</code>  <code>dataclass</code>","text":"Source code in <code>src/onesecondtrader/core/models/records.py</code> <pre><code>@dataclasses.dataclass\nclass FillRecord:\n    fill_id: uuid.UUID\n    order_id: uuid.UUID\n    symbol: str\n    side: orders.OrderSide\n    quantity: float\n    price: float\n    commission: float\n    ts_event: pd.Timestamp\n</code></pre>"},{"location":"api-reference/core/strategies/base/","title":"Base","text":""},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase","title":"<code>StrategyBase</code>","text":"<p>               Bases: <code>Subscriber</code>, <code>ABC</code></p> Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def position(self) -&gt; float:\n    return self._positions.get(self._current_symbol, 0.0)\n</code></pre> Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def avg_price(self) -&gt; float:\n    return self._avg_prices.get(self._current_symbol, 0.0)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.position","title":"<code>position</code>  <code>property</code>","text":""},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.avg_price","title":"<code>avg_price</code>  <code>property</code>","text":""},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.__init__","title":"<code>__init__(event_bus)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def __init__(self, event_bus: messaging.EventBus) -&gt; None:\n    super().__init__(event_bus)\n    self._subscribe(\n        events.BarReceived,\n        events.OrderSubmissionAccepted,\n        events.OrderModificationAccepted,\n        events.OrderCancellationAccepted,\n        events.OrderSubmissionRejected,\n        events.OrderModificationRejected,\n        events.OrderCancellationRejected,\n        events.OrderFilled,\n        events.OrderExpired,\n    )\n\n    self._current_symbol: str = \"\"\n    self._current_ts: pd.Timestamp = pd.Timestamp.now(tz=\"UTC\")\n    self._indicators: list[indicators.Indicator] = []\n\n    self._fills: dict[str, list[models.FillRecord]] = {}\n    self._positions: dict[str, float] = {}\n    self._avg_prices: dict[str, float] = {}\n    self._pending_orders: dict[uuid.UUID, models.OrderRecord] = {}\n    self._submitted_orders: dict[uuid.UUID, models.OrderRecord] = {}\n    self._submitted_modifications: dict[uuid.UUID, models.OrderRecord] = {}\n    self._submitted_cancellations: dict[uuid.UUID, models.OrderRecord] = {}\n\n    # OHLCV as indicators for history access: self.bar.close.history\n    self.bar = SimpleNamespace(\n        open=self.add_indicator(indicators.Open()),\n        high=self.add_indicator(indicators.High()),\n        low=self.add_indicator(indicators.Low()),\n        close=self.add_indicator(indicators.Close()),\n        volume=self.add_indicator(indicators.Volume()),\n    )\n\n    # Hook for subclasses to register indicators without overriding __init__\n    self.setup()\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.add_indicator","title":"<code>add_indicator(ind)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def add_indicator(self, ind: indicators.Indicator) -&gt; indicators.Indicator:\n    self._indicators.append(ind)\n    return ind\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.submit_order","title":"<code>submit_order(order_type, side, quantity, limit_price=None, stop_price=None)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def submit_order(\n    self,\n    order_type: models.OrderType,\n    side: models.OrderSide,\n    quantity: float,\n    limit_price: float | None = None,\n    stop_price: float | None = None,\n) -&gt; uuid.UUID:\n    # Uses bar timestamp for backtest compatibility; ts_created tracks real wall-clock time\n    order_id = uuid.uuid4()\n\n    event = events.OrderSubmission(\n        ts_event=self._current_ts,\n        system_order_id=order_id,\n        symbol=self._current_symbol,\n        order_type=order_type,\n        side=side,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n    )\n\n    order = models.OrderRecord(\n        order_id=order_id,\n        symbol=self._current_symbol,\n        order_type=order_type,\n        side=side,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n    )\n\n    self._submitted_orders[order_id] = order\n    self._publish(event)\n    return order_id\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.submit_modification","title":"<code>submit_modification(order_id, quantity=None, limit_price=None, stop_price=None)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def submit_modification(\n    self,\n    order_id: uuid.UUID,\n    quantity: float | None = None,\n    limit_price: float | None = None,\n    stop_price: float | None = None,\n) -&gt; bool:\n    original_order = self._pending_orders.get(order_id)\n    if original_order is None:\n        return False\n\n    event = events.OrderModification(\n        ts_event=self._current_ts,\n        system_order_id=order_id,\n        symbol=original_order.symbol,\n        quantity=quantity,\n        limit_price=limit_price,\n        stop_price=stop_price,\n    )\n\n    modified_order = models.OrderRecord(\n        order_id=order_id,\n        symbol=original_order.symbol,\n        order_type=original_order.order_type,\n        side=original_order.side,\n        quantity=quantity if quantity is not None else original_order.quantity,\n        limit_price=(\n            limit_price if limit_price is not None else original_order.limit_price\n        ),\n        stop_price=(\n            stop_price if stop_price is not None else original_order.stop_price\n        ),\n        filled_quantity=original_order.filled_quantity,\n    )\n\n    self._submitted_modifications[order_id] = modified_order\n    self._publish(event)\n    return True\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.submit_cancellation","title":"<code>submit_cancellation(order_id)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def submit_cancellation(self, order_id: uuid.UUID) -&gt; bool:\n    original_order = self._pending_orders.get(order_id)\n    if original_order is None:\n        return False\n\n    event = events.OrderCancellation(\n        ts_event=self._current_ts,\n        system_order_id=order_id,\n        symbol=original_order.symbol,\n    )\n\n    self._submitted_cancellations[order_id] = original_order\n    self._publish(event)\n    return True\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_event","title":"<code>_on_event(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_event(self, event: events.EventBase) -&gt; None:\n    match event:\n        case events.BarReceived() as bar_event:\n            self._on_bar_received(bar_event)\n        case events.OrderSubmissionAccepted() as accepted:\n            self._on_order_submission_accepted(accepted)\n        case events.OrderModificationAccepted() as accepted:\n            self._on_order_modification_accepted(accepted)\n        case events.OrderCancellationAccepted() as accepted:\n            self._on_order_cancellation_accepted(accepted)\n        case events.OrderSubmissionRejected() as rejected:\n            self._on_order_submission_rejected(rejected)\n        case events.OrderModificationRejected() as rejected:\n            self._on_order_modification_rejected(rejected)\n        case events.OrderCancellationRejected() as rejected:\n            self._on_order_cancellation_rejected(rejected)\n        case events.OrderFilled() as filled:\n            self._on_order_filled(filled)\n        case events.OrderExpired() as expired:\n            self._on_order_expired(expired)\n        case _:\n            return\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_bar_received","title":"<code>_on_bar_received(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_bar_received(self, event: events.BarReceived) -&gt; None:\n    if event.symbol not in self.symbols:\n        return\n    if event.bar_period != self.bar_period:\n        return\n\n    self._current_symbol = event.symbol\n    self._current_ts = event.ts_event\n\n    for ind in self._indicators:\n        ind.update(event)\n\n    self._emit_processed_bar(event)\n    self.on_bar(event)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._emit_processed_bar","title":"<code>_emit_processed_bar(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _emit_processed_bar(self, event: events.BarReceived) -&gt; None:\n    ohlcv_names = {\"OPEN\", \"HIGH\", \"LOW\", \"CLOSE\", \"VOLUME\"}\n\n    indicator_values = {\n        f\"{ind.plot_at:02d}_{ind.name}\": ind.latest\n        for ind in self._indicators\n        if ind.name not in ohlcv_names\n    }\n\n    processed_bar = events.BarProcessed(\n        ts_event=event.ts_event,\n        symbol=event.symbol,\n        bar_period=event.bar_period,\n        open=event.open,\n        high=event.high,\n        low=event.low,\n        close=event.close,\n        volume=event.volume,\n        indicators=indicator_values,\n    )\n\n    self._publish(processed_bar)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_submission_accepted","title":"<code>_on_order_submission_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_submission_accepted(\n    self, event: events.OrderSubmissionAccepted\n) -&gt; None:\n    order = self._submitted_orders.pop(event.associated_order_id, None)\n    if order is not None:\n        self._pending_orders[event.associated_order_id] = order\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_modification_accepted","title":"<code>_on_order_modification_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_modification_accepted(\n    self, event: events.OrderModificationAccepted\n) -&gt; None:\n    modified_order = self._submitted_modifications.pop(\n        event.associated_order_id, None\n    )\n    if modified_order is not None:\n        self._pending_orders[event.associated_order_id] = modified_order\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_cancellation_accepted","title":"<code>_on_order_cancellation_accepted(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_cancellation_accepted(\n    self, event: events.OrderCancellationAccepted\n) -&gt; None:\n    self._submitted_cancellations.pop(event.associated_order_id, None)\n    self._pending_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_submission_rejected","title":"<code>_on_order_submission_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_submission_rejected(\n    self, event: events.OrderSubmissionRejected\n) -&gt; None:\n    self._submitted_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_modification_rejected","title":"<code>_on_order_modification_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_modification_rejected(\n    self, event: events.OrderModificationRejected\n) -&gt; None:\n    self._submitted_modifications.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_cancellation_rejected","title":"<code>_on_order_cancellation_rejected(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_cancellation_rejected(\n    self, event: events.OrderCancellationRejected\n) -&gt; None:\n    self._submitted_cancellations.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_filled","title":"<code>_on_order_filled(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_filled(self, event: events.OrderFilled) -&gt; None:\n    # Track partial fills: only remove order when fully filled\n    order = self._pending_orders.get(event.associated_order_id)\n    if order:\n        order.filled_quantity += event.quantity_filled\n        if order.filled_quantity &gt;= order.quantity:\n            self._pending_orders.pop(event.associated_order_id)\n\n    fill = models.FillRecord(\n        fill_id=event.fill_id,\n        order_id=event.associated_order_id,\n        symbol=event.symbol,\n        side=event.side,\n        quantity=event.quantity_filled,\n        price=event.fill_price,\n        commission=event.commission,\n        ts_event=event.ts_event,\n    )\n\n    self._fills.setdefault(event.symbol, []).append(fill)\n    self._update_position(event)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._update_position","title":"<code>_update_position(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _update_position(self, event: events.OrderFilled) -&gt; None:\n    symbol = event.symbol\n    fill_qty = event.quantity_filled\n    fill_price = event.fill_price\n\n    signed_qty = 0.0\n    match event.side:\n        case models.OrderSide.BUY:\n            signed_qty = fill_qty\n        case models.OrderSide.SELL:\n            signed_qty = -fill_qty\n\n    old_pos = self._positions.get(symbol, 0.0)\n    old_avg = self._avg_prices.get(symbol, 0.0)\n    new_pos = old_pos + signed_qty\n\n    if new_pos == 0.0:\n        new_avg = 0.0\n    elif old_pos == 0.0:\n        new_avg = fill_price\n    elif (old_pos &gt; 0 and signed_qty &gt; 0) or (old_pos &lt; 0 and signed_qty &lt; 0):\n        new_avg = (old_avg * abs(old_pos) + fill_price * abs(signed_qty)) / abs(\n            new_pos\n        )\n    else:\n        if abs(new_pos) &lt;= abs(old_pos):\n            new_avg = old_avg\n        else:\n            new_avg = fill_price\n\n    self._positions[symbol] = new_pos\n    self._avg_prices[symbol] = new_avg\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase._on_order_expired","title":"<code>_on_order_expired(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def _on_order_expired(self, event: events.OrderExpired) -&gt; None:\n    self._pending_orders.pop(event.associated_order_id, None)\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.setup","title":"<code>setup()</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>def setup(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/strategies/base/#onesecondtrader.core.strategies.base.StrategyBase.on_bar","title":"<code>on_bar(event)</code>  <code>abstractmethod</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/base.py</code> <pre><code>@abc.abstractmethod\ndef on_bar(self, event: events.BarReceived) -&gt; None:\n    pass\n</code></pre>"},{"location":"api-reference/core/strategies/examples/","title":"Examples","text":""},{"location":"api-reference/core/strategies/examples/#onesecondtrader.core.strategies.examples.SMACrossover","title":"<code>SMACrossover</code>","text":"<p>               Bases: <code>StrategyBase</code></p>"},{"location":"api-reference/core/strategies/examples/#onesecondtrader.core.strategies.examples.SMACrossover.setup","title":"<code>setup()</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/examples.py</code> <pre><code>def setup(self) -&gt; None:\n    self.fast_sma = self.add_indicator(\n        indicators.SimpleMovingAverage(period=self.fast_period)\n    )\n    self.slow_sma = self.add_indicator(\n        indicators.SimpleMovingAverage(period=self.slow_period)\n    )\n</code></pre>"},{"location":"api-reference/core/strategies/examples/#onesecondtrader.core.strategies.examples.SMACrossover.on_bar","title":"<code>on_bar(event)</code>","text":"Source code in <code>src/onesecondtrader/core/strategies/examples.py</code> <pre><code>def on_bar(self, event: events.BarReceived) -&gt; None:\n    if (\n        self.fast_sma[-2] &lt;= self.slow_sma[-2]\n        and self.fast_sma.latest &gt; self.slow_sma.latest\n        and self.position &lt;= 0\n    ):\n        self.submit_order(\n            models.OrderType.MARKET, models.OrderSide.BUY, self.quantity\n        )\n\n    if (\n        self.fast_sma[-2] &gt;= self.slow_sma[-2]\n        and self.fast_sma.latest &lt; self.slow_sma.latest\n        and self.position &gt;= 0\n    ):\n        self.submit_order(\n            models.OrderType.MARKET, models.OrderSide.SELL, self.quantity\n        )\n</code></pre>"},{"location":"api-reference/secmaster/schema/","title":"Schema","text":"<p>Security Master Database Schema</p> <p>Stores instrument metadata and market data using Databento's schema and terminology.</p> <p> View DataBento's Schemas and Data Formats Documentation</p> <p> View DataBento's Standards and Conventions Documentation</p> <p>The security master database schema follows a normalized one-to-many relationship structure: each publisher can have many instruments, and each instrument can have many records in each of the market data tables.</p> <p>Metadata Tables:</p> Table Databento Schema Description <code>publishers</code> - Registry of data vendors and market data sources that provide instrument definitions and price data. Each publisher represents a distinct data feed with its own instrument identifiers. <code>instruments</code> <code>definition</code> Comprehensive security master containing static reference data for all tradeable instruments including contract specifications, pricing parameters, expiration dates, and hierarchical relationships between derivatives and their underlyings. <p>Market Data Tables:</p> Table Databento Schema Description <code>ohlcv</code> <code>ohlcv-1s</code>, <code>ohlcv-1m</code>, etc. Aggregated Open-High-Low-Close-Volume bar/candlestick data at various time intervals (1-second, 1-minute, hourly, daily). Foundation for technical analysis and strategy backtesting. <code>trades</code> <code>trades</code> / <code>mbp-0</code> Individual trade executions (prints) with price, size, and exchange-assigned trade conditions. Captures every matched order for tick-level analysis. <code>quotes</code> <code>mbp-1</code> Top-of-book bid/ask quotes with the most recent trade information. Each record represents an order book event that changed the best bid or offer. <code>bbo</code> <code>bbo-1s</code>, <code>bbo-1m</code> Periodically sampled best bid/offer snapshots at regular intervals. Provides compressed spread data without full tick granularity. <code>mbo</code> <code>mbo</code> Full market-by-order data capturing every order book event including additions, modifications, cancellations, and executions with individual order IDs. <code>mbp10</code> <code>mbp-10</code> 10-level market depth snapshots showing the top 10 price levels on both bid and ask sides. Balances depth visibility with storage efficiency. <code>imbalance</code> <code>imbalance</code> Auction imbalance messages published during opening, closing, and intraday auctions showing paired and unpaired share quantities. <code>statistics</code> <code>statistics</code> Exchange-published statistics including settlement prices, open interest, trading volume, and reference prices for mark-to-market calculations. <code>status</code> <code>status</code> Trading status updates indicating instrument state changes such as trading halts, pre-open periods, auction states, and session boundaries."},{"location":"api-reference/secmaster/schema/#publishers","title":"Publishers","text":"<p>Data providers and market data vendors that supply instrument definitions and market data.</p> <p>This table serves as the authoritative registry of all data sources in the system. It is intentionally separated from the instruments table because the same trading symbol (e.g., <code>ESH5</code> for the March 2025 E-mini S&amp;P 500 future) may exist across multiple vendors, each assigning their own unique <code>instrument_id</code>. This design allows the system to track and reconcile data from multiple sources while maintaining clear provenance for each instrument.</p> <p>The <code>dataset</code> field uses Databento's dataset naming convention, which combines the venue and feed identifier (e.g., <code>GLBX.MDP3</code> for CME Globex MDP 3.0 feed).</p> Field Type Constraints Description <code>publisher_id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier that serves as the primary key for this publisher record <code>name</code> TEXT NOT NULL, UNIQUE Human-readable name of the data provider or vendor (e.g., <code>Databento</code>, <code>Bloomberg</code>). Must be unique across all publishers <code>dataset</code> TEXT NOT NULL Databento dataset identifier that specifies the venue and feed combination (e.g., <code>GLBX.MDP3</code> for CME Globex Market Data Platform 3.0) <code>venue</code> TEXT ISO 10383 Market Identifier Code (MIC) for the trading venue (e.g., <code>XCME</code> for Chicago Mercantile Exchange). May be NULL if the publisher covers multiple venues <pre><code>CREATE TABLE publishers (\n    publisher_id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL UNIQUE,\n    dataset TEXT NOT NULL,\n    venue TEXT\n);\n</code></pre>"},{"location":"api-reference/secmaster/schema/#instruments","title":"Instruments","text":"<p>Security and instrument metadata sourced from Databento's <code>InstrumentDefMsg</code>.</p> <p>This table serves as the central repository for all tradeable instruments in the system. It stores static reference data that defines each instrument's characteristics, including contract specifications, pricing parameters, and temporal validity. The schema is designed to accommodate a wide variety of instrument types including equities, futures, options, spreads, and FX products.</p> <p>Each instrument is uniquely identified within the system by <code>instrument_id</code>, but the same logical instrument (e.g., ESH5) may appear multiple times if sourced from different publishers. The unique constraint on (<code>publisher_id</code>, <code>raw_symbol</code>) ensures data integrity while allowing multi-source reconciliation.</p> <p>For derivatives, the <code>underlying_id</code> field creates a self-referential relationship that links options and futures to their underlying instruments, enabling hierarchical queries across the derivatives chain.</p> <p>Instrument Class Codes (used in <code>instrument_class</code>):</p> Code Description B Bond C Call option F Future K Stock M Mixed spread P Put option S Future spread T Option spread X FX spot Y Commodity spot Field Type Constraints Description <code>instrument_id</code> INTEGER PRIMARY KEY Auto-incrementing unique identifier that serves as the primary key for this instrument record within the security master <code>publisher_id</code> INTEGER NOT NULL, FK Foreign key reference to <code>publishers.publisher_id</code> identifying which data vendor provided this instrument definition <code>raw_instrument_id</code> INTEGER The native instrument identifier assigned by the publisher/exchange (e.g., Databento's internal ID). May be NULL if not provided <code>raw_symbol</code> TEXT NOT NULL The trading symbol exactly as provided by the publisher without any normalization (e.g., <code>ESH5</code> for March 2025 E-mini S&amp;P 500) <code>instrument_class</code> TEXT NOT NULL, DEFAULT 'K' Single-character classification code indicating the instrument type. See the Instrument Class Codes table above for the complete mapping <code>security_type</code> TEXT Descriptive security type string used by the exchange (e.g., <code>FUT</code> for futures, <code>OPT</code> for options, <code>STK</code> for stocks, <code>MLEG</code> for multi-leg) <code>asset</code> TEXT The underlying asset or product code that this instrument is based on (e.g., <code>ES</code> for E-mini S&amp;P 500, <code>CL</code> for Crude Oil, <code>AAPL</code> for Apple stock) <code>cfi</code> TEXT ISO 10962 Classification of Financial Instruments code providing standardized instrument categorization (e.g., <code>FXXXXX</code> for futures) <code>exchange</code> TEXT ISO 10383 Market Identifier Code (MIC) for the primary exchange where this instrument trades (e.g., <code>XCME</code> for CME, <code>XNYS</code> for NYSE) <code>currency</code> TEXT DEFAULT 'USD' ISO 4217 currency code for the currency in which the instrument is quoted and traded. Defaults to USD if not specified <code>strike_price</code> INTEGER For options: the strike price at which the option can be exercised. Stored as fixed-point integer with \\(10^9\\) scale factor. NULL for non-option instruments <code>strike_price_currency</code> TEXT ISO 4217 currency code for the strike price, which may differ from the trading currency in quanto or cross-currency options <code>expiration</code> INTEGER The timestamp when the instrument expires and ceases trading, stored as nanoseconds since Unix epoch. NULL for perpetual instruments <code>activation</code> INTEGER The timestamp when the instrument becomes available for trading, stored as nanoseconds since Unix epoch. Useful for newly listed contracts <code>maturity_year</code> INTEGER The calendar year component embedded in the instrument symbol (e.g., 2025 for ESH5). Used for futures and options contract identification <code>maturity_month</code> INTEGER The calendar month component (1-12) embedded in the instrument symbol (e.g., 3 for March in ESH5). Used for contract roll calculations <code>maturity_day</code> INTEGER The calendar day component embedded in the instrument symbol, if applicable. NULL for monthly contracts, populated for weekly options <code>contract_multiplier</code> INTEGER The multiplier applied to the quoted price to determine the contract's notional value (e.g., 50 for ES futures means $50 per index point) <code>unit_of_measure</code> TEXT The unit in which the underlying commodity or asset is measured (e.g., <code>USD</code> for financial futures, <code>LBS</code> for cattle, <code>BBL</code> for oil) <code>unit_of_measure_qty</code> INTEGER The quantity of the unit of measure per contract, stored as fixed-point integer with \\(10^9\\) scale factor (e.g., 1000 barrels for CL) <code>underlying_id</code> INTEGER FK Self-referential foreign key to <code>instruments.instrument_id</code> linking derivatives to their underlying instrument. NULL for non-derivatives <code>underlying</code> TEXT The symbol of the underlying instrument as a string. Provides a denormalized reference when the underlying may not exist in the database <code>display_factor</code> INTEGER Multiplier for converting internal prices to display prices, stored as fixed-point integer with \\(10^9\\) scale factor. Used for price formatting <code>high_limit_price</code> INTEGER The maximum price at which the instrument can trade during the session (circuit breaker), stored as fixed-point integer with \\(10^9\\) scale factor <code>low_limit_price</code> INTEGER The minimum price at which the instrument can trade during the session (circuit breaker), stored as fixed-point integer with \\(10^9\\) scale factor <code>min_price_increment</code> INTEGER The minimum price movement (tick size) for the instrument, stored as fixed-point integer with \\(10^9\\) scale factor (e.g., 0.25 for ES) <code>security_group</code> TEXT Exchange-defined grouping code that categorizes related instruments (e.g., <code>ES</code> group contains all E-mini S&amp;P 500 contracts) <code>ts_recv</code> INTEGER NOT NULL The timestamp when this instrument definition was received/captured by the data infrastructure, stored as nanoseconds since Unix epoch <pre><code>CREATE TABLE instruments (\n    instrument_id INTEGER PRIMARY KEY,\n    publisher_id INTEGER NOT NULL,\n    raw_instrument_id INTEGER,\n    raw_symbol TEXT NOT NULL,\n    instrument_class TEXT NOT NULL DEFAULT 'K' CHECK(instrument_class IN ('B', 'C', 'F', 'K', 'M', 'P', 'S', 'T', 'X', 'Y')),\n    security_type TEXT,\n    asset TEXT,\n    cfi TEXT,\n    exchange TEXT,\n    currency TEXT DEFAULT 'USD',\n    strike_price INTEGER,\n    strike_price_currency TEXT,\n    expiration INTEGER,\n    activation INTEGER,\n    maturity_year INTEGER,\n    maturity_month INTEGER CHECK(maturity_month IS NULL OR (maturity_month &gt;= 1 AND maturity_month &lt;= 12)),\n    maturity_day INTEGER CHECK(maturity_day IS NULL OR (maturity_day &gt;= 1 AND maturity_day &lt;= 31)),\n    contract_multiplier INTEGER,\n    unit_of_measure TEXT,\n    unit_of_measure_qty INTEGER,\n    underlying_id INTEGER,\n    underlying TEXT,\n    display_factor INTEGER,\n    high_limit_price INTEGER,\n    low_limit_price INTEGER,\n    min_price_increment INTEGER,\n    security_group TEXT,\n    ts_recv INTEGER NOT NULL,\n    FOREIGN KEY (publisher_id) REFERENCES publishers(publisher_id),\n    FOREIGN KEY (underlying_id) REFERENCES instruments(instrument_id),\n    UNIQUE(publisher_id, raw_symbol)\n);\n</code></pre>"},{"location":"api-reference/secmaster/schema/#ohlcv","title":"OHLCV","text":"<p>OHLCV (Open-High-Low-Close-Volume) bar/candlestick data sourced from Databento's <code>OhlcvMsg</code>.</p> <p>This table stores aggregated price and volume data at various time intervals, providing the foundation for technical analysis, charting, and strategy backtesting. Each row represents a single bar/candle summarizing all trading activity within a specific time period for a given instrument.</p> <p>The table supports multiple bar durations through the <code>rtype</code> field, allowing storage of 1-second, 1-minute, 1-hour, 1-day, and end-of-day bars in a single unified table. This design enables efficient cross-timeframe analysis without requiring separate tables for each granularity.</p> <p>The composite primary key is ordered with <code>instrument_id</code> first to ensure that all bars for the same instrument are physically clustered together on disk, optimizing sequential reads for time-series queries and backtesting operations.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this bar belongs to. Part of the composite primary key <code>rtype</code> INTEGER NOT NULL, PK Databento record type code indicating the bar duration: 32=1-second, 33=1-minute, 34=1-hour, 35=1-day, 36=end-of-day. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp marking the beginning of the bar interval, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>open</code> INTEGER NOT NULL The first traded price during the bar interval, stored as fixed-point integer with \\(10^9\\) scale factor for nanosecond price precision <code>high</code> INTEGER NOT NULL The highest traded price during the bar interval, stored as fixed-point integer with \\(10^9\\) scale factor <code>low</code> INTEGER NOT NULL The lowest traded price during the bar interval, stored as fixed-point integer with \\(10^9\\) scale factor <code>close</code> INTEGER NOT NULL The last traded price during the bar interval, stored as fixed-point integer with \\(10^9\\) scale factor <code>volume</code> INTEGER NOT NULL The total number of contracts or shares traded during the bar interval. Represents the sum of all trade sizes <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree, eliminating the overhead of rowid indirection and reducing storage requirements for this high-volume table.</p> <pre><code>CREATE TABLE ohlcv (\n    instrument_id INTEGER NOT NULL,\n    rtype INTEGER NOT NULL CHECK(rtype IN (32, 33, 34, 35, 36)),\n    ts_event INTEGER NOT NULL,\n    open INTEGER NOT NULL,\n    high INTEGER NOT NULL,\n    low INTEGER NOT NULL CHECK(low &lt;= high),\n    close INTEGER NOT NULL,\n    volume INTEGER NOT NULL CHECK(volume &gt;= 0),\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, rtype, ts_event)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#trades","title":"Trades","text":"<p>Individual trade execution records sourced from Databento's <code>Mbp0Msg</code> (trades schema).</p> <p>This table captures every individual trade that occurs on the exchange, providing the highest granularity of execution data available. Each row represents a single match between a buyer and seller, recording the exact price, quantity, and timing of the transaction.</p> <p>Trade data is essential for transaction cost analysis (TCA), market microstructure research, VWAP/TWAP calculations, and high-frequency trading strategies. The <code>side</code> field indicates which side of the order book was the aggressor (the party that crossed the spread to execute immediately).</p> <p>The composite primary key includes <code>sequence</code> in addition to timestamp because modern exchanges can execute multiple trades within the same nanosecond, particularly during periods of high volatility or when large orders are filled across multiple price levels.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument was traded. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the trade was executed by the exchange's matching engine, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the trade message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>price</code> INTEGER NOT NULL The execution price of the trade, stored as fixed-point integer with \\(10^9\\) scale factor for nanosecond price precision <code>size</code> INTEGER NOT NULL The number of contracts or shares that were traded in this execution <code>action</code> TEXT NOT NULL The event action type. For trades, this is always 'T' indicating a trade execution <code>side</code> TEXT NOT NULL Indicates which side was the aggressor (liquidity taker): 'A'=Ask (buyer lifted the offer), 'B'=Bid (seller hit the bid), 'N'=None/unknown <code>flags</code> INTEGER NOT NULL Bit field containing message flags including packet boundary indicators and data quality markers. See Databento documentation for bit definitions <code>depth</code> INTEGER NOT NULL The book depth level. For trades this is always 0 as trades occur at the top of book <code>ts_in_delta</code> INTEGER NOT NULL The latency between exchange transmission and capture receipt, calculated as <code>ts_recv - ts_exchange_send</code> in nanoseconds. Useful for latency analysis <code>sequence</code> INTEGER NOT NULL, PK The venue's message sequence number, used to detect gaps and ensure message ordering. Part of the composite primary key to disambiguate simultaneous trades <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree, critical for this high-volume tick data table where storage efficiency is paramount.</p> <pre><code>CREATE TABLE trades (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    size INTEGER NOT NULL CHECK(size &gt; 0),\n    action TEXT NOT NULL CHECK(action IN ('A', 'C', 'M', 'R', 'T', 'F', 'N')),\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    flags INTEGER NOT NULL,\n    depth INTEGER NOT NULL,\n    ts_in_delta INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event, sequence)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#quotes","title":"Quotes","text":"<p>Top-of-book quote updates with embedded trade information sourced from Databento's <code>Mbp1Msg</code> (mbp-1 schema).</p> <p>This table captures every change to the best bid and offer (BBO) along with any associated trade information. It provides a complete tick-by-tick view of the top of the order book, enabling precise spread analysis, quote-to-trade ratio calculations, and market making strategy development.</p> <p>Unlike the <code>trades</code> table which only contains executions, this table records all order book events at the top level including order additions, cancellations, and modifications. Each row includes a snapshot of the current best bid and ask after the event, making it easy to reconstruct the BBO at any point in time without maintaining order book state.</p> <p>The <code>action</code> field distinguishes between different event types: new orders being added to the book, existing orders being cancelled or modified, book clears (typically at session boundaries), and trade executions.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this quote update belongs to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the event occurred at the exchange's matching engine, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>price</code> INTEGER NOT NULL The price associated with the order book event (the order being added/cancelled/modified, or the trade price), stored as fixed-point integer with \\(10^9\\) scale factor <code>size</code> INTEGER NOT NULL The quantity associated with the order book event (the order size being added/cancelled/modified, or the trade size) <code>action</code> TEXT NOT NULL The type of order book event: 'A'=Add (new order), 'C'=Cancel, 'M'=Modify, 'R'=Clear (book reset), 'T'=Trade execution <code>side</code> TEXT NOT NULL The side of the order book affected: 'A'=Ask (sell side), 'B'=Bid (buy side), 'N'=None (for trades or unclear) <code>flags</code> INTEGER NOT NULL Bit field containing message flags including packet boundary indicators and data quality markers. See Databento documentation for bit definitions <code>depth</code> INTEGER NOT NULL The price level in the order book where this event occurred. For top-of-book data this is typically 0 (best price) <code>ts_in_delta</code> INTEGER NOT NULL The latency between exchange transmission and capture receipt, calculated as <code>ts_recv - ts_exchange_send</code> in nanoseconds <code>sequence</code> INTEGER NOT NULL, PK The venue's message sequence number for ordering and gap detection. Part of the composite primary key to disambiguate simultaneous events <code>bid_px</code> INTEGER NOT NULL The best bid price after this event, stored as fixed-point integer with \\(10^9\\) scale factor. Represents the highest price buyers are willing to pay <code>ask_px</code> INTEGER NOT NULL The best ask price after this event, stored as fixed-point integer with \\(10^9\\) scale factor. Represents the lowest price sellers are willing to accept <code>bid_sz</code> INTEGER NOT NULL The total quantity available at the best bid price after this event <code>ask_sz</code> INTEGER NOT NULL The total quantity available at the best ask price after this event <code>bid_ct</code> INTEGER NOT NULL The number of individual orders resting at the best bid price, useful for understanding order book fragmentation <code>ask_ct</code> INTEGER NOT NULL The number of individual orders resting at the best ask price, useful for understanding order book fragmentation <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree, critical for this high-volume tick data table.</p> <pre><code>CREATE TABLE quotes (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    size INTEGER NOT NULL,\n    action TEXT NOT NULL CHECK(action IN ('A', 'C', 'M', 'R', 'T', 'F', 'N')),\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    flags INTEGER NOT NULL,\n    depth INTEGER NOT NULL,\n    ts_in_delta INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    bid_px INTEGER NOT NULL,\n    ask_px INTEGER NOT NULL,\n    bid_sz INTEGER NOT NULL CHECK(bid_sz &gt;= 0),\n    ask_sz INTEGER NOT NULL CHECK(ask_sz &gt;= 0),\n    bid_ct INTEGER NOT NULL,\n    ask_ct INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event, sequence)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#bbo","title":"BBO","text":"<p>Subsampled best bid/offer (BBO) snapshots sourced from Databento's <code>BboMsg</code> (bbo-1s, bbo-1m schemas).</p> <p>This table stores periodic snapshots of the best bid and offer at regular time intervals, providing a compressed view of top-of-book data that is more storage-efficient than full tick data while still capturing the essential spread dynamics.</p> <p>Unlike the <code>quotes</code> table which records every individual order book event, this table contains only one record per time interval (1-second or 1-minute), representing the state of the BBO at the end of each interval. This makes it ideal for strategies that don't require tick-by-tick granularity but still need accurate spread information.</p> <p>Each snapshot also includes information about the last trade that occurred during the interval (if any), providing a convenient way to correlate quote and trade data without joining multiple tables.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this BBO snapshot belongs to. Part of the composite primary key <code>rtype</code> INTEGER NOT NULL, PK Databento record type code indicating the snapshot interval: 195=1-second snapshots, 196=1-minute snapshots. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp marking the end of the snapshot interval, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the snapshot message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>price</code> INTEGER NOT NULL The price of the last trade during the interval, stored as fixed-point integer with \\(10^9\\) scale factor. Set to UNDEF_PRICE if no trade occurred <code>size</code> INTEGER NOT NULL The size of the last trade during the interval. Set to 0 if no trade occurred during the interval <code>side</code> TEXT NOT NULL The aggressor side of the last trade during the interval: 'A'=Ask (buyer lifted offer), 'B'=Bid (seller hit bid), 'N'=None (no trade or unknown) <code>flags</code> INTEGER NOT NULL Bit field containing message flags including data quality markers. See Databento documentation for bit definitions <code>sequence</code> INTEGER NOT NULL The venue's message sequence number of the last update that affected this snapshot, useful for synchronization <code>bid_px</code> INTEGER NOT NULL The best bid price at the end of the interval, stored as fixed-point integer with \\(10^9\\) scale factor <code>ask_px</code> INTEGER NOT NULL The best ask price at the end of the interval, stored as fixed-point integer with \\(10^9\\) scale factor <code>bid_sz</code> INTEGER NOT NULL The total quantity available at the best bid price at the end of the interval <code>ask_sz</code> INTEGER NOT NULL The total quantity available at the best ask price at the end of the interval <code>bid_ct</code> INTEGER NOT NULL The number of individual orders resting at the best bid price at the end of the interval <code>ask_ct</code> INTEGER NOT NULL The number of individual orders resting at the best ask price at the end of the interval <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree for efficient storage and retrieval of time-series data.</p> <pre><code>CREATE TABLE bbo (\n    instrument_id INTEGER NOT NULL,\n    rtype INTEGER NOT NULL CHECK(rtype IN (195, 196)),\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    size INTEGER NOT NULL,\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    flags INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    bid_px INTEGER NOT NULL,\n    ask_px INTEGER NOT NULL,\n    bid_sz INTEGER NOT NULL CHECK(bid_sz &gt;= 0),\n    ask_sz INTEGER NOT NULL CHECK(ask_sz &gt;= 0),\n    bid_ct INTEGER NOT NULL,\n    ask_ct INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, rtype, ts_event)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#mbo","title":"MBO","text":"<p>Market-by-order (MBO) event data sourced from Databento's <code>MboMsg</code> (mbo schema).</p> <p>This table contains the highest fidelity order book data available, tracking every individual order throughout its lifecycle from submission to completion. Each row represents a single event affecting a specific order, enabling complete reconstruction of the order book state at any point in time.</p> <p>MBO data is essential for advanced market microstructure analysis, order flow toxicity measurement, and strategies that require understanding of individual order behavior rather than just aggregate price levels. It allows identification of specific trading patterns such as spoofing, layering, and iceberg order detection.</p> <p>The composite primary key includes <code>order_id</code> because the same timestamp and sequence number can contain events for multiple orders (e.g., when a single aggressive order matches against multiple resting orders).</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this order event belongs to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the order event occurred at the exchange's matching engine, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>order_id</code> INTEGER NOT NULL, PK The unique order identifier assigned by the exchange, used to track the order across its entire lifecycle. Part of the composite primary key <code>price</code> INTEGER NOT NULL The limit price of the order, stored as fixed-point integer with \\(10^9\\) scale factor. For market orders, this may be set to a sentinel value <code>size</code> INTEGER NOT NULL The quantity of the order. For modify events, this is the new size; for fill events, this is the filled quantity <code>flags</code> INTEGER NOT NULL Bit field containing message flags including packet boundary indicators and data quality markers. See Databento documentation for bit definitions <code>channel_id</code> INTEGER NOT NULL Databento's internal channel identifier used for data routing and synchronization across multiple feed handlers <code>action</code> TEXT NOT NULL The type of order event: 'A'=Add (new order), 'C'=Cancel, 'M'=Modify, 'R'=Clear (book reset), 'T'=Trade, 'F'=Fill (partial or complete) <code>side</code> TEXT NOT NULL The side of the order book: 'A'=Ask (sell order), 'B'=Bid (buy order), 'N'=None (for trades or unclear) <code>ts_in_delta</code> INTEGER NOT NULL The latency between exchange transmission and capture receipt, calculated as <code>ts_recv - ts_exchange_send</code> in nanoseconds <code>sequence</code> INTEGER NOT NULL, PK The venue's message sequence number for ordering and gap detection. Part of the composite primary key <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree, critical for this extremely high-volume order book data table.</p> <pre><code>CREATE TABLE mbo (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    order_id INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    size INTEGER NOT NULL,\n    flags INTEGER NOT NULL,\n    channel_id INTEGER NOT NULL,\n    action TEXT NOT NULL CHECK(action IN ('A', 'C', 'M', 'R', 'T', 'F', 'N')),\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    ts_in_delta INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event, sequence, order_id)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#mbp10","title":"MBP10","text":"<p>10-level market depth (MBP-10) snapshots sourced from Databento's <code>Mbp10Msg</code> (mbp-10 schema).</p> <p>This table provides a complete view of the top 10 price levels on both the bid and ask sides of the order book at each update. It offers a balance between the full granularity of MBO data and the minimal footprint of top-of-book (MBP-1) data, capturing enough depth to understand market liquidity structure without the storage overhead of full order book reconstruction.</p> <p>Each row contains both the triggering event (the order book change that caused this snapshot) and the resulting state of all 10 levels. This denormalized design eliminates the need for joins when analyzing depth data and ensures that each record is self-contained.</p> <p>The depth data is essential for strategies that consider liquidity beyond the best price, such as iceberg detection, depth-weighted fair value calculations, and execution algorithms that need to estimate market impact across multiple price levels.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this depth snapshot belongs to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the triggering event occurred at the exchange's matching engine, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>price</code> INTEGER NOT NULL The price associated with the triggering order book event, stored as fixed-point integer with \\(10^9\\) scale factor <code>size</code> INTEGER NOT NULL The quantity associated with the triggering order book event <code>action</code> TEXT NOT NULL The type of event that triggered this snapshot: 'A'=Add, 'C'=Cancel, 'M'=Modify, 'R'=Clear, 'T'=Trade <code>side</code> TEXT NOT NULL The side of the triggering event: 'A'=Ask, 'B'=Bid, 'N'=None <code>flags</code> INTEGER NOT NULL Bit field containing message flags including packet boundary indicators and data quality markers <code>depth</code> INTEGER NOT NULL The price level (0-9) where the triggering event occurred in the order book <code>ts_in_delta</code> INTEGER NOT NULL The latency between exchange transmission and capture receipt, calculated as <code>ts_recv - ts_exchange_send</code> in nanoseconds <code>sequence</code> INTEGER NOT NULL, PK The venue's message sequence number for ordering and gap detection. Part of the composite primary key <code>bid_px_00</code> - <code>bid_px_09</code> INTEGER NOT NULL Bid prices at levels 0 (best) through 9 (10th best), stored as fixed-point integers with \\(10^9\\) scale factor <code>ask_px_00</code> - <code>ask_px_09</code> INTEGER NOT NULL Ask prices at levels 0 (best) through 9 (10th best), stored as fixed-point integers with \\(10^9\\) scale factor <code>bid_sz_00</code> - <code>bid_sz_09</code> INTEGER NOT NULL Total quantities available at each bid price level (0-9) <code>ask_sz_00</code> - <code>ask_sz_09</code> INTEGER NOT NULL Total quantities available at each ask price level (0-9) <code>bid_ct_00</code> - <code>bid_ct_09</code> INTEGER NOT NULL Number of individual orders at each bid price level (0-9), useful for fragmentation analysis <code>ask_ct_00</code> - <code>ask_ct_09</code> INTEGER NOT NULL Number of individual orders at each ask price level (0-9), useful for fragmentation analysis <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree for efficient storage of this high-volume depth data.</p> <p>Design Note: Price levels are stored as separate columns (denormalized) rather than in a separate table to avoid expensive joins and maintain query performance for time-series analysis.</p> <pre><code>CREATE TABLE mbp10 (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    size INTEGER NOT NULL,\n    action TEXT NOT NULL CHECK(action IN ('A', 'C', 'M', 'R', 'T', 'F', 'N')),\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    flags INTEGER NOT NULL,\n    depth INTEGER NOT NULL CHECK(depth &gt;= 0 AND depth &lt;= 9),\n    ts_in_delta INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    bid_px_00 INTEGER NOT NULL, bid_px_01 INTEGER NOT NULL, bid_px_02 INTEGER NOT NULL,\n    bid_px_03 INTEGER NOT NULL, bid_px_04 INTEGER NOT NULL, bid_px_05 INTEGER NOT NULL,\n    bid_px_06 INTEGER NOT NULL, bid_px_07 INTEGER NOT NULL, bid_px_08 INTEGER NOT NULL,\n    bid_px_09 INTEGER NOT NULL,\n    ask_px_00 INTEGER NOT NULL, ask_px_01 INTEGER NOT NULL, ask_px_02 INTEGER NOT NULL,\n    ask_px_03 INTEGER NOT NULL, ask_px_04 INTEGER NOT NULL, ask_px_05 INTEGER NOT NULL,\n    ask_px_06 INTEGER NOT NULL, ask_px_07 INTEGER NOT NULL, ask_px_08 INTEGER NOT NULL,\n    ask_px_09 INTEGER NOT NULL,\n    bid_sz_00 INTEGER NOT NULL, bid_sz_01 INTEGER NOT NULL, bid_sz_02 INTEGER NOT NULL,\n    bid_sz_03 INTEGER NOT NULL, bid_sz_04 INTEGER NOT NULL, bid_sz_05 INTEGER NOT NULL,\n    bid_sz_06 INTEGER NOT NULL, bid_sz_07 INTEGER NOT NULL, bid_sz_08 INTEGER NOT NULL,\n    bid_sz_09 INTEGER NOT NULL,\n    ask_sz_00 INTEGER NOT NULL, ask_sz_01 INTEGER NOT NULL, ask_sz_02 INTEGER NOT NULL,\n    ask_sz_03 INTEGER NOT NULL, ask_sz_04 INTEGER NOT NULL, ask_sz_05 INTEGER NOT NULL,\n    ask_sz_06 INTEGER NOT NULL, ask_sz_07 INTEGER NOT NULL, ask_sz_08 INTEGER NOT NULL,\n    ask_sz_09 INTEGER NOT NULL,\n    bid_ct_00 INTEGER NOT NULL, bid_ct_01 INTEGER NOT NULL, bid_ct_02 INTEGER NOT NULL,\n    bid_ct_03 INTEGER NOT NULL, bid_ct_04 INTEGER NOT NULL, bid_ct_05 INTEGER NOT NULL,\n    bid_ct_06 INTEGER NOT NULL, bid_ct_07 INTEGER NOT NULL, bid_ct_08 INTEGER NOT NULL,\n    bid_ct_09 INTEGER NOT NULL,\n    ask_ct_00 INTEGER NOT NULL, ask_ct_01 INTEGER NOT NULL, ask_ct_02 INTEGER NOT NULL,\n    ask_ct_03 INTEGER NOT NULL, ask_ct_04 INTEGER NOT NULL, ask_ct_05 INTEGER NOT NULL,\n    ask_ct_06 INTEGER NOT NULL, ask_ct_07 INTEGER NOT NULL, ask_ct_08 INTEGER NOT NULL,\n    ask_ct_09 INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event, sequence)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#imbalance","title":"Imbalance","text":"<p>Auction imbalance data sourced from Databento's <code>ImbalanceMsg</code> (imbalance schema).</p> <p>This table captures order imbalance information disseminated by exchanges during auction periods, including market open, market close, and intraday auctions (such as volatility interruptions). Imbalance data is critical for strategies that participate in or trade around auction events.</p> <p>During an auction, the exchange periodically publishes indicative prices and the imbalance between buy and sell interest. This information helps market participants decide whether to add, modify, or cancel orders before the auction concludes. The <code>paired_qty</code> represents orders that would execute at the reference price, while <code>total_imbalance_qty</code> shows the excess on one side that would remain unfilled.</p> <p>The hypothetical clearing prices (<code>cont_book_clr_price</code>, <code>auct_interest_clr_price</code>) provide estimates of where the auction might clear under different matching scenarios, helping traders anticipate the final auction price.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this imbalance data belongs to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the imbalance message was generated by the exchange, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>ref_price</code> INTEGER NOT NULL The reference price used for calculating the imbalance, typically the last traded price or a calculated indicative price, stored as fixed-point integer with \\(10^9\\) scale factor <code>auction_time</code> INTEGER NOT NULL Reserved field for future use. May contain the scheduled auction time on some venues <code>cont_book_clr_price</code> INTEGER NOT NULL The hypothetical clearing price if both auction orders and continuous book orders were matched together, stored as fixed-point integer with \\(10^9\\) scale factor <code>auct_interest_clr_price</code> INTEGER NOT NULL The hypothetical clearing price if only auction-specific orders were matched (excluding continuous book), stored as fixed-point integer with \\(10^9\\) scale factor <code>ssr_filling_price</code> INTEGER NOT NULL Reserved field for short sale restriction filling price. May be used on venues with SSR rules <code>ind_match_price</code> INTEGER NOT NULL Reserved field for indicative match price. May contain venue-specific indicative pricing <code>upper_collar</code> INTEGER NOT NULL Reserved field for upper price collar. May contain the maximum allowed auction price on some venues <code>lower_collar</code> INTEGER NOT NULL Reserved field for lower price collar. May contain the minimum allowed auction price on some venues <code>paired_qty</code> INTEGER NOT NULL The quantity of shares/contracts that would be matched (paired) at the reference price if the auction were to execute now <code>total_imbalance_qty</code> INTEGER NOT NULL The total quantity that cannot be paired at the reference price, representing the excess on the imbalanced side <code>market_imbalance_qty</code> INTEGER NOT NULL Reserved field for market order imbalance. May contain the portion of imbalance from market orders on some venues <code>unpaired_qty</code> INTEGER NOT NULL Reserved field for unpaired quantity. May contain additional unpaired order information on some venues <code>auction_type</code> TEXT NOT NULL Venue-specific code indicating the type of auction (e.g., opening, closing, volatility, IPO). Interpretation varies by exchange <code>side</code> TEXT NOT NULL The side with excess quantity (the imbalanced side): 'A'=Ask (more sell interest), 'B'=Bid (more buy interest), 'N'=None (balanced) <code>auction_status</code> INTEGER NOT NULL Venue-specific status code indicating the current phase or state of the auction process <code>freeze_status</code> INTEGER NOT NULL Venue-specific code indicating whether the auction is frozen (no new orders accepted) or still accepting modifications <code>num_extensions</code> INTEGER NOT NULL The number of times the auction period has been extended, typically due to price volatility or significant order changes <code>unpaired_side</code> TEXT NOT NULL The side of any unpaired quantity. May differ from <code>side</code> on venues with complex auction mechanics <code>significant_imbalance</code> TEXT NOT NULL Venue-specific indicator flagging whether the imbalance is considered significant and may trigger special handling <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree for efficient storage of auction event data.</p> <pre><code>CREATE TABLE imbalance (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    ref_price INTEGER NOT NULL,\n    auction_time INTEGER NOT NULL,\n    cont_book_clr_price INTEGER NOT NULL,\n    auct_interest_clr_price INTEGER NOT NULL,\n    ssr_filling_price INTEGER NOT NULL,\n    ind_match_price INTEGER NOT NULL,\n    upper_collar INTEGER NOT NULL,\n    lower_collar INTEGER NOT NULL,\n    paired_qty INTEGER NOT NULL,\n    total_imbalance_qty INTEGER NOT NULL,\n    market_imbalance_qty INTEGER NOT NULL,\n    unpaired_qty INTEGER NOT NULL,\n    auction_type TEXT NOT NULL,\n    side TEXT NOT NULL CHECK(side IN ('A', 'B', 'N')),\n    auction_status INTEGER NOT NULL,\n    freeze_status INTEGER NOT NULL,\n    num_extensions INTEGER NOT NULL CHECK(num_extensions &gt;= 0),\n    unpaired_side TEXT NOT NULL CHECK(unpaired_side IN ('A', 'B', 'N')),\n    significant_imbalance TEXT NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#statistics","title":"Statistics","text":"<p>Venue statistics and reference data sourced from Databento's <code>StatMsg</code> (statistics schema).</p> <p>This table serves as a flexible container for various statistical values disseminated by exchanges and data vendors. It captures a wide range of reference data including settlement prices, open interest, trading volumes, price limits, and other venue-specific metrics that don't fit into the standard market data tables.</p> <p>The schema uses a generic structure where the <code>stat_type</code> field identifies what kind of statistic is being recorded, and either <code>price</code> or <code>quantity</code> contains the actual value depending on whether the statistic is price-based or quantity-based. This design allows the table to accommodate new statistic types without schema changes.</p> <p>Common use cases include tracking daily settlement prices for futures (critical for mark-to-market calculations), monitoring open interest changes, and capturing exchange- published reference prices used for margin calculations.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this statistic belongs to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the statistic was generated or became effective, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>ts_ref</code> INTEGER NOT NULL The reference timestamp that the statistic applies to (e.g., the trading date for a settlement price), stored as nanoseconds since Unix epoch <code>price</code> INTEGER NOT NULL The value for price-based statistics (e.g., settlement price, high/low limits), stored as fixed-point integer with \\(10^9\\) scale factor. Set to UNDEF_PRICE for non-price statistics <code>quantity</code> INTEGER NOT NULL The value for quantity-based statistics (e.g., open interest, volume), stored as an integer. Set to UNDEF_STAT_QUANTITY for price-based statistics <code>sequence</code> INTEGER NOT NULL, PK The venue's message sequence number for ordering. Part of the composite primary key to handle multiple statistics at the same timestamp <code>ts_in_delta</code> INTEGER NOT NULL The latency between exchange transmission and capture receipt, calculated as <code>ts_recv - ts_exchange_send</code> in nanoseconds <code>stat_type</code> INTEGER NOT NULL, PK Databento's StatType enum value identifying the type of statistic (e.g., settlement, open interest, volume). Part of the composite primary key <code>channel_id</code> INTEGER NOT NULL Databento's internal channel identifier used for data routing and synchronization <code>update_action</code> INTEGER NOT NULL Indicates whether this is a new statistic (1=Added) or a correction/deletion of a previous value (2=Deleted) <code>stat_flags</code> INTEGER NOT NULL Additional venue-specific flags that provide context for certain statistic types (e.g., preliminary vs. final settlement) <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree for efficient storage and retrieval of statistical data.</p> <pre><code>CREATE TABLE statistics (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    ts_ref INTEGER NOT NULL,\n    price INTEGER NOT NULL,\n    quantity INTEGER NOT NULL,\n    sequence INTEGER NOT NULL,\n    ts_in_delta INTEGER NOT NULL,\n    stat_type INTEGER NOT NULL,\n    channel_id INTEGER NOT NULL,\n    update_action INTEGER NOT NULL CHECK(update_action IN (1, 2)),\n    stat_flags INTEGER NOT NULL,\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event, stat_type, sequence)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#status","title":"Status","text":"<p>Trading status updates sourced from Databento's <code>StatusMsg</code> (status schema).</p> <p>This table tracks changes to the trading state of instruments, including market opens, closes, trading halts, and regulatory restrictions. Status information is critical for trading systems to know when they can submit orders and when trading is suspended.</p> <p>Trading halts can occur for various reasons including scheduled market closures, circuit breakers triggered by price volatility, pending news announcements, or regulatory actions. The <code>reason</code> field provides context for why the status changed, while <code>action</code> describes what type of change occurred.</p> <p>The boolean flags (<code>is_trading</code>, <code>is_quoting</code>, <code>is_short_sell_restricted</code>) provide a quick way to check the current trading permissions without needing to interpret the venue-specific action and reason codes.</p> Field Type Constraints Description <code>instrument_id</code> INTEGER NOT NULL, FK, PK Foreign key reference to <code>instruments.instrument_id</code> identifying which instrument this status update applies to. Part of the composite primary key <code>ts_event</code> INTEGER NOT NULL, PK The timestamp when the status change occurred or became effective, stored as nanoseconds since Unix epoch. Part of the composite primary key <code>ts_recv</code> INTEGER NOT NULL The timestamp when the message was received by Databento's capture infrastructure, stored as nanoseconds since Unix epoch <code>action</code> INTEGER NOT NULL Venue-specific code indicating the type of status change (e.g., halt, resume, open, close). Interpretation varies by exchange <code>reason</code> INTEGER NOT NULL Venue-specific code explaining why the status changed (e.g., scheduled close, volatility halt, news pending). Interpretation varies by exchange <code>trading_event</code> INTEGER NOT NULL Venue-specific code describing the effect on trading activity (e.g., no change, trading suspended, trading resumed) <code>is_trading</code> TEXT NOT NULL TriState flag indicating whether continuous trading is currently active: 'Y'=trading allowed, 'N'=trading suspended, '~'=unknown/not applicable <code>is_quoting</code> TEXT NOT NULL TriState flag indicating whether market makers can submit quotes: 'Y'=quoting allowed, 'N'=quoting suspended, '~'=unknown. May differ from <code>is_trading</code> during pre-open <code>is_short_sell_restricted</code> TEXT NOT NULL TriState flag indicating whether short selling restrictions are in effect (e.g., SEC Rule 201 uptick rule): 'Y'=restricted, 'N'=unrestricted, '~'=unknown <p>Optimization: Uses <code>WITHOUT ROWID</code> to store data directly in the primary key B-tree for efficient storage of status event data.</p> <pre><code>CREATE TABLE status (\n    instrument_id INTEGER NOT NULL,\n    ts_event INTEGER NOT NULL,\n    ts_recv INTEGER NOT NULL,\n    action INTEGER NOT NULL,\n    reason INTEGER NOT NULL,\n    trading_event INTEGER NOT NULL,\n    is_trading TEXT NOT NULL CHECK(is_trading IN ('Y', 'N', '~')),\n    is_quoting TEXT NOT NULL CHECK(is_quoting IN ('Y', 'N', '~')),\n    is_short_sell_restricted TEXT NOT NULL CHECK(is_short_sell_restricted IN ('Y', 'N', '~')),\n    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id),\n    PRIMARY KEY (instrument_id, ts_event)\n) WITHOUT ROWID;\n</code></pre>"},{"location":"api-reference/secmaster/schema/#symbology","title":"Symbology","text":"<p>Ticker symbol to instrument ID mappings over time sourced from Databento's symbology.json.</p> <p>This table maps human-readable ticker symbols (e.g., \"AAPL\", \"MSFT\") to the numeric instrument IDs used in market data records. The mapping is time-bounded because instrument IDs can change over time due to:</p> <ul> <li>Publisher remapping: Some venues reassign numeric IDs periodically (even daily)</li> <li>Delistings and relistings: When a symbol is delisted and later relisted, it may receive a new instrument ID</li> <li>Corporate actions: Mergers, spin-offs, and ticker changes can result in new IDs</li> </ul> <p>Each row represents a single mapping that is valid for a specific date range. To look up the symbol for a given instrument_id at a specific point in time, query with:</p> <p>SELECT symbol FROM symbology WHERE instrument_id = ? AND date(?, 'unixepoch') BETWEEN start_date AND end_date</p> <p>Note: The instrument_id in this table corresponds to the raw_instrument_id in the instruments table (the publisher's native ID), not the auto-generated instrument_id primary key.</p> Field Type Constraints Description <code>symbol</code> TEXT NOT NULL, PK The ticker symbol as provided by the publisher (e.g., \"AAPL\", \"ESH5\"). Part of the composite primary key <code>instrument_id</code> INTEGER NOT NULL, PK The numeric instrument ID assigned by the publisher. Part of the composite primary key <code>start_date</code> TEXT NOT NULL, PK The first date (inclusive) when this mapping is valid, in YYYY-MM-DD format. Part of the composite primary key <code>end_date</code> TEXT NOT NULL The last date (inclusive) when this mapping is valid, in YYYY-MM-DD format <pre><code>CREATE TABLE symbology (\n    symbol TEXT NOT NULL,\n    instrument_id INTEGER NOT NULL,\n    start_date TEXT NOT NULL,\n    end_date TEXT NOT NULL,\n    PRIMARY KEY (symbol, instrument_id, start_date)\n);\n</code></pre>"},{"location":"api-reference/secmaster/utils/","title":"Utils","text":""},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.BATCH_SIZE","title":"<code>BATCH_SIZE = 10000</code>  <code>module-attribute</code>","text":""},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.create_secmaster_db","title":"<code>create_secmaster_db(db_path)</code>","text":"<p>Initialize a new secmaster database at the specified path.</p> <p>Creates the database file with the schema defined in ./schema.sql but does not populate any data.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Path</code> <p>Path where the database file will be created.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The path where the database was created.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If a database already exists at the path.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def create_secmaster_db(db_path: pathlib.Path) -&gt; pathlib.Path:\n    \"\"\"\n    Initialize a new secmaster database at the specified path.\n\n    Creates the database file with the schema defined in ./schema.sql but does not\n    populate any data.\n\n    Args:\n        db_path: Path where the database file will be created.\n\n    Returns:\n        The path where the database was created.\n\n    Raises:\n        FileExistsError: If a database already exists at the path.\n    \"\"\"\n\n    if db_path.exists():\n        raise FileExistsError(f\"Database already exists: {db_path}\")\n    db_path.parent.mkdir(parents=True, exist_ok=True)\n\n    connection = sqlite3.connect(str(db_path))\n\n    schema_path = pathlib.Path(__file__).parent / \"schema.sql\"\n    connection.executescript(schema_path.read_text())\n\n    connection.commit()\n    connection.close()\n    return db_path\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_symbology","title":"<code>ingest_symbology(json_path, db_path)</code>","text":"<p>Ingest symbology mappings from a Databento symbology.json file into the database.</p> <p>Parses the symbology.json file which maps ticker symbols to instrument IDs with date ranges, and inserts the mappings into the symbology table.</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>Path</code> <p>Path to the symbology.json file.</p> required <code>db_path</code> <code>Path</code> <p>Path to the secmaster SQLite database.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of symbology records inserted.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the JSON file does not exist.</p> <code>Error</code> <p>If a database error occurs during ingestion.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_symbology(json_path: pathlib.Path, db_path: pathlib.Path) -&gt; int:\n    \"\"\"\n    Ingest symbology mappings from a Databento symbology.json file into the database.\n\n    Parses the symbology.json file which maps ticker symbols to instrument IDs with\n    date ranges, and inserts the mappings into the symbology table.\n\n    Args:\n        json_path: Path to the symbology.json file.\n        db_path: Path to the secmaster SQLite database.\n\n    Returns:\n        The number of symbology records inserted.\n\n    Raises:\n        FileNotFoundError: If the JSON file does not exist.\n        sqlite3.Error: If a database error occurs during ingestion.\n    \"\"\"\n    connection = sqlite3.connect(str(db_path))\n    _enable_bulk_loading(connection)\n    try:\n        count = _ingest_symbology_with_connection(json_path, connection)\n        connection.commit()\n    finally:\n        _disable_bulk_loading(connection)\n        connection.close()\n    return count\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_symbology_with_connection","title":"<code>_ingest_symbology_with_connection(json_path, connection)</code>","text":"<p>Ingest symbology using an existing connection. Uses batch inserts for performance.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_symbology_with_connection(\n    json_path: pathlib.Path, connection: sqlite3.Connection\n) -&gt; int:\n    \"\"\"\n    Ingest symbology using an existing connection. Uses batch inserts for performance.\n    \"\"\"\n    with open(json_path, \"r\") as f:\n        data = json.load(f)\n\n    result = data.get(\"result\", {})\n    cursor = connection.cursor()\n\n    batch = []\n    count = 0\n    for symbol, mappings in result.items():\n        for mapping in mappings:\n            batch.append((symbol, int(mapping[\"s\"]), mapping[\"d0\"], mapping[\"d1\"]))\n            count += 1\n            if len(batch) &gt;= BATCH_SIZE:\n                cursor.executemany(\n                    \"INSERT OR REPLACE INTO symbology \"\n                    \"(symbol, instrument_id, start_date, end_date) \"\n                    \"VALUES (?, ?, ?, ?)\",\n                    batch,\n                )\n                batch.clear()\n\n    if batch:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO symbology \"\n            \"(symbol, instrument_id, start_date, end_date) \"\n            \"VALUES (?, ?, ?, ?)\",\n            batch,\n        )\n\n    return count\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._enable_bulk_loading","title":"<code>_enable_bulk_loading(connection)</code>","text":"<p>Configure SQLite for fast bulk loading.</p> <p>Disables safety features that slow down bulk inserts. The tradeoff is that if the process crashes or power fails during import, the database may be corrupted and need to be recreated. This is acceptable for bulk imports where the source data is preserved and the import can be re-run.</p> Settings <ul> <li>synchronous=OFF: Don't wait for disk writes to complete</li> <li>journal_mode=OFF: Disable rollback journal (no crash recovery)</li> <li>cache_size=-64000: Use 64MB of memory for cache (negative = KB)</li> </ul> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _enable_bulk_loading(connection: sqlite3.Connection) -&gt; None:\n    \"\"\"\n    Configure SQLite for fast bulk loading.\n\n    Disables safety features that slow down bulk inserts. The tradeoff is that if the\n    process crashes or power fails during import, the database may be corrupted and\n    need to be recreated. This is acceptable for bulk imports where the source data\n    is preserved and the import can be re-run.\n\n    Settings:\n        - synchronous=OFF: Don't wait for disk writes to complete\n        - journal_mode=OFF: Disable rollback journal (no crash recovery)\n        - cache_size=-64000: Use 64MB of memory for cache (negative = KB)\n    \"\"\"\n    connection.execute(\"PRAGMA synchronous = OFF\")\n    connection.execute(\"PRAGMA journal_mode = OFF\")\n    connection.execute(\"PRAGMA cache_size = -64000\")\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._disable_bulk_loading","title":"<code>_disable_bulk_loading(connection)</code>","text":"<p>Restore SQLite to safe default settings after bulk loading.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _disable_bulk_loading(connection: sqlite3.Connection) -&gt; None:\n    \"\"\"\n    Restore SQLite to safe default settings after bulk loading.\n    \"\"\"\n    connection.execute(\"PRAGMA synchronous = FULL\")\n    connection.execute(\"PRAGMA journal_mode = DELETE\")\n    connection.execute(\"PRAGMA cache_size = -2000\")\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_dbzip","title":"<code>ingest_dbzip(zip_path, db_path)</code>","text":"<p>Ingest market data from a Databento zip archive into the secmaster database.</p> <p>Extracts all <code>.dbn.zst</code> files from the zip and ingests each one. Also ingests symbology.json if present in the archive.</p> <p>Uses optimized SQLite settings for fast bulk loading. These settings disable crash recovery, so if the import is interrupted, the database may need to be recreated. The source zip file is not modified.</p> <p>Parameters:</p> Name Type Description Default <code>zip_path</code> <code>Path</code> <p>Path to the zip archive containing DBN files.</p> required <code>db_path</code> <code>Path</code> <p>Path to the secmaster SQLite database.</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>A tuple of (dbn_record_count, symbology_record_count).</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_dbzip(zip_path: pathlib.Path, db_path: pathlib.Path) -&gt; tuple[int, int]:\n    \"\"\"\n    Ingest market data from a Databento zip archive into the secmaster database.\n\n    Extracts all `.dbn.zst` files from the zip and ingests each one. Also ingests\n    symbology.json if present in the archive.\n\n    Uses optimized SQLite settings for fast bulk loading. These settings disable\n    crash recovery, so if the import is interrupted, the database may need to be\n    recreated. The source zip file is not modified.\n\n    Args:\n        zip_path: Path to the zip archive containing DBN files.\n        db_path: Path to the secmaster SQLite database.\n\n    Returns:\n        A tuple of (dbn_record_count, symbology_record_count).\n    \"\"\"\n    dbn_count = 0\n    symbology_count = 0\n\n    connection = sqlite3.connect(str(db_path))\n    _enable_bulk_loading(connection)\n\n    try:\n        with zipfile.ZipFile(zip_path, \"r\") as zf:\n            namelist = zf.namelist()\n            dbn_files = [\n                n for n in namelist if n.endswith(\".dbn.zst\") or n.endswith(\".dbn\")\n            ]\n            with tempfile.TemporaryDirectory() as tmpdir:\n                for name in tqdm(dbn_files, desc=\"Ingesting DBN files\", unit=\"file\"):\n                    zf.extract(name, tmpdir)\n                    extracted_path = pathlib.Path(tmpdir) / name\n                    dbn_count += _ingest_dbn_with_connection(extracted_path, connection)\n\n                if \"symbology.json\" in namelist:\n                    zf.extract(\"symbology.json\", tmpdir)\n                    symbology_path = pathlib.Path(tmpdir) / \"symbology.json\"\n                    symbology_count = _ingest_symbology_with_connection(\n                        symbology_path, connection\n                    )\n\n        connection.commit()\n    finally:\n        _disable_bulk_loading(connection)\n        connection.close()\n\n    return dbn_count, symbology_count\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils.ingest_dbn","title":"<code>ingest_dbn(dbn_path, db_path)</code>","text":"<p>Ingest market data from a Databento Binary Encoding (DBN) file into the secmaster database.</p> <p>Reads records from the DBN file and inserts them into the appropriate tables based on their record type (rtype). Supports both uncompressed <code>.dbn</code> files and zstd-compressed <code>.dbn.zst</code> files.</p> <p>Parameters:</p> Name Type Description Default <code>dbn_path</code> <code>Path</code> <p>Path to the DBN file to ingest.</p> required <code>db_path</code> <code>Path</code> <p>Path to the secmaster SQLite database.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of records successfully ingested.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the DBN file does not exist.</p> <code>Error</code> <p>If a database error occurs during ingestion.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def ingest_dbn(dbn_path: pathlib.Path, db_path: pathlib.Path) -&gt; int:\n    \"\"\"\n    Ingest market data from a Databento Binary Encoding (DBN) file into the secmaster database.\n\n    Reads records from the DBN file and inserts them into the appropriate tables based on\n    their record type (rtype). Supports both uncompressed `.dbn` files and zstd-compressed\n    `.dbn.zst` files.\n\n    Args:\n        dbn_path: Path to the DBN file to ingest.\n        db_path: Path to the secmaster SQLite database.\n\n    Returns:\n        The number of records successfully ingested.\n\n    Raises:\n        FileNotFoundError: If the DBN file does not exist.\n        sqlite3.Error: If a database error occurs during ingestion.\n    \"\"\"\n    connection = sqlite3.connect(str(db_path))\n    _enable_bulk_loading(connection)\n    try:\n        count = _ingest_dbn_with_connection(dbn_path, connection)\n        connection.commit()\n    finally:\n        _disable_bulk_loading(connection)\n        connection.close()\n    return count\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._ingest_dbn_with_connection","title":"<code>_ingest_dbn_with_connection(dbn_path, connection)</code>","text":"<p>Ingest DBN file using an existing connection. Uses batch inserts for performance.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ingest_dbn_with_connection(\n    dbn_path: pathlib.Path, connection: sqlite3.Connection\n) -&gt; int:\n    \"\"\"\n    Ingest DBN file using an existing connection. Uses batch inserts for performance.\n    \"\"\"\n    store = databento.DBNStore.from_file(dbn_path)\n    cursor = connection.cursor()\n\n    batches: dict[str, list[tuple]] = {\n        \"ohlcv\": [],\n        \"trades\": [],\n        \"quotes\": [],\n        \"bbo\": [],\n        \"mbo\": [],\n        \"mbp10\": [],\n        \"imbalance\": [],\n        \"statistics\": [],\n        \"status\": [],\n        \"instruments\": [],\n    }\n\n    count = 0\n    for record in store:\n        match record:\n            case databento.OHLCVMsg():\n                batches[\"ohlcv\"].append(_ohlcv_to_tuple(record))\n            case databento.TradeMsg():\n                batches[\"trades\"].append(_trade_to_tuple(record))\n            case databento.MBP1Msg():\n                batches[\"quotes\"].append(_quote_to_tuple(record))\n            case databento.BBOMsg():\n                batches[\"bbo\"].append(_bbo_to_tuple(record))\n            case databento.MBOMsg():\n                batches[\"mbo\"].append(_mbo_to_tuple(record))\n            case databento.MBP10Msg():\n                batches[\"mbp10\"].append(_mbp10_to_tuple(record))\n            case databento.ImbalanceMsg():\n                batches[\"imbalance\"].append(_imbalance_to_tuple(record))\n            case databento.StatMsg():\n                batches[\"statistics\"].append(_statistics_to_tuple(record))\n            case databento.StatusMsg():\n                batches[\"status\"].append(_status_to_tuple(record))\n            case databento.InstrumentDefMsg():\n                batches[\"instruments\"].append(_instrument_to_tuple(record))\n        count += 1\n\n        if count % BATCH_SIZE == 0:\n            _flush_batches(cursor, batches)\n\n    _flush_batches(cursor, batches)\n    return count\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._flush_batches","title":"<code>_flush_batches(cursor, batches)</code>","text":"<p>Flush all non-empty batches to the database using executemany.</p> Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _flush_batches(cursor: sqlite3.Cursor, batches: dict) -&gt; None:\n    \"\"\"Flush all non-empty batches to the database using executemany.\"\"\"\n    if batches[\"ohlcv\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO ohlcv \"\n            \"(instrument_id, rtype, ts_event, open, high, low, close, volume) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"ohlcv\"],\n        )\n        batches[\"ohlcv\"].clear()\n\n    if batches[\"trades\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO trades \"\n            \"(instrument_id, ts_event, ts_recv, price, size, action, side, flags, depth, ts_in_delta, sequence) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"trades\"],\n        )\n        batches[\"trades\"].clear()\n\n    if batches[\"quotes\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO quotes \"\n            \"(instrument_id, ts_event, ts_recv, price, size, action, side, flags, depth, ts_in_delta, sequence, \"\n            \"bid_px, ask_px, bid_sz, ask_sz, bid_ct, ask_ct) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"quotes\"],\n        )\n        batches[\"quotes\"].clear()\n\n    if batches[\"bbo\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO bbo \"\n            \"(instrument_id, rtype, ts_event, ts_recv, price, size, side, flags, sequence, \"\n            \"bid_px, ask_px, bid_sz, ask_sz, bid_ct, ask_ct) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"bbo\"],\n        )\n        batches[\"bbo\"].clear()\n\n    if batches[\"mbo\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO mbo \"\n            \"(instrument_id, ts_event, ts_recv, order_id, price, size, flags, channel_id, action, side, ts_in_delta, sequence) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"mbo\"],\n        )\n        batches[\"mbo\"].clear()\n\n    if batches[\"mbp10\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO mbp10 \"\n            \"(instrument_id, ts_event, ts_recv, price, size, action, side, flags, depth, ts_in_delta, sequence, \"\n            \"bid_px_00, bid_px_01, bid_px_02, bid_px_03, bid_px_04, bid_px_05, bid_px_06, bid_px_07, bid_px_08, bid_px_09, \"\n            \"ask_px_00, ask_px_01, ask_px_02, ask_px_03, ask_px_04, ask_px_05, ask_px_06, ask_px_07, ask_px_08, ask_px_09, \"\n            \"bid_sz_00, bid_sz_01, bid_sz_02, bid_sz_03, bid_sz_04, bid_sz_05, bid_sz_06, bid_sz_07, bid_sz_08, bid_sz_09, \"\n            \"ask_sz_00, ask_sz_01, ask_sz_02, ask_sz_03, ask_sz_04, ask_sz_05, ask_sz_06, ask_sz_07, ask_sz_08, ask_sz_09, \"\n            \"bid_ct_00, bid_ct_01, bid_ct_02, bid_ct_03, bid_ct_04, bid_ct_05, bid_ct_06, bid_ct_07, bid_ct_08, bid_ct_09, \"\n            \"ask_ct_00, ask_ct_01, ask_ct_02, ask_ct_03, ask_ct_04, ask_ct_05, ask_ct_06, ask_ct_07, ask_ct_08, ask_ct_09) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, \"\n            \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"mbp10\"],\n        )\n        batches[\"mbp10\"].clear()\n\n    if batches[\"imbalance\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO imbalance \"\n            \"(instrument_id, ts_event, ts_recv, ref_price, auction_time, cont_book_clr_price, auct_interest_clr_price, \"\n            \"ssr_filling_price, ind_match_price, upper_collar, lower_collar, paired_qty, total_imbalance_qty, \"\n            \"market_imbalance_qty, unpaired_qty, auction_type, side, auction_status, freeze_status, num_extensions, \"\n            \"unpaired_side, significant_imbalance) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"imbalance\"],\n        )\n        batches[\"imbalance\"].clear()\n\n    if batches[\"statistics\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO statistics \"\n            \"(instrument_id, ts_event, ts_recv, ts_ref, price, quantity, sequence, ts_in_delta, stat_type, channel_id, \"\n            \"update_action, stat_flags) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"statistics\"],\n        )\n        batches[\"statistics\"].clear()\n\n    if batches[\"status\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO status \"\n            \"(instrument_id, ts_event, ts_recv, action, reason, trading_event, is_trading, is_quoting, is_short_sell_restricted) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"status\"],\n        )\n        batches[\"status\"].clear()\n\n    if batches[\"instruments\"]:\n        cursor.executemany(\n            \"INSERT OR REPLACE INTO instruments \"\n            \"(publisher_id, raw_instrument_id, raw_symbol, instrument_class, security_type, asset, cfi, exchange, currency, \"\n            \"strike_price, strike_price_currency, expiration, activation, maturity_year, maturity_month, maturity_day, \"\n            \"contract_multiplier, unit_of_measure, unit_of_measure_qty, underlying, display_factor, high_limit_price, \"\n            \"low_limit_price, min_price_increment, security_group, ts_recv) \"\n            \"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n            batches[\"instruments\"],\n        )\n        batches[\"instruments\"].clear()\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._ohlcv_to_tuple","title":"<code>_ohlcv_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _ohlcv_to_tuple(record: databento.OHLCVMsg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.rtype.value,\n        record.ts_event,\n        record.open,\n        record.high,\n        record.low,\n        record.close,\n        record.volume,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._trade_to_tuple","title":"<code>_trade_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _trade_to_tuple(record: databento.TradeMsg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.price,\n        record.size,\n        str(record.action),\n        str(record.side),\n        record.flags,\n        record.depth,\n        record.ts_in_delta,\n        record.sequence,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._quote_to_tuple","title":"<code>_quote_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _quote_to_tuple(record: databento.MBP1Msg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.price,\n        record.size,\n        str(record.action),\n        str(record.side),\n        record.flags,\n        record.depth,\n        record.ts_in_delta,\n        record.sequence,\n        record.levels[0].bid_px,\n        record.levels[0].ask_px,\n        record.levels[0].bid_sz,\n        record.levels[0].ask_sz,\n        record.levels[0].bid_ct,\n        record.levels[0].ask_ct,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._bbo_to_tuple","title":"<code>_bbo_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _bbo_to_tuple(record: databento.BBOMsg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.rtype.value,\n        record.ts_event,\n        record.ts_recv,\n        record.price,\n        record.size,\n        str(record.side),\n        record.flags,\n        record.sequence,\n        record.levels[0].bid_px,\n        record.levels[0].ask_px,\n        record.levels[0].bid_sz,\n        record.levels[0].ask_sz,\n        record.levels[0].bid_ct,\n        record.levels[0].ask_ct,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._mbo_to_tuple","title":"<code>_mbo_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _mbo_to_tuple(record: databento.MBOMsg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.order_id,\n        record.price,\n        record.size,\n        record.flags,\n        record.channel_id,\n        str(record.action),\n        str(record.side),\n        record.ts_in_delta,\n        record.sequence,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._mbp10_to_tuple","title":"<code>_mbp10_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _mbp10_to_tuple(record: databento.MBP10Msg) -&gt; tuple:\n    levels = record.levels\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.price,\n        record.size,\n        str(record.action),\n        str(record.side),\n        record.flags,\n        record.depth,\n        record.ts_in_delta,\n        record.sequence,\n        levels[0].bid_px,\n        levels[1].bid_px,\n        levels[2].bid_px,\n        levels[3].bid_px,\n        levels[4].bid_px,\n        levels[5].bid_px,\n        levels[6].bid_px,\n        levels[7].bid_px,\n        levels[8].bid_px,\n        levels[9].bid_px,\n        levels[0].ask_px,\n        levels[1].ask_px,\n        levels[2].ask_px,\n        levels[3].ask_px,\n        levels[4].ask_px,\n        levels[5].ask_px,\n        levels[6].ask_px,\n        levels[7].ask_px,\n        levels[8].ask_px,\n        levels[9].ask_px,\n        levels[0].bid_sz,\n        levels[1].bid_sz,\n        levels[2].bid_sz,\n        levels[3].bid_sz,\n        levels[4].bid_sz,\n        levels[5].bid_sz,\n        levels[6].bid_sz,\n        levels[7].bid_sz,\n        levels[8].bid_sz,\n        levels[9].bid_sz,\n        levels[0].ask_sz,\n        levels[1].ask_sz,\n        levels[2].ask_sz,\n        levels[3].ask_sz,\n        levels[4].ask_sz,\n        levels[5].ask_sz,\n        levels[6].ask_sz,\n        levels[7].ask_sz,\n        levels[8].ask_sz,\n        levels[9].ask_sz,\n        levels[0].bid_ct,\n        levels[1].bid_ct,\n        levels[2].bid_ct,\n        levels[3].bid_ct,\n        levels[4].bid_ct,\n        levels[5].bid_ct,\n        levels[6].bid_ct,\n        levels[7].bid_ct,\n        levels[8].bid_ct,\n        levels[9].bid_ct,\n        levels[0].ask_ct,\n        levels[1].ask_ct,\n        levels[2].ask_ct,\n        levels[3].ask_ct,\n        levels[4].ask_ct,\n        levels[5].ask_ct,\n        levels[6].ask_ct,\n        levels[7].ask_ct,\n        levels[8].ask_ct,\n        levels[9].ask_ct,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._imbalance_to_tuple","title":"<code>_imbalance_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _imbalance_to_tuple(record: databento.ImbalanceMsg) -&gt; tuple:\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.ref_price,\n        record.auction_time,\n        record.cont_book_clr_price,\n        record.auct_interest_clr_price,\n        record.ssr_filling_price,\n        record.ind_match_price,\n        record.upper_collar,\n        record.lower_collar,\n        record.paired_qty,\n        record.total_imbalance_qty,\n        record.market_imbalance_qty,\n        record.unpaired_qty,\n        str(record.auction_type),\n        str(record.side),\n        record.auction_status,\n        record.freeze_status,\n        record.num_extensions,\n        str(record.unpaired_side),\n        str(record.significant_imbalance),\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._statistics_to_tuple","title":"<code>_statistics_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _statistics_to_tuple(record: databento.StatMsg) -&gt; tuple:\n    stat_type = record.stat_type\n    update_action = record.update_action\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        record.ts_ref,\n        record.price,\n        record.quantity,\n        record.sequence,\n        record.ts_in_delta,\n        stat_type.value if hasattr(stat_type, \"value\") else stat_type,\n        record.channel_id,\n        update_action.value if hasattr(update_action, \"value\") else update_action,\n        record.stat_flags,\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._status_to_tuple","title":"<code>_status_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _status_to_tuple(record: databento.StatusMsg) -&gt; tuple:\n    action = record.action\n    reason = record.reason\n    trading_event = record.trading_event\n    return (\n        record.instrument_id,\n        record.ts_event,\n        record.ts_recv,\n        action.value if hasattr(action, \"value\") else action,\n        reason.value if hasattr(reason, \"value\") else reason,\n        trading_event.value if hasattr(trading_event, \"value\") else trading_event,\n        str(record.is_trading),\n        str(record.is_quoting),\n        str(record.is_short_sell_restricted),\n    )\n</code></pre>"},{"location":"api-reference/secmaster/utils/#onesecondtrader.secmaster.utils._instrument_to_tuple","title":"<code>_instrument_to_tuple(record)</code>","text":"Source code in <code>src/onesecondtrader/secmaster/utils.py</code> <pre><code>def _instrument_to_tuple(record: databento.InstrumentDefMsg) -&gt; tuple:\n    return (\n        record.publisher_id,\n        record.instrument_id,\n        record.raw_symbol,\n        str(record.instrument_class),\n        record.security_type,\n        record.asset,\n        record.cfi,\n        record.exchange,\n        record.currency,\n        record.strike_price,\n        record.strike_price_currency,\n        record.expiration,\n        record.activation,\n        record.maturity_year,\n        record.maturity_month,\n        record.maturity_day,\n        record.contract_multiplier,\n        record.unit_of_measure,\n        record.unit_of_measure_qty,\n        record.underlying,\n        record.display_factor,\n        record.high_limit_price,\n        record.low_limit_price,\n        record.min_price_increment,\n        record.group,\n        record.ts_recv,\n    )\n</code></pre>"},{"location":"documentation/overview/","title":"Read the Docs","text":"<p>At its core, the OneSecondTrader package enables users to implement a trading strategy and execute it by connecting two interchangeable components: a data feed and a broker. Both components may operate either in simulated mode\u2014using historical market data and a simulated execution layer\u2014or in live or paper-trading mode via a live data feed and a real broker API.</p> <p>A central design principle of the system is that backtesting and live trading follow the same execution flow from market data ingestion to order handling, while differing only in the concrete implementations of the data feed and broker. As a result, transitioning a strategy from historical simulation to live deployment requires no changes to the strategy code itself.</p> <p>This architectural decision ensures that any discrepancy between backtested and live performance can be attributed exclusively to the fidelity of the simulations.  On the data side, this concerns how accurately the imitation of a live datafeed from historical records approximates real-time market behavior. On the execution side, it concerns how well the simulated broker models real-world constraints such as slippage, partial fills, et cetera. </p> <p>By strictly isolating these sources of divergence, OneSecondTrader provides a controlled and transparent environment for strategy development, validation, and deployment, without the risk of structural mismatches between research and production.</p> <p>The OneSecondTrader library is organized as a top-level Python package composed of four sub-packages (<code>core</code>, <code>connectors</code>, <code>secmaster</code>, and <code>dashboard</code>), each encapsulating an architecturally distinct set of responsibilities. To get started, have a look at the package structure overview. </p>"},{"location":"documentation/structure/connectors/","title":"Connectors Package Documentation","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"},{"location":"documentation/structure/core/","title":"Core Package Documentation","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"},{"location":"documentation/structure/dashboard/","title":"Dashboard Package Documentation","text":"<p>Under Construction</p> <p>This part of the documentation is still under construction! If necessary, have a look at the API reference for now.</p>"},{"location":"documentation/structure/overview/","title":"Package Structure Overview","text":"<p>The OneSecondTrader library is organized as a top-level Python package composed of four sub-packages (<code>core</code>, <code>connectors</code>, <code>secmaster</code>, and <code>dashboard</code>), each encapsulating an architecturally distinct set of responsibilities.</p>"},{"location":"documentation/structure/overview/#core-package","title":"Core Package","text":"<p>The <code>core</code> package provides the skeleton of an event-driven trading system. It does include the definition of a set of events which are used to communicate between the different system components, an event bus for routing events to the concerned components, as well as base classes for strategies, brokers, and indicators. It does not include any datafeed component or any actual broker implementation, which are provided by the <code>connectors</code> package to isolate external dependencies from the system's core logic.</p> <p> View Core Package Documentation.</p>"},{"location":"documentation/structure/overview/#connectors-package","title":"Connectors Package","text":"<p>The <code>connectors</code> package provides actual implementations of brokers and datafeeds. This includes both the (internally) simulated broker and datafeed as well as connectors to actual live brokers and datafeeds APIs. This makes it possible for the core of the system to stay the same, while the options for connecting to actual live brokers and datafeeds can be expanded as needed.</p> <p> View Connectors Package Documentation.</p>"},{"location":"documentation/structure/overview/#securities-master-database-package","title":"Securities Master Database Package","text":"<p>The <code>secmaster</code> package provides the skeleton for a securities master database as well as some utilities to actually ingest data from various sources into this database. Simulated datafeeds (see <code>connectors</code> package) will use it as a source of market data.</p> <p> View Securities Master Database Package Documentation.</p>"},{"location":"documentation/structure/overview/#dashboard-package","title":"Dashboard Package","text":"<p>The <code>dashboard</code> package provides a web-based dashboard to view and control the runs of the trading system. A run refers to a single execution of the trading system, and is associated with a concrete instance of a strategy (or instances of multiple strategies), as well as the connected broker and datafeed.  The backend of the dashboard is organized around a database that persistently records all run-related activity on a per-run basis. The frontend is implemented as a web application that presents this information in a form suitable for both inspection  and operational decision-making. Backtests differ from live runs only in temporal behavior. Backtests complete quickly, as historical data is replayed at maximum speed, whereas live runs naturally unfold in real time.</p> <p> View Dashboard Package Documentation.</p>"},{"location":"documentation/structure/secmaster/","title":"Securities Master Database Package Documentation","text":"<p>The <code>secmaster</code> package provides schema file <code>schema.sql</code> for the securities master database as well as a module <code>utils.py</code> that provides utility functions to create and populate the database.</p> <p>The securities master database is intended to be used as a source of market data for the simulated datafeed when replaying historical data during backtesting.  It is implemented as an SQLite database. SQLite is an embedded database engine that stores the entire database in a single file and requires no server or external configuration.</p> <p>As part of this documentation page, we will provide an explanation of the schema itself and an overview of the utility functions provided to create and populate the database.</p>"},{"location":"documentation/structure/secmaster/#schema-overview","title":"Schema Overview","text":"<p>For a complete overview and explanation of the schema used by the securities master database, please refer to the API reference documentation.</p> <p> View Securities Master Database Schema Documentation.</p>"},{"location":"documentation/structure/secmaster/#utility-functions","title":"Utility Functions","text":""}]}