{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"pippoetry <pre><code>pip install onesecondtrader \n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/core/","title":"Core","text":"<p>Core module containing the backbone of OneSecondTrader's event-driven architecture.</p>"},{"location":"api-reference/core/#onesecondtrader.core.event_bus","title":"<code>event_bus = EventBus()</code>  <code>module-attribute</code>","text":"<p>Global event bus instance.</p>"},{"location":"api-reference/core/#onesecondtrader.core.Models","title":"<code>Models</code>","text":"<p>Namespace for all models.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class Models:\n    \"\"\"\n    Namespace for all models.\n    \"\"\"\n\n    class RecordType(enum.Enum):\n        OHLCV_1S = 32\n        OHLCV_1M = 33\n        OHLCV_1H = 34\n        OHLCV_1D = 35\n\n    class OrderSide(enum.Enum):\n        BUY = enum.auto()\n        SELL = enum.auto()\n\n    class OrderType(enum.Enum):\n        MARKET = enum.auto()\n        LIMIT = enum.auto()\n        STOP = enum.auto()\n        STOP_LIMIT = enum.auto()\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.Events","title":"<code>Events</code>","text":"<p>Namespace for all events.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class Events:\n    \"\"\"\n    Namespace for all events.\n    \"\"\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class BaseEvent:\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n    # SYSTEM EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class SystemShutdown(BaseEvent):\n        pass\n\n    # MARKET EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class IncomingBar(BaseEvent):\n        ts_event: pd.Timestamp\n        symbol: str\n        record_type: Models.RecordType\n        open: float\n        high: float\n        low: float\n        close: float\n        volume: int | None = None\n\n    # BROKER REQUEST EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Order(BaseEvent):\n        order_id: uuid.UUID = dataclasses.field(default_factory=lambda: uuid.uuid4())\n        symbol: str\n        order_type: Models.OrderType\n        side: Models.OrderSide\n        quantity: float\n        limit_price: float | None = None\n        stop_price: float | None = None\n\n    # BROKER RESPONSE EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Fill(BaseEvent):\n        fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n        broker_fill_id: str | None = None\n        associated_order_id: uuid.UUID\n        side: Models.OrderSide\n        quantity_filled: float\n        fill_price: float\n        commission: float\n        exchange: str = \"SIMULATED\"\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.BaseConsumer","title":"<code>BaseConsumer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all consumers.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class BaseConsumer(abc.ABC):\n    \"\"\"\n    Base class for all consumers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._queue: queue.Queue[Events.BaseEvent] = queue.Queue()\n        self._thread = threading.Thread(target=self._consume, daemon=True)\n        self._thread.start()\n\n    @abc.abstractmethod\n    def on_event(self, event: Events.BaseEvent) -&gt; None:\n        pass\n\n    def receive(self, event: Events.BaseEvent) -&gt; None:\n        self._queue.put(event)\n\n    def _consume(self) -&gt; None:\n        while True:\n            event = self._queue.get()\n            if isinstance(event, Events.SystemShutdown):\n                break\n            self.on_event(event)\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus for publishing events to the consumers subscribed to them.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class EventBus:\n    \"\"\"\n    Event bus for publishing events to the consumers subscribed to them.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._subscriptions: defaultdict[type[Events.BaseEvent], list[BaseConsumer]] = (\n            defaultdict(list)\n        )\n        self._lock: threading.Lock = threading.Lock()\n\n    def subscribe(self, subscriber: BaseConsumer, event_type: type[Events.BaseEvent]):\n        with self._lock:\n            if subscriber not in self._subscriptions[event_type]:\n                self._subscriptions[event_type].append(subscriber)\n\n    def unsubscribe(self, subscriber: BaseConsumer):\n        with self._lock:\n            for consumer_list in self._subscriptions.values():\n                if subscriber in consumer_list:\n                    consumer_list.remove(subscriber)\n\n    def publish(self, event: Events.BaseEvent) -&gt; None:\n        with self._lock:\n            consumers = list(self._subscriptions[type(event)])\n        for consumer in consumers:\n            consumer.receive(event)\n</code></pre>"},{"location":"api-reference/indicators/","title":"Indicators","text":"<p>OneSecondTrader's library of pre-built indicators.</p>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.BaseIndicator","title":"<code>BaseIndicator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for indicators. Subclasses must set the <code>name</code> property and implement the <code>_compute_indicator()</code> method. See <code>SimpleMovingAverage</code> for an example.</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class BaseIndicator(abc.ABC):\n    \"\"\"\n    Base class for indicators. Subclasses must set the `name` property and implement\n    the `_compute_indicator()` method. See `SimpleMovingAverage` for an example.\n    \"\"\"\n\n    def __init__(self, max_history: int = 100) -&gt; None:\n        self._lock = threading.Lock()\n        self._history: deque[float] = deque(maxlen=max(1, int(max_history)))\n\n    @property\n    @abc.abstractmethod\n    def name(self) -&gt; str:\n        pass\n\n    def update(self, incoming_bar: Events.IncomingBar) -&gt; None:\n        _latest_value: float = self._compute_indicator(incoming_bar)\n        with self._lock:\n            self._history.append(_latest_value)\n\n    @abc.abstractmethod\n    def _compute_indicator(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        pass\n\n    @property\n    def latest(self) -&gt; float:\n        with self._lock:\n            return self._history[-1] if self._history else np.nan\n\n    @property\n    def history(self) -&gt; deque[float]:\n        return self._history\n</code></pre>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.InputSource","title":"<code>InputSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum of supported input sources for indicators. Indicators with a <code>input_source</code> parameter can be configured to use one of these sources for their calculations.</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class InputSource(enum.Enum):\n    \"\"\"\n    Enum of supported input sources for indicators. Indicators with a `input_source`\n    parameter can be configured to use one of these sources for their calculations.\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>BaseIndicator</code></p> <p>Simple Moving Average (SMA) indicator. Can be configured to use different input sources (see <code>InputSource</code> enum, default is <code>InputSource.CLOSE</code>).</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class SimpleMovingAverage(BaseIndicator):\n    \"\"\"\n    Simple Moving Average (SMA) indicator. Can be configured to use different input\n    sources (see `InputSource` enum, default is `InputSource.CLOSE`).\n    \"\"\"\n\n    def __init__(\n        self,\n        period: int = 200,\n        max_history: int = 100,\n        input_source: InputSource = InputSource.CLOSE,\n    ) -&gt; None:\n        super().__init__(max_history=max_history)\n        self.period: int = max(1, int(period))\n        self.input_source: InputSource = input_source\n        self._window: deque[float] = deque(maxlen=self.period)\n\n    @property\n    def name(self) -&gt; str:\n        return f\"SMA_{self.period}_{self.input_source.name}\"\n\n    def _compute_indicator(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        value: float = self._extract_input(incoming_bar)\n        self._window.append(value)\n        if len(self._window) &lt; self.period:\n            return np.nan\n        return sum(self._window) / self.period\n\n    def _extract_input(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        match self.input_source:\n            case InputSource.OPEN:\n                return incoming_bar.open\n            case InputSource.HIGH:\n                return incoming_bar.high\n            case InputSource.LOW:\n                return incoming_bar.low\n            case InputSource.CLOSE:\n                return incoming_bar.close\n            case InputSource.VOLUME:\n                return (\n                    float(incoming_bar.volume)\n                    if incoming_bar.volume is not None\n                    else np.nan\n                )\n            case _:\n                return incoming_bar.close\n</code></pre>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Core </p> <p> View <code>core.py</code> API</p> </li> <li> <p>Indicators </p> <p> View <code>indicators.py</code> API</p> </li> </ul>"}]}