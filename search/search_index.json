{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The Trading Infrastructure Toolkit for Python  <p>   Research, simulate, and deploy algorithmic strategies \u2014 all in one place. </p> <p>Under Construction</p> <p>This package is under construction! OneSecondTrader is still a work in progress, but don\u2019t worry \u2013 a pre-release version is just around the corner. Grab a coffee and hang tight!</p>"},{"location":"#quickstart","title":"Quickstart","text":"pippoetry <pre><code>pip install onesecondtrader \n</code></pre> <pre><code>poetry add onesecondtrader\n</code></pre>"},{"location":"quickstart/","title":"\u2192 Quickstart","text":""},{"location":"quickstart/#redirecting","title":"Redirecting...","text":"<p>If you are not redirected automatically, click here.</p>"},{"location":"api-reference/core/","title":"Core","text":"<p>Core module containing the backbone of OneSecondTrader's event-driven architecture.</p>"},{"location":"api-reference/core/#onesecondtrader.core.event_bus","title":"<code>event_bus = EventBus()</code>  <code>module-attribute</code>","text":"<p>Global event bus instance.</p>"},{"location":"api-reference/core/#onesecondtrader.core.Models","title":"<code>Models</code>","text":"<p>Namespace for all models.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class Models:\n    \"\"\"\n    Namespace for all models.\n    \"\"\"\n\n    class RecordType(enum.Enum):\n        OHLCV_1S = 32\n        OHLCV_1M = 33\n        OHLCV_1H = 34\n        OHLCV_1D = 35\n\n    class OrderSide(enum.Enum):\n        BUY = enum.auto()\n        SELL = enum.auto()\n\n    class OrderType(enum.Enum):\n        MARKET = enum.auto()\n        LIMIT = enum.auto()\n        STOP = enum.auto()\n        STOP_LIMIT = enum.auto()\n\n    class RejectionReason(enum.Enum):\n        ORDER_ALREADY_FILLED = enum.auto()\n        ORDER_ALREADY_CANCELLED = enum.auto()\n        ORDER_PENDING_EXECUTION = enum.auto()\n        INSUFFICIENT_FUNDS = enum.auto()\n        MARKET_CLOSED = enum.auto()\n        UNKNOWN = enum.auto()\n\n    class TimeInForce(enum.Enum):\n        GTC = enum.auto()\n        DAY = enum.auto()\n        IOC = enum.auto()\n        FOK = enum.auto()\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.Events","title":"<code>Events</code>","text":"<p>Namespace for all events.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class Events:\n    \"\"\"\n    Namespace for all events.\n    \"\"\"\n\n    # BASE EVENT\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class BaseEvent:\n        ts_event: pd.Timestamp = dataclasses.field(\n            default_factory=lambda: pd.Timestamp.now(tz=\"UTC\")\n        )\n\n    # SYSTEM EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class SystemEvent(BaseEvent):\n        pass\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class SystemShutdown(SystemEvent):\n        pass\n\n    # MARKET EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class MarketEvent(BaseEvent):\n        pass\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class IncomingBar(MarketEvent):\n        ts_event: pd.Timestamp\n        symbol: str\n        record_type: Models.RecordType\n        open: float\n        high: float\n        low: float\n        close: float\n        volume: int | None = None\n\n    # BROKER REQUESTS EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class BrokerRequestEvent(BaseEvent):\n        pass\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class SubmitOrder(BrokerRequestEvent):\n        order_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n        symbol: str\n        order_type: Models.OrderType\n        side: Models.OrderSide\n        quantity: float\n        limit_price: float | None = None\n        stop_price: float | None = None\n        time_in_force: Models.TimeInForce = Models.TimeInForce.GTC\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class ModifyOrder(BrokerRequestEvent):\n        order_id: uuid.UUID\n        quantity: float | None = None\n        limit_price: float | None = None\n        stop_price: float | None = None\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelOrder(BrokerRequestEvent):\n        order_id: uuid.UUID\n\n    # BROKER RESPONSE EVENTS\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class BrokerResponseEvent(BaseEvent):\n        ts_broker: pd.Timestamp\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderSubmitted(BrokerResponseEvent):\n        order_id: uuid.UUID\n        broker_order_id: str | None = None\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderModified(BrokerResponseEvent):\n        order_id: uuid.UUID\n        broker_order_id: str | None = None\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class Fill(BrokerResponseEvent):\n        fill_id: uuid.UUID = dataclasses.field(default_factory=uuid.uuid4)\n        broker_fill_id: str | None = None\n        associated_order_id: uuid.UUID\n        symbol: str\n        side: Models.OrderSide\n        quantity_filled: float\n        fill_price: float\n        commission: float\n        exchange: str = \"SIMULATED\"\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderRejected(BrokerResponseEvent):\n        order_id: uuid.UUID\n        reason: Models.RejectionReason\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderCancelled(BrokerResponseEvent):\n        order_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class OrderExpired(BrokerResponseEvent):\n        order_id: uuid.UUID\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class CancelRejected(BrokerResponseEvent):\n        order_id: uuid.UUID\n        reason: Models.RejectionReason\n\n    @dataclasses.dataclass(kw_only=True, frozen=True)\n    class ModifyRejected(BrokerResponseEvent):\n        order_id: uuid.UUID\n        reason: Models.RejectionReason\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.BaseConsumer","title":"<code>BaseConsumer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all consumers.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class BaseConsumer(abc.ABC):\n    \"\"\"\n    Base class for all consumers.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._queue: queue.Queue[Events.BaseEvent] = queue.Queue()\n        self._thread = threading.Thread(\n            target=self._consume, name=self.__class__.__name__, daemon=True\n        )\n        self._thread.start()\n\n    @abc.abstractmethod\n    def on_event(self, event: Events.BaseEvent) -&gt; None:\n        pass\n\n    def receive(self, event: Events.BaseEvent) -&gt; None:\n        self._queue.put(event)\n\n    def _consume(self) -&gt; None:\n        while True:\n            event = self._queue.get()\n            if isinstance(event, Events.SystemShutdown):\n                break\n            self.on_event(event)\n</code></pre>"},{"location":"api-reference/core/#onesecondtrader.core.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus for publishing events to the consumers subscribed to them.</p> Source code in <code>src/onesecondtrader/core.py</code> <pre><code>class EventBus:\n    \"\"\"\n    Event bus for publishing events to the consumers subscribed to them.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._subscriptions: defaultdict[type[Events.BaseEvent], list[BaseConsumer]] = (\n            defaultdict(list)\n        )\n        self._lock: threading.Lock = threading.Lock()\n\n    def subscribe(self, subscriber: BaseConsumer, event_type: type[Events.BaseEvent]):\n        with self._lock:\n            if subscriber not in self._subscriptions[event_type]:\n                self._subscriptions[event_type].append(subscriber)\n\n    def unsubscribe(self, subscriber: BaseConsumer):\n        with self._lock:\n            for consumer_list in self._subscriptions.values():\n                if subscriber in consumer_list:\n                    consumer_list.remove(subscriber)\n\n    def publish(self, event: Events.BaseEvent) -&gt; None:\n        with self._lock:\n            consumers = list(self._subscriptions[type(event)])\n        for consumer in consumers:\n            consumer.receive(event)\n</code></pre>"},{"location":"api-reference/datafeeds/","title":"Datafeeds","text":""},{"location":"api-reference/datafeeds/#onesecondtrader.datafeeds.simulated_datafeed_csv","title":"<code>simulated_datafeed_csv = SimulatedDatafeedCSV()</code>  <code>module-attribute</code>","text":"<p>Global instance of SimulatedDatafeedCSV.</p>"},{"location":"api-reference/datafeeds/#onesecondtrader.datafeeds.DatafeedBase","title":"<code>DatafeedBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all datafeeds.</p> Source code in <code>src/onesecondtrader/datafeeds.py</code> <pre><code>class DatafeedBase(abc.ABC):\n    \"\"\"\n    Base class for all datafeeds.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._is_connected: bool = False\n        self._watched_symbols: set[tuple[str, Models.RecordType]] = set()\n        self._lock: threading.Lock = threading.Lock()\n\n    @abc.abstractmethod\n    def watch(self, symbols: list[tuple[str, Models.RecordType]]) -&gt; bool:\n        pass\n\n    @abc.abstractmethod\n    def unwatch(self, symbols: list[str]) -&gt; None:\n        pass\n</code></pre>"},{"location":"api-reference/datafeeds/#onesecondtrader.datafeeds.SimulatedDatafeedCSV","title":"<code>SimulatedDatafeedCSV</code>","text":"<p>               Bases: <code>DatafeedBase</code></p> <p>CSV-based simulated datafeed for backtesting.</p> Source code in <code>src/onesecondtrader/datafeeds.py</code> <pre><code>class SimulatedDatafeedCSV(DatafeedBase):\n    \"\"\"\n    CSV-based simulated datafeed for backtesting.\n    \"\"\"\n\n    csv_path: str | Path = \"\"\n    artificial_delay: float = 0.0\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._stop_event = threading.Event()\n        self._streaming_thread: threading.Thread | None = None\n        self._data_iterator: pd.io.parsers.readers.TextFileReader | None = None\n        self._connected_path: str | Path = \"\"\n\n    def watch(self, symbols: list[tuple[str, Models.RecordType]]) -&gt; bool:\n        with self._lock:\n            if not self._is_connected:\n                try:\n                    self._data_iterator = pd.read_csv(\n                        Path(self.csv_path),\n                        usecols=[\n                            \"ts_event\",\n                            \"rtype\",\n                            \"open\",\n                            \"high\",\n                            \"low\",\n                            \"close\",\n                            \"volume\",\n                            \"symbol\",\n                        ],\n                        dtype={\n                            \"ts_event\": int,\n                            \"rtype\": int,\n                            \"open\": int,\n                            \"high\": int,\n                            \"low\": int,\n                            \"close\": int,\n                            \"volume\": int,\n                            \"symbol\": str,\n                        },\n                        chunksize=1,\n                    )\n                    self._is_connected = True\n                    self._connected_path = self.csv_path\n                    logger.info(\n                        f\"{self.__class__.__name__} connected to {self.csv_path}\"\n                    )\n                except Exception as e:\n                    logger.error(f\"{self.__class__.__name__} failed to connect: {e}\")\n                    self._data_iterator = None\n                    self._is_connected = False\n                    return False\n            elif self._connected_path != self.csv_path:\n                logger.warning(\n                    \"csv_path changed while connected; unwatch all symbols first\"\n                )\n\n            self._watched_symbols.update(symbols)\n            formatted = \", \".join(f\"{s} ({r.name})\" for s, r in symbols)\n            logger.info(f\"{self.__class__.__name__} watching {formatted}\")\n\n            if not self._streaming_thread or not self._streaming_thread.is_alive():\n                self._stop_event.clear()\n                self._streaming_thread = threading.Thread(\n                    target=self._stream, name=\"CSVDatafeedStreaming\", daemon=False\n                )\n                self._streaming_thread.start()\n\n        return True\n\n    def unwatch(self, symbols: list[str]) -&gt; None:\n        thread_to_join = None\n        with self._lock:\n            symbols_set = set(symbols)\n            self._watched_symbols.difference_update(\n                {\n                    (symbol, rtype)\n                    for (symbol, rtype) in self._watched_symbols\n                    if symbol in symbols_set\n                }\n            )\n            logger.info(f\"{self.__class__.__name__} unwatched {', '.join(symbols)}\")\n            if not self._watched_symbols:\n                self._stop_event.set()\n                thread_to_join = self._streaming_thread\n                self._streaming_thread = None\n\n        if thread_to_join and thread_to_join.is_alive():\n            thread_to_join.join(timeout=5.0)\n            if thread_to_join.is_alive():\n                logger.warning(\"Streaming thread did not terminate within timeout\")\n            else:\n                logger.info(f\"{self.__class__.__name__} disconnected\")\n\n    def _stream(self) -&gt; None:\n        if self._data_iterator is None:\n            logger.error(\"_stream called with no data iterator\")\n            return\n        should_delay = self.artificial_delay &gt; 0\n        delay_time = self.artificial_delay\n        while not self._stop_event.is_set():\n            try:\n                chunk = next(self._data_iterator)\n                row = chunk.iloc[0]\n\n                symbol = row[\"symbol\"]\n                record_type = Models.RecordType(row[\"rtype\"])\n                symbol_key = (symbol, record_type)\n\n                with self._lock:\n                    if symbol_key not in self._watched_symbols:\n                        continue\n\n                bar_event = Events.IncomingBar(\n                    ts_event=pd.Timestamp(row[\"ts_event\"], unit=\"ns\", tz=\"UTC\"),\n                    symbol=symbol,\n                    record_type=record_type,\n                    open=row[\"open\"] / 1e9,\n                    high=row[\"high\"] / 1e9,\n                    low=row[\"low\"] / 1e9,\n                    close=row[\"close\"] / 1e9,\n                    volume=row[\"volume\"],\n                )\n\n                event_bus.publish(bar_event)\n\n                if should_delay and self._stop_event.wait(delay_time):\n                    break\n            except StopIteration:\n                logger.info(\"CSV datafeed reached end of file\")\n                break\n            except Exception as e:\n                logger.error(f\"CSV datafeed error reading data: {e}\")\n                break\n\n        with self._lock:\n            self._data_iterator = None\n            self._is_connected = False\n</code></pre>"},{"location":"api-reference/indicators/","title":"Indicators","text":"<p>OneSecondTrader's library of pre-built indicators.</p>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.BaseIndicator","title":"<code>BaseIndicator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for indicators. Subclasses must set the <code>name</code> property and implement the <code>_compute_indicator()</code> method. See <code>SimpleMovingAverage</code> for an example.</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class BaseIndicator(abc.ABC):\n    \"\"\"\n    Base class for indicators. Subclasses must set the `name` property and implement\n    the `_compute_indicator()` method. See `SimpleMovingAverage` for an example.\n    \"\"\"\n\n    def __init__(self, max_history: int = 100) -&gt; None:\n        self._lock = threading.Lock()\n        self._history: deque[float] = deque(maxlen=max(1, int(max_history)))\n\n    @property\n    @abc.abstractmethod\n    def name(self) -&gt; str:\n        pass\n\n    def update(self, incoming_bar: Events.IncomingBar) -&gt; None:\n        _latest_value: float = self._compute_indicator(incoming_bar)\n        with self._lock:\n            self._history.append(_latest_value)\n\n    @abc.abstractmethod\n    def _compute_indicator(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        pass\n\n    @property\n    def latest(self) -&gt; float:\n        with self._lock:\n            return self._history[-1] if self._history else np.nan\n\n    @property\n    def history(self) -&gt; deque[float]:\n        return self._history\n</code></pre>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.InputSource","title":"<code>InputSource</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum of supported input sources for indicators. Indicators with a <code>input_source</code> parameter can be configured to use one of these sources for their calculations.</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class InputSource(enum.Enum):\n    \"\"\"\n    Enum of supported input sources for indicators. Indicators with a `input_source`\n    parameter can be configured to use one of these sources for their calculations.\n    \"\"\"\n\n    OPEN = enum.auto()\n    HIGH = enum.auto()\n    LOW = enum.auto()\n    CLOSE = enum.auto()\n    VOLUME = enum.auto()\n</code></pre>"},{"location":"api-reference/indicators/#onesecondtrader.indicators.SimpleMovingAverage","title":"<code>SimpleMovingAverage</code>","text":"<p>               Bases: <code>BaseIndicator</code></p> <p>Simple Moving Average (SMA) indicator. Can be configured to use different input sources (see <code>InputSource</code> enum, default is <code>InputSource.CLOSE</code>).</p> Source code in <code>src/onesecondtrader/indicators.py</code> <pre><code>class SimpleMovingAverage(BaseIndicator):\n    \"\"\"\n    Simple Moving Average (SMA) indicator. Can be configured to use different input\n    sources (see `InputSource` enum, default is `InputSource.CLOSE`).\n    \"\"\"\n\n    def __init__(\n        self,\n        period: int = 200,\n        max_history: int = 100,\n        input_source: InputSource = InputSource.CLOSE,\n    ) -&gt; None:\n        super().__init__(max_history=max_history)\n        self.period: int = max(1, int(period))\n        self.input_source: InputSource = input_source\n        self._window: deque[float] = deque(maxlen=self.period)\n\n    @property\n    def name(self) -&gt; str:\n        return f\"SMA_{self.period}_{self.input_source.name}\"\n\n    def _compute_indicator(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        value: float = self._extract_input(incoming_bar)\n        self._window.append(value)\n        if len(self._window) &lt; self.period:\n            return np.nan\n        return sum(self._window) / self.period\n\n    def _extract_input(self, incoming_bar: Events.IncomingBar) -&gt; float:\n        match self.input_source:\n            case InputSource.OPEN:\n                return incoming_bar.open\n            case InputSource.HIGH:\n                return incoming_bar.high\n            case InputSource.LOW:\n                return incoming_bar.low\n            case InputSource.CLOSE:\n                return incoming_bar.close\n            case InputSource.VOLUME:\n                return (\n                    float(incoming_bar.volume)\n                    if incoming_bar.volume is not None\n                    else np.nan\n                )\n            case _:\n                return incoming_bar.close\n</code></pre>"},{"location":"api-reference/overview/","title":"API Reference","text":"<ul> <li> <p>Core </p> <p> View <code>core.py</code> API</p> </li> <li> <p>Datafeeds </p> <p> View <code>datafeeds.py</code> API</p> </li> <li> <p>Indicators </p> <p> View <code>indicators.py</code> API</p> </li> </ul>"}]}